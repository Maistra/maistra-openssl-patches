From f5f1a3f8c06d99bc44552880db4d3a49cc78b6f2 Mon Sep 17 00:00:00 2001
From: Dmitri Dolguikh <dmitri@appliedlogic.ca>
Date: Mon, 20 Apr 2020 16:17:16 -0700
Subject: [PATCH] Maistra 1.1 release

  b2327e0e        Dmitri Dolguikh Mon Mar 30 10:53:38 2020 -0700  Updated with latest envoy
  e876eaa8        Brian Avery     Thu Mar 26 18:36:58 2020 -0400  Updated SHA to pick up Envoy fixes
  1d7afe9c        Dmitri Dolguikh Tue Mar 24 09:38:08 2020 -0700  Fixes MAISTRA-1297 and MAISTRA-1291: sni-verifier no longer fails during TLS1.3 handshake
  83855328        brian-avery     Fri Mar 20 10:29:18 2020 -0400  Disable failing tests
  30f0c97f        Jonh Wendell    Mon Mar 16 18:50:06 2020 -0400  MAISTRA-1275: Bump Envoy version
  db1bba78        mergify[bot]    Mon Mar 16 17:34:11 2020 +0000  Merge pull request #14 from brian-avery/update146
  7b11782d        Brian Avery     Mon Mar 16 13:12:52 2020 -0400  Update hash
  54fa30a7        Brian Avery     Mon Mar 16 13:11:37 2020 -0400  Merge commit 'f777dd13e28edc4ff394e98cd82c82ca4a2bcc71' into update146
  e29db8ac        Brian Avery     Thu Feb 20 13:53:19 2020 -0500  Delete Docker BUILD
  6314c37d        Brian Avery     Wed Feb 19 19:22:13 2020 -0500  Update x_tools_imports.bzl
  b7d74a45        Brian Avery     Wed Feb 19 19:08:38 2020 -0500  Updated archives to archive
  aa374e51        Brian Avery     Tue Feb 18 15:37:15 2020 -0500  Update WORKSPACE
  d45d291a        Brian Avery     Tue Feb 18 15:32:17 2020 -0500  Cleanup
  e18b7ed2        Brian Avery     Tue Feb 18 15:17:43 2020 -0500  Remove docker from bazel
  7957f44e        mergify[bot]    Mon Feb 17 18:28:15 2020 +0000  Merge pull request #7 from brian-avery/maistra-1.1
  8d668d0f        Brian Avery     Mon Feb 17 13:25:13 2020 -0500  Update WORKSPACE
  e2245013        Brian Avery     Fri Feb 14 15:57:27 2020 -0500  Merge branch 'maistra-1.1' into maistra-1.1
  f2f340bc        Brian Avery     Fri Feb 14 15:55:01 2020 -0500  Updated version
  e885dd68        Dmitri Dolguikh Wed Feb 12 10:41:00 2020 -0800  changes from maistra/istio-proxy-openssl applied, build/test issues fixed, tests (not disabled ones) are passing
  b2327e0e        Dmitri Dolguikh Mon Mar 30 10:53:38 2020 -0700  Updated with latest envoy
  e876eaa8        Brian Avery     Thu Mar 26 18:36:58 2020 -0400  Updated SHA to pick up Envoy fixes
  1d7afe9c        Dmitri Dolguikh Tue Mar 24 09:38:08 2020 -0700  Fixes MAISTRA-1297 and MAISTRA-1291: sni-verifier no longer fails during TLS1.3 handshake
  83855328        brian-avery     Fri Mar 20 10:29:18 2020 -0400  Disable failing tests
  30f0c97f        Jonh Wendell    Mon Mar 16 18:50:06 2020 -0400  MAISTRA-1275: Bump Envoy version
  db1bba78        mergify[bot]    Mon Mar 16 17:34:11 2020 +0000  Merge pull request #14 from brian-avery/update146
  7b11782d        Brian Avery     Mon Mar 16 13:12:52 2020 -0400  Update hash
  54fa30a7        Brian Avery     Mon Mar 16 13:11:37 2020 -0400  Merge commit 'f777dd13e28edc4ff394e98cd82c82ca4a2bcc71' into update146
  e29db8ac        Brian Avery     Thu Feb 20 13:53:19 2020 -0500  Delete Docker BUILD
  6314c37d        Brian Avery     Wed Feb 19 19:22:13 2020 -0500  Update x_tools_imports.bzl
  b7d74a45        Brian Avery     Wed Feb 19 19:08:38 2020 -0500  Updated archives to archive
  aa374e51        Brian Avery     Tue Feb 18 15:37:15 2020 -0500  Update WORKSPACE
  d45d291a        Brian Avery     Tue Feb 18 15:32:17 2020 -0500  Cleanup
  e18b7ed2        Brian Avery     Tue Feb 18 15:17:43 2020 -0500  Remove docker from bazel
  7957f44e        mergify[bot]    Mon Feb 17 18:28:15 2020 +0000  Merge pull request #7 from brian-avery/maistra-1.1
  8d668d0f        Brian Avery     Mon Feb 17 13:25:13 2020 -0500  Update WORKSPACE
  e2245013        Brian Avery     Fri Feb 14 15:57:27 2020 -0500  Merge branch 'maistra-1.1' into maistra-1.1
  f2f340bc        Brian Avery     Fri Feb 14 15:55:01 2020 -0500  Updated version
  e885dd68        Dmitri Dolguikh Wed Feb 12 10:41:00 2020 -0800  changes from maistra/istio-proxy-openssl applied, build/test issues fixed, tests (not disabled ones) are passing
  6aba088f        Dmitri Dolguikh Tue Feb 11 16:42:55 2020 -0800  Updated to use envoy with an up to date version of jwt_verification_lib
  cd83c36f        Brian Avery     Tue Feb 11 17:23:12 2020 -0500  Updated SHA (#4)
  43b8866b        Brian Avery     Tue Feb 11 16:38:32 2020 -0500  Updated SHA
  dbf5bba5        Brian Avery     Tue Feb 11 15:51:55 2020 -0500  UPdate workspace
  32e0e407        Brian Avery     Tue Feb 11 15:49:12 2020 -0500  Updated Proxy workspace and SHA
  765ea0c4        Brian Avery     Tue Feb 11 16:04:46 2020 -0500  Updated to use the Maistra fork of Envoy (#3)
  5a49500b        Kevin Conner    Tue Aug 6 07:42:20 2019 -0700   switch mergify to rebase instead of merge
  9d2a46b1        Kevin Conner    Tue Jul 23 14:44:34 2019 -0700  Disabled commented-reviews-by
  182b74b9        Kevin Conner    Mon Jul 22 06:27:50 2019 -0700  Disable commit message lint: MAISTRA-667
  8758aa72        Kevin Conner    Fri Jul 19 12:24:00 2019 -0700  Update commit message lint to remove mergify message: MAISTRA-667
  b60eeaf6        Kevin Conner    Fri Jul 19 11:44:27 2019 -0700  Update commit message lint to include mergify: MAISTRA-667
  fe89adcc        Kevin Conner    Fri Jul 19 11:16:35 2019 -0700  Enable commit message lint
  a2400bfb        Kevin Conner    Thu Jul 18 19:15:07 2019 -0700  Add mergify.yml file
---
 .bazelignore                                  |     4 +
 .bazelrc                                      |     9 +
 ...Changes-and-fixes-to-support-OpenSSL.patch | 15326 ++++++++++++++++
 WORKSPACE                                     |    53 +-
 extensions/stats/plugin_test.cc               |    20 +-
 openssl.BUILD                                 |    11 +
 repositories.bzl                              |     7 -
 src/envoy/http/jwt_auth/jwt.cc                |    47 +-
 src/envoy/http/jwt_auth/jwt.h                 |     1 +
 src/envoy/tcp/sni_verifier/BUILD              |    17 +
 src/envoy/tcp/sni_verifier/openssl_impl.cc    |    23 +
 src/envoy/tcp/sni_verifier/openssl_impl.h     |    17 +
 src/envoy/tcp/sni_verifier/sni_verifier.cc    |    34 +-
 src/envoy/tcp/sni_verifier/sni_verifier.h     |     1 +
 .../tcp/sni_verifier/sni_verifier_test.cc     |     8 +-
 tools/docker/BUILD                            |    53 -
 x_tools_imports.bzl                           |     4 +-
 17 files changed, 15489 insertions(+), 146 deletions(-)
 create mode 100644 .bazelignore
 create mode 100644 0001-Changes-and-fixes-to-support-OpenSSL.patch
 create mode 100644 openssl.BUILD
 create mode 100644 src/envoy/tcp/sni_verifier/openssl_impl.cc
 create mode 100644 src/envoy/tcp/sni_verifier/openssl_impl.h
 delete mode 100644 tools/docker/BUILD

diff --git a/.bazelignore b/.bazelignore
new file mode 100644
index 00000000..e5b7c6cf
--- /dev/null
+++ b/.bazelignore
@@ -0,0 +1,4 @@
+test/common/stats
+test/extensions/filters/network/thrift_proxy
+test/extensions/tracers/dynamic_ot
+test/exe
diff --git a/.bazelrc b/.bazelrc
index 4772f718..52a9054f 100644
--- a/.bazelrc
+++ b/.bazelrc
@@ -188,3 +188,12 @@ build:debug -c dbg
 build --cxxopt -Wnon-virtual-dtor
 build --cxxopt -Wformat
 build --cxxopt -Wformat-security
+
+build --cxxopt -D_GLIBCXX_USE_CXX11_ABI=1
+build --cxxopt -DENVOY_IGNORE_GLIBCXX_USE_CXX11_ABI_ERROR=1
+build --cxxopt -D_FORTIFY_SOURCE=2
+build --cxxopt -Wno-error=deprecated-declarations
+build --cxxopt -Wno-error=unused-variable
+build --cxxopt -w
+build --cxxopt -ldl
+
diff --git a/0001-Changes-and-fixes-to-support-OpenSSL.patch b/0001-Changes-and-fixes-to-support-OpenSSL.patch
new file mode 100644
index 00000000..fb6296e0
--- /dev/null
+++ b/0001-Changes-and-fixes-to-support-OpenSSL.patch
@@ -0,0 +1,15326 @@
+From dcdcd36ff2bd8eaf91cb94f6f13fe3e6b4afa1ca Mon Sep 17 00:00:00 2001
+From: Dmitri Dolguikh <dmitri@appliedlogic.ca>
+Date: Fri, 17 Apr 2020 15:22:53 -0700
+Subject: [PATCH] Changes and fixes to support OpenSSL
+
+  8f2ed867ba      Tim Walsh       Tue Mar 31 03:42:57 2020 +1000  Fix for dual certificate issue MAISTRA-1142 (#10)
+  13d2925edf      Dmitri Dolguikh Thu Mar 26 14:00:00 2020 -0700  Fixes MAISTRA-1299: fix ASSERT failure and infinite loop when attempting to unset readDisable state on a closed connection, part 2 (#11)
+  a939c3c1a4      Dmitri Dolguikh Wed Mar 25 14:22:39 2020 -0700  Fixes MAISTRA-1299: fix ASSERT failure and infinite loop when attempting to unset readDisable state on a closed connection (#9)
+  09d777a2af      Jonh Wendell    Mon Mar 16 18:42:04 2020 -0400  Merge pull request #8 from jwendell/MAISTRA-1275
+  362b623330      Jonh Wendell    Mon Mar 16 18:33:04 2020 -0400  MAISTRA-1275: Write "OpenSSL" into envoy --version
+  61101255b6      Dmitri Dolguikh Fri Mar 13 10:43:59 2020 -0700  Merge pull request #7 from dmitri-d/maistra-1.1-upstream-release-1.4.6-patch
+  7f1eb1e504      Dmitri Dolguikh Thu Mar 12 16:19:25 2020 -0700  Removed no longer relevant comments from tls_inspector_test
+  8ccac219c4      Dmitri Dolguikh Thu Mar 12 10:49:01 2020 -0700  Fixing alpn detection in tls_inspector
+  cf0f50b960      Dmitri Dolguikh Thu Mar 12 14:10:23 2020 -0700  Updated bssl_wrapper to latest version
+  fac23c0658      Dmitri Dolguikh Thu Mar 12 14:38:36 2020 -0700  Merge branch 'upstream-release-1.4.6-patch' into maistra-1.1
+  0b12b160b9      Dmitri Dolguikh Mon Mar 9 10:55:57 2020 -0700   Fixes MAISTRA-1226: added support for importPublicKey in lua filter (#6)
+  e6e28d947a      Dmitri Dolguikh Fri Feb 28 14:59:58 2020 -0800  added an explanation why DynamicOpentracingHttpTracer has been disabled (#5)
+  7e505069b3      Dmitri Dolguikh Fri Feb 28 14:58:46 2020 -0800  added an explanation why DynamicOpentracingHttpTracer has been disabled (#4)
+  7fe19868ec      Dmitri Dolguikh Fri Feb 28 14:57:44 2020 -0800  Fixes MAISTRA-1167: RetryHostPredicateFilter in protocol_integration_test suite passes now (#3)
+  2c5d27e1c0      Dmitri Dolguikh Fri Feb 14 12:50:21 2020 -0800  Fixes MAISTRA-1167: //test/extensions/filters/listener/proxy_protocol:proxy_protocol_test is passing now (#2)
+  7d0995a9cb      Dmitri Dolguikh Fri Feb 14 12:49:59 2020 -0800  Merge pull request #1 from dmitri-d/fix-1168-certchain
+  ff116fa0d6      Dmitri Dolguikh Wed Feb 12 15:29:31 2020 -0800  Fixes MAISTRA-1168: added implementation of boringssl function SSL_get_peer_full_cert_chain
+  72c81ba8ce      Dmitri Dolguikh Tue Feb 11 16:27:50 2020 -0800  Updated jwt_verification_lib to the latest version
+  487d30c7b7      Dmitri Dolguikh Tue Feb 11 09:19:53 2020 -0800  Updated for maistra-1.1 release
+  071457c9c4      Dmitri Dolguikh Tue Feb 4 15:32:41 2020 -0800   updated to support openssl
+---
+ .bazelrc                                      |  12 +
+ WORKSPACE                                     |   6 +
+ bazel/BUILD                                   |   5 -
+ bazel/external/openssl_includes-1.patch       |  13 +
+ bazel/external/openssl_includes.BUILD         |  18 +
+ bazel/repositories.bzl                        |  66 +-
+ bazel/repository_locations.bzl                |  37 +-
+ include/envoy/ssl/private_key/private_key.h   |  10 +-
+ openssl.BUILD                                 |  11 +
+ source/common/common/BUILD                    |   6 +-
+ source/common/config/BUILD                    |   1 -
+ source/common/config/remote_data_fetcher.cc   |   6 +-
+ source/common/crypto/BUILD                    |   8 +-
+ source/common/crypto/utility.h                |  77 +-
+ source/common/http/http1/codec_impl.cc        |   2 +-
+ source/common/network/connection_impl.cc      |  26 +-
+ source/exe/BUILD                              |   3 +-
+ source/extensions/common/crypto/BUILD         |   4 +-
+ source/extensions/common/crypto/crypto_impl.h |   3 +-
+ .../crypto/{utility.cc => utility_impl.cc}    |  35 +-
+ .../extensions/common/crypto/utility_impl.h   |  35 +
+ source/extensions/common/wasm/wasm.cc         |   2 +-
+ source/extensions/extensions_build_config.bzl |   6 +
+ .../filters/http/common/aws/signer_impl.cc    |  29 +-
+ .../extensions/filters/http/jwt_authn/BUILD   |   7 +
+ source/extensions/filters/http/lua/BUILD      |   3 +
+ .../extensions/filters/http/lua/lua_filter.cc |   6 +-
+ .../extensions/filters/http/lua/lua_filter.h  |   1 -
+ .../filters/listener/tls_inspector/BUILD      |   8 +-
+ .../listener/tls_inspector/openssl_impl.cc    |  39 +
+ .../listener/tls_inspector/openssl_impl.h     |  24 +
+ .../listener/tls_inspector/tls_inspector.cc   |  78 +-
+ .../listener/tls_inspector/tls_inspector.h    |   9 +-
+ source/extensions/quic_listeners/quiche/BUILD | 269 ------
+ .../quiche/active_quic_listener.cc            |  86 --
+ .../quiche/active_quic_listener.h             |  98 ---
+ .../quiche/active_quic_listener_config.cc     |  25 -
+ .../quiche/active_quic_listener_config.h      |  27 -
+ .../quic_listeners/quiche/codec_impl.cc       |  23 -
+ .../quic_listeners/quiche/codec_impl.h        |  61 --
+ .../quic_listeners/quiche/envoy_quic_alarm.cc |  35 -
+ .../quic_listeners/quiche/envoy_quic_alarm.h  |  40 -
+ .../quiche/envoy_quic_alarm_factory.cc        |  22 -
+ .../quiche/envoy_quic_alarm_factory.h         |  39 -
+ .../quiche/envoy_quic_connection.cc           |  25 -
+ .../quiche/envoy_quic_connection.h            |  68 --
+ .../quiche/envoy_quic_connection_helper.h     |  42 -
+ .../quiche/envoy_quic_dispatcher.cc           |  60 --
+ .../quiche/envoy_quic_dispatcher.h            |  78 --
+ .../quiche/envoy_quic_fake_proof_source.h     |  88 --
+ .../quiche/envoy_quic_fake_proof_verifier.h   |  61 --
+ .../quiche/envoy_quic_packet_writer.cc        |  55 --
+ .../quiche/envoy_quic_packet_writer.h         |  50 --
+ .../quiche/envoy_quic_server_connection.cc    |  61 --
+ .../quiche/envoy_quic_server_connection.h     |  34 -
+ .../quiche/envoy_quic_server_session.cc       |  93 --
+ .../quiche/envoy_quic_server_session.h        |  73 --
+ .../quiche/envoy_quic_server_stream.cc        | 132 ---
+ .../quiche/envoy_quic_server_stream.h         |  52 --
+ .../quic_listeners/quiche/envoy_quic_stream.h |  42 -
+ .../quic_listeners/quiche/envoy_quic_utils.cc |  66 --
+ .../quic_listeners/quiche/envoy_quic_utils.h  |  29 -
+ .../quic_listeners/quiche/platform/BUILD      | 325 -------
+ .../quiche/platform/envoy_quic_clock.cc       |  30 -
+ .../quiche/platform/envoy_quic_clock.h        |  30 -
+ .../quiche/platform/flags_impl.cc             | 102 ---
+ .../quiche/platform/flags_impl.h              | 110 ---
+ .../quiche/platform/flags_list.h              | 503 -----------
+ .../quiche/platform/http2_arraysize_impl.h    |  11 -
+ .../quiche/platform/http2_bug_tracker_impl.h  |  13 -
+ .../quiche/platform/http2_containers_impl.h   |  15 -
+ .../http2_estimate_memory_usage_impl.h        |  15 -
+ .../quiche/platform/http2_export_impl.h       |  10 -
+ .../quiche/platform/http2_flag_utils_impl.h   |  11 -
+ .../quiche/platform/http2_flags_impl.h        |  14 -
+ .../quiche/platform/http2_logging_impl.h      |  23 -
+ .../quiche/platform/http2_macros_impl.h       |  26 -
+ .../quiche/platform/http2_optional_impl.h     |  15 -
+ .../quiche/platform/http2_ptr_util_impl.h     |  18 -
+ .../quiche/platform/http2_string_impl.h       |  15 -
+ .../quiche/platform/http2_string_piece_impl.h |  15 -
+ .../quiche/platform/http2_string_utils_impl.h |  47 -
+ .../quiche/platform/quic_aligned_impl.h       |  14 -
+ .../quiche/platform/quic_arraysize_impl.h     |  11 -
+ .../quiche/platform/quic_bbr2_sender_impl.h   |  15 -
+ .../quiche/platform/quic_bug_tracker_impl.h   |  16 -
+ .../quiche/platform/quic_cert_utils_impl.cc   |  68 --
+ .../quiche/platform/quic_cert_utils_impl.h    |  22 -
+ .../quiche/platform/quic_client_stats_impl.h  |  36 -
+ .../quiche/platform/quic_containers_impl.h    |  41 -
+ .../quiche/platform/quic_endian_impl.h        |  28 -
+ .../platform/quic_error_code_wrappers_impl.h  |  13 -
+ .../quic_estimate_memory_usage_impl.h         |  16 -
+ .../quiche/platform/quic_export_impl.h        |  10 -
+ .../quiche/platform/quic_fallthrough_impl.h   |  11 -
+ .../quiche/platform/quic_file_utils_impl.cc   |  55 --
+ .../quiche/platform/quic_file_utils_impl.h    |  28 -
+ .../quiche/platform/quic_flag_utils_impl.h    |  31 -
+ .../quiche/platform/quic_flags_impl.h         |  44 -
+ .../platform/quic_hostname_utils_impl.cc      |  48 --
+ .../platform/quic_hostname_utils_impl.h       |  36 -
+ .../quiche/platform/quic_iovec_impl.h         |  11 -
+ .../quiche/platform/quic_logging_impl.cc      |  81 --
+ .../quiche/platform/quic_logging_impl.h       | 184 ----
+ .../quiche/platform/quic_macros_impl.h        |  12 -
+ .../quiche/platform/quic_map_util_impl.h      |  23 -
+ .../quiche/platform/quic_mem_slice_impl.cc    |  45 -
+ .../quiche/platform/quic_mem_slice_impl.h     |  68 --
+ .../platform/quic_mem_slice_span_impl.cc      |  21 -
+ .../platform/quic_mem_slice_span_impl.h       |  78 --
+ .../platform/quic_mem_slice_storage_impl.cc   |  50 --
+ .../platform/quic_mem_slice_storage_impl.h    |  45 -
+ .../quiche/platform/quic_mutex_impl.h         |  60 --
+ .../quiche/platform/quic_optional_impl.h      |  15 -
+ .../quiche/platform/quic_pcc_sender_impl.h    |  32 -
+ .../quiche/platform/quic_prefetch_impl.h      |  19 -
+ .../quiche/platform/quic_ptr_util_impl.h      |  24 -
+ .../platform/quic_reference_counted_impl.h    | 106 ---
+ .../quiche/platform/quic_server_stats_impl.h  |  23 -
+ .../quiche/platform/quic_stack_trace_impl.h   |  24 -
+ .../quiche/platform/quic_str_cat_impl.h       |  22 -
+ .../quic_stream_buffer_allocator_impl.h       |  18 -
+ .../quiche/platform/quic_string_impl.h        |  15 -
+ .../quiche/platform/quic_string_piece_impl.h  |  15 -
+ .../quiche/platform/quic_string_utils_impl.h  |  18 -
+ .../quiche/platform/quic_text_utils_impl.h    |  81 --
+ .../quiche/platform/quic_uint128_impl.h       |  18 -
+ .../quiche/platform/quiche_logging_impl.h     |   9 -
+ .../quiche/platform/quiche_ptr_util_impl.h    |  17 -
+ .../quiche_unordered_containers_impl.h        |  21 -
+ .../quiche/platform/spdy_arraysize_impl.h     |  11 -
+ .../quiche/platform/spdy_bug_tracker_impl.h   |  13 -
+ .../quiche/platform/spdy_containers_impl.h    |  42 -
+ .../platform/spdy_endianness_util_impl.h      |  29 -
+ .../spdy_estimate_memory_usage_impl.h         |  16 -
+ .../quiche/platform/spdy_export_impl.h        |  10 -
+ .../quiche/platform/spdy_flags_impl.h         |  13 -
+ .../quiche/platform/spdy_logging_impl.h       |  21 -
+ .../quiche/platform/spdy_macros_impl.h        |  12 -
+ .../quiche/platform/spdy_map_util_impl.h      |  18 -
+ .../quiche/platform/spdy_mem_slice_impl.h     |  45 -
+ .../quiche/platform/spdy_ptr_util_impl.h      |  23 -
+ .../quiche/platform/spdy_string_impl.h        |  15 -
+ .../quiche/platform/spdy_string_piece_impl.h  |  15 -
+ .../quiche/platform/spdy_string_utils_impl.h  |  47 -
+ .../quiche/platform/spdy_test_helpers_impl.h  |  10 -
+ .../platform/spdy_test_utils_prod_impl.h      |  10 -
+ .../quiche/platform/spdy_unsafe_arena_impl.h  |  15 -
+ .../quiche/platform/string_utils.cc           |  96 ---
+ .../quiche/platform/string_utils.h            |  25 -
+ .../quic_filter_manager_connection_impl.cc    | 110 ---
+ .../quic_filter_manager_connection_impl.h     | 126 ---
+ .../quiche/quic_io_handle_wrapper.h           |  68 --
+ .../quiche/quic_transport_socket_factory.cc   |  48 --
+ .../quiche/quic_transport_socket_factory.h    |  94 --
+ .../spdy_server_push_utils_for_envoy.cc       |  37 -
+ source/extensions/transport_sockets/tls/BUILD |  19 +
+ .../tls/context_config_impl.cc                |  32 +-
+ .../tls/context_config_impl.h                 |   6 +
+ .../transport_sockets/tls/context_impl.cc     | 625 ++++++--------
+ .../transport_sockets/tls/context_impl.h      |  22 +-
+ .../tls/context_manager_impl.h                |   1 +
+ .../transport_sockets/tls/openssl_impl.cc     | 170 ++++
+ .../transport_sockets/tls/openssl_impl.h      |  57 ++
+ .../transport_sockets/tls/ssl_socket.cc       |   9 +-
+ .../transport_sockets/tls/ssl_socket.h        |   1 +
+ .../transport_sockets/tls/utility.cc          |  30 +-
+ .../transport_sockets/tls/utility.h           |   3 +
+ test/common/config/BUILD                      |  10 +-
+ test/common/crypto/BUILD                      |  10 +-
+ test/common/crypto/utility_test.cc            |  33 +-
+ test/common/network/connection_impl_test.cc   |  33 +-
+ .../filters/http/lua/lua_filter_test.cc       |   3 +
+ .../filters/http/lua/lua_integration_test.cc  |   3 +-
+ .../proxy_protocol/proxy_protocol_test.cc     |   7 +-
+ .../filters/listener/tls_inspector/BUILD      |   5 +-
+ .../listener/tls_inspector/tls_utility.cc     |   6 +-
+ test/extensions/quic_listeners/quiche/BUILD   | 182 ----
+ .../active_quic_listener_config_test.cc       |  48 --
+ .../quiche/active_quic_listener_test.cc       | 188 ----
+ .../quiche/crypto_test_utils_for_envoy.cc     |  39 -
+ .../quiche/envoy_quic_alarm_test.cc           | 193 -----
+ .../quiche/envoy_quic_dispatcher_test.cc      | 264 ------
+ .../quiche/envoy_quic_proof_source_test.cc    |  75 --
+ .../quiche/envoy_quic_server_session_test.cc  | 401 ---------
+ .../quiche/envoy_quic_server_stream_test.cc   | 252 ------
+ .../quiche/envoy_quic_utils_test.cc           |  65 --
+ .../quiche/envoy_quic_writer_test.cc          | 138 ---
+ .../quic_listeners/quiche/platform/BUILD      | 239 -----
+ .../quiche/platform/envoy_quic_clock_test.cc  |  78 --
+ .../platform/epoll_address_test_utils_impl.h  |  44 -
+ .../quiche/platform/epoll_bug_impl.h          |  11 -
+ .../quiche/platform/epoll_expect_bug_impl.h   |  11 -
+ .../quiche/platform/epoll_export_impl.h       |  10 -
+ .../quiche/platform/epoll_logging_impl.h      |  20 -
+ .../quiche/platform/epoll_ptr_util_impl.h     |  17 -
+ .../quiche/platform/epoll_test_impl.h         |  12 -
+ .../quiche/platform/epoll_thread_impl.h       |  15 -
+ .../quiche/platform/epoll_time_impl.h         |  15 -
+ .../quiche/platform/http2_platform_test.cc    | 147 ----
+ .../platform/http2_reconstruct_object_impl.h  |  32 -
+ .../quiche/platform/quic_epoll_clock.cc       |  38 -
+ .../quiche/platform/quic_epoll_clock.h        |  47 -
+ .../quiche/platform/quic_epoll_impl.h         |  18 -
+ .../quiche/platform/quic_expect_bug_impl.h    |  16 -
+ .../quiche/platform/quic_mock_log_impl.h      |  98 ---
+ .../quiche/platform/quic_platform_test.cc     | 814 ------------------
+ .../quiche/platform/quic_port_utils_impl.cc   |  44 -
+ .../quiche/platform/quic_port_utils_impl.h    |  16 -
+ .../quiche/platform/quic_sleep_impl.h         |  19 -
+ .../platform/quic_system_event_loop_impl.h    |  19 -
+ .../quiche/platform/quic_test_impl.h          |  28 -
+ .../quic_test_mem_slice_vector_impl.h         |  36 -
+ .../quiche/platform/quic_test_output_impl.cc  |  79 --
+ .../quiche/platform/quic_test_output_impl.h   |  15 -
+ .../quiche/platform/quic_thread_impl.h        |  72 --
+ .../quiche/platform/quiche_test_impl.h        |  10 -
+ .../quiche/platform/spdy_platform_test.cc     | 135 ---
+ .../quiche/platform/spdy_test_helpers_impl.h  |  11 -
+ .../quiche/platform/spdy_test_impl.h          |  10 -
+ .../quiche/quic_io_handle_wrapper_test.cc     |  88 --
+ .../tracers/dynamic_ot/config_test.cc         |   6 +-
+ .../dynamic_opentracing_driver_impl_test.cc   |  12 +-
+ test/extensions/transport_sockets/tls/BUILD   |  27 +-
+ .../tls/context_impl_test.cc                  |  17 +-
+ .../tls/integration/ssl_integration_test.cc   |   2 +
+ .../transport_sockets/tls/ssl_socket_test.cc  |  97 ++-
+ .../transport_sockets/tls/ssl_test_utility.h  |   1 +
+ .../transport_sockets/tls/utility_test.cc     |   9 +-
+ test/integration/integration_test.cc          |  25 +
+ test/integration/protocol_integration_test.cc |   1 -
+ test/mocks/ssl/mocks.h                        |   5 +-
+ test/server/BUILD                             |  15 -
+ .../listener_manager_impl_quic_only_test.cc   |  82 --
+ test/test_common/utility.h                    |   2 +-
+ 235 files changed, 1164 insertions(+), 10776 deletions(-)
+ create mode 100644 bazel/external/openssl_includes-1.patch
+ create mode 100644 bazel/external/openssl_includes.BUILD
+ create mode 100644 openssl.BUILD
+ rename source/extensions/common/crypto/{utility.cc => utility_impl.cc} (72%)
+ create mode 100644 source/extensions/common/crypto/utility_impl.h
+ create mode 100644 source/extensions/filters/listener/tls_inspector/openssl_impl.cc
+ create mode 100644 source/extensions/filters/listener/tls_inspector/openssl_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/BUILD
+ delete mode 100644 source/extensions/quic_listeners/quiche/active_quic_listener.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/active_quic_listener.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/active_quic_listener_config.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/active_quic_listener_config.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/codec_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/codec_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_alarm.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_alarm.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_connection.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_connection.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_connection_helper.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_connection.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_connection.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_session.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_session.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_stream.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_server_stream.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_stream.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_utils.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/envoy_quic_utils.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/BUILD
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/flags_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/flags_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/flags_list.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_arraysize_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_bug_tracker_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_containers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_estimate_memory_usage_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_export_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_flag_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_flags_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_logging_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_macros_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_optional_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_ptr_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_string_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_string_piece_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/http2_string_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_aligned_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_arraysize_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_bbr2_sender_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_client_stats_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_containers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_endian_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_error_code_wrappers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_estimate_memory_usage_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_export_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_fallthrough_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_flag_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_flags_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_iovec_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_logging_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_logging_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_macros_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_map_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_mutex_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_optional_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_pcc_sender_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_prefetch_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_ptr_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_reference_counted_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_server_stats_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_stack_trace_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_str_cat_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_stream_buffer_allocator_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_string_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_string_piece_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_string_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_text_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quic_uint128_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quiche_logging_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quiche_ptr_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/quiche_unordered_containers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_arraysize_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_bug_tracker_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_containers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_endianness_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_estimate_memory_usage_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_export_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_flags_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_logging_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_macros_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_map_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_mem_slice_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_ptr_util_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_string_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_string_piece_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_string_utils_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_test_utils_prod_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/spdy_unsafe_arena_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/string_utils.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/platform/string_utils.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/quic_io_handle_wrapper.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/quic_transport_socket_factory.cc
+ delete mode 100644 source/extensions/quic_listeners/quiche/quic_transport_socket_factory.h
+ delete mode 100644 source/extensions/quic_listeners/quiche/spdy_server_push_utils_for_envoy.cc
+ create mode 100644 source/extensions/transport_sockets/tls/openssl_impl.cc
+ create mode 100644 source/extensions/transport_sockets/tls/openssl_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/BUILD
+ delete mode 100644 test/extensions/quic_listeners/quiche/active_quic_listener_config_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/active_quic_listener_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/crypto_test_utils_for_envoy.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_alarm_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_dispatcher_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_proof_source_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_server_session_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_server_stream_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_utils_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/envoy_quic_writer_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/BUILD
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/envoy_quic_clock_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_address_test_utils_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_bug_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_expect_bug_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_export_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_logging_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_ptr_util_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_test_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_thread_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/epoll_time_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/http2_platform_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/http2_reconstruct_object_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_epoll_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_mock_log_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_platform_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_sleep_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_system_event_loop_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_test_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_test_mem_slice_vector_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quic_thread_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/quiche_test_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/spdy_platform_test.cc
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/platform/spdy_test_impl.h
+ delete mode 100644 test/extensions/quic_listeners/quiche/quic_io_handle_wrapper_test.cc
+ delete mode 100644 test/server/listener_manager_impl_quic_only_test.cc
+
+diff --git a/.bazelrc b/.bazelrc
+index 8cffa9f703..b0021d1d0b 100644
+--- a/.bazelrc
++++ b/.bazelrc
+@@ -166,3 +166,15 @@ build:asan-fuzzer --test_env=UBSAN_OPTIONS=print_stacktrace=1
+ 
+ try-import clang.bazelrc
+ try-import user.bazelrc
++
++build --cxxopt -D_GLIBCXX_USE_CXX11_ABI=1
++build --cxxopt -DENVOY_IGNORE_GLIBCXX_USE_CXX11_ABI_ERROR=1
++build --cxxopt -Wnon-virtual-dtor
++build --cxxopt -Wformat
++build --cxxopt -Wformat-security
++build --cxxopt -Wno-error=deprecated-declarations
++build --cxxopt -Wno-error=unused-variable
++build --cxxopt -w
++build --cxxopt -ldl
++build --copt -DOPENSSL_IS_BORINGSSL=0
++
+diff --git a/WORKSPACE b/WORKSPACE
+index ef120bc53d..74614212d2 100644
+--- a/WORKSPACE
++++ b/WORKSPACE
+@@ -15,3 +15,9 @@ envoy_dependencies()
+ load("//bazel:dependency_imports.bzl", "envoy_dependency_imports")
+ 
+ envoy_dependency_imports()
++
++new_local_repository(
++    name = "openssl",
++    path = "/usr/lib64/",
++    build_file = "openssl.BUILD"
++)
+diff --git a/bazel/BUILD b/bazel/BUILD
+index 51d4703a3a..776798174a 100644
+--- a/bazel/BUILD
++++ b/bazel/BUILD
+@@ -372,8 +372,3 @@ alias(
+         },
+     ),
+ )
+-
+-alias(
+-    name = "crypto_utility_lib",
+-    actual = "//source/extensions/common/crypto:utility_lib",
+-)
+diff --git a/bazel/external/openssl_includes-1.patch b/bazel/external/openssl_includes-1.patch
+new file mode 100644
+index 0000000000..a86a2820f3
+--- /dev/null
++++ b/bazel/external/openssl_includes-1.patch
+@@ -0,0 +1,13 @@
++diff --git a/ssl/packet_locl.h b/ssl/packet_locl.h
++index 860360b8b2..49c719285f 100644
++--- a/ssl/packet_locl.h
+++++ b/ssl/packet_locl.h
++@@ -426,7 +426,7 @@ __owur static ossl_inline int PACKET_memdup(const PACKET *pkt,
++     if (length == 0)
++         return 1;
++ 
++-    *data = OPENSSL_memdup(pkt->curr, length);
+++    *data = (unsigned char *)OPENSSL_memdup(pkt->curr, length);
++     if (*data == NULL)
++         return 0;
++ 
+diff --git a/bazel/external/openssl_includes.BUILD b/bazel/external/openssl_includes.BUILD
+new file mode 100644
+index 0000000000..60224a951b
+--- /dev/null
++++ b/bazel/external/openssl_includes.BUILD
+@@ -0,0 +1,18 @@
++cc_library(
++    name = "openssl_includes_lib",
++    copts = ["-Wno-error=error"],
++    hdrs = [
++            "e_os.h", 
++            "ssl/ssl_locl.h", 
++            "ssl/packet_locl.h", 
++            "ssl/record/record.h", 
++            "ssl/statem/statem.h", 
++            "include/internal/dane.h",
++            "include/internal/nelem.h",
++            "include/internal/numbers.h",
++            "include/internal/refcount.h",
++            "include/internal/tsan_assist.h",
++    ],
++    includes = ["ssl", "ssl/record", "ssl/statem", "include",],
++    visibility = ["//visibility:public"],
++)
+diff --git a/bazel/repositories.bzl b/bazel/repositories.bzl
+index f6b3466a52..8c32745b41 100644
+--- a/bazel/repositories.bzl
++++ b/bazel/repositories.bzl
+@@ -6,14 +6,6 @@ load("@com_google_googleapis//:repository_rules.bzl", "switched_rules_by_languag
+ 
+ # dict of {build recipe name: longform extension name,}
+ PPC_SKIP_TARGETS = {"luajit": "envoy.filters.http.lua"}
+-NOBORINGSSL_SKIP_TARGETS = {
+-    # The lua filter depends on BoringSSL
+-    "lua": "envoy.filters.http.lua",
+-
+-    # These two extensions are supposed to be replaced with alternative extensions.
+-    "tls": "envoy.transport_sockets.tls",
+-    "tls_inspector": "envoy.filters.listener.tls_inspector",
+-}
+ 
+ # Make all contents of an external repository accessible under a filegroup.  Used for external HTTP
+ # archives, e.g. cares.
+@@ -114,12 +106,13 @@ def envoy_dependencies(skip_targets = []):
+     # Binding to an alias pointing to the selected version of BoringSSL:
+     # - BoringSSL FIPS from @boringssl_fips//:ssl,
+     # - non-FIPS BoringSSL from @boringssl//:ssl.
+-    _boringssl()
+-    _boringssl_fips()
+-    native.bind(
+-        name = "ssl",
+-        actual = "@envoy//bazel:boringssl",
+-    )
++
++    # EXTERNAL OPENSSL
++    _openssl()
++    _openssl_includes()
++    _bssl_wrapper()
++    _openssl_cbs()
++
+ 
+     # The long repo names (`com_github_fmtlib_fmt` instead of `fmtlib`) are
+     # semi-standard in the Bazel community, intended to avoid both duplicate
+@@ -150,7 +143,6 @@ def envoy_dependencies(skip_targets = []):
+     _io_opencensus_cpp()
+     _com_github_curl()
+     _com_github_envoyproxy_sqlparser()
+-    _com_googlesource_quiche()
+     _com_googlesource_chromium_v8()
+     _org_llvm_llvm()
+     _com_github_wavm_wavm()
+@@ -184,23 +176,45 @@ def envoy_dependencies(skip_targets = []):
+         actual = "@bazel_tools//tools/cpp/runfiles",
+     )
+ 
+-def _boringssl():
++#EXTERNAL OPENSSL
++def _openssl():
++    native.bind(
++        name = "ssl",
++        actual = "@openssl//:openssl-lib",
++)
++
++def _openssl_includes():
+     _repository_impl(
+-        name = "boringssl",
++        name = "com_github_openssl_openssl",
++        build_file = "@envoy//bazel/external:openssl_includes.BUILD",
++        patches = [
++            "@envoy//bazel/external:openssl_includes-1.patch",
++        ],
+         patch_args = ["-p1"],
+-        patches = ["@envoy//bazel:boringssl_static.patch"],
+     )
++    native.bind(
++        name = "openssl_includes_lib",
++        actual = "@com_github_openssl_openssl//:openssl_includes_lib",
++)
+ 
+-def _boringssl_fips():
+-    location = REPOSITORY_LOCATIONS["boringssl_fips"]
+-    genrule_repository(
+-        name = "boringssl_fips",
+-        urls = location["urls"],
+-        sha256 = location["sha256"],
+-        genrule_cmd_file = "@envoy//bazel/external:boringssl_fips.genrule_cmd",
+-        build_file = "@envoy//bazel/external:boringssl_fips.BUILD",
++
++#EXTERNAL OPENSSL
++def _bssl_wrapper():
++    _repository_impl("bssl_wrapper")
++    native.bind(
++        name = "bssl_wrapper_lib",
++        actual = "@bssl_wrapper//:bssl_wrapper_lib",
+     )
+ 
++#EXTERNAL OPENSSL
++def _openssl_cbs():
++    _repository_impl("openssl_cbs")
++    native.bind(
++        name = "openssl_cbs_lib",
++        actual = "@openssl_cbs//:openssl_cbs_lib",
++    )
++
++
+ def _com_github_circonus_labs_libcircllhist():
+     _repository_impl(
+         name = "com_github_circonus_labs_libcircllhist",
+diff --git a/bazel/repository_locations.bzl b/bazel/repository_locations.bzl
+index 802e939161..da71422b38 100644
+--- a/bazel/repository_locations.bzl
++++ b/bazel/repository_locations.bzl
+@@ -21,21 +21,22 @@ REPOSITORY_LOCATIONS = dict(
+         strip_prefix = "envoy-build-tools-a6b28555badcb18d6be924c8fc1bea49971656b8",
+         urls = ["https://github.com/envoyproxy/envoy-build-tools/archive/a6b28555badcb18d6be924c8fc1bea49971656b8.tar.gz"],
+     ),
+-    boringssl = dict(
+-        sha256 = "891352824e0f7977bc0c291b8c65076e3ed23630334841b93f346f12d4484b06",
+-        strip_prefix = "boringssl-5565939d4203234ddc742c02241ce4523e7b3beb",
+-        # To update BoringSSL, which tracks Chromium releases:
+-        # 1. Open https://omahaproxy.appspot.com/ and note <current_version> of linux/beta release.
+-        # 2. Open https://chromium.googlesource.com/chromium/src/+/refs/tags/<current_version>/DEPS and note <boringssl_revision>.
+-        # 3. Find a commit in BoringSSL's "master-with-bazel" branch that merges <boringssl_revision>.
+-        #
+-        # chromium-78.0.3904.21 (BETA)
+-        urls = ["https://github.com/google/boringssl/archive/5565939d4203234ddc742c02241ce4523e7b3beb.tar.gz"],
+-    ),
+-    boringssl_fips = dict(
+-        sha256 = "b12ad676ee533824f698741bd127f6fbc82c46344398a6d78d25e62c6c418c73",
+-        # fips-20180730
+-        urls = ["https://commondatastorage.googleapis.com/chromium-boringssl-docs/fips/boringssl-66005f41fbc3529ffe8d007708756720529da20d.tar.xz"],
++    com_github_openssl_openssl = dict(
++        sha256 = "cf26f056a955cff721d3a3c08d8126d1e4f69803e08c9600dac3b6b7158586d6",
++        strip_prefix = "openssl-894da2fb7ed5d314ee5c2fc9fd2d9b8b74111596",
++        urls = ["https://github.com/openssl/openssl/archive/894da2fb7ed5d314ee5c2fc9fd2d9b8b74111596.tar.gz"],
++     ),
++    #EXTERNAL OPENSSL
++    bssl_wrapper = dict(
++        sha256 = "d84ea7d190210145695e5b172e8e6fb23f3464360da5efab5a1ae1a973c21f57",
++        strip_prefix = "bssl_wrapper-c9649facde3ab1d8bc871c7375a8946c50950e97",
++        urls = ["https://github.com/maistra/bssl_wrapper/archive/c9649facde3ab1d8bc871c7375a8946c50950e97.tar.gz"],
++    ),
++    #EXTERNAL OPENSSL
++    openssl_cbs = dict(
++        sha256 = "f466ca7bc4b876cfa9edb4870275207e580588f85f8fae268c40277846a6d8de",
++        strip_prefix = "openssl-cbs-dab3282af49f134766abcda5f95cbb19057a53d1",
++        urls = ["https://github.com/maistra/openssl-cbs/archive/dab3282af49f134766abcda5f95cbb19057a53d1.tar.gz"],
+     ),
+     com_google_absl = dict(
+         sha256 = "3df5970908ed9a09ba51388d04661803a6af18c373866f442cede7f381e0b94a",
+@@ -174,10 +175,10 @@ REPOSITORY_LOCATIONS = dict(
+         urls = ["https://github.com/msgpack/msgpack-c/releases/download/cpp-3.2.0/msgpack-3.2.0.tar.gz"],
+     ),
+     com_github_google_jwt_verify = dict(
+-        sha256 = "7c937f61b4dbe7881bc3a03327150ec44b30b310c65a21ee621f083e665056f3",
+-        strip_prefix = "jwt_verify_lib-14fbfce0ba1b05b6aeb2908b3ce825a52ccb6450",
++        sha256 = "974826c9ba8060d9656e6c360718e3ee5eb1622ff59ed4138f8a3cd718ea7b13",
++        strip_prefix = "jwt_verify_lib-2c7ddcd871c3d902e089787e244ebe49723652cc",
+         # 2019-12-20
+-        urls = ["https://github.com/google/jwt_verify_lib/archive/14fbfce0ba1b05b6aeb2908b3ce825a52ccb6450.tar.gz"],
++        urls = ["https://github.com/Maistra/jwt_verify_lib/archive/2c7ddcd871c3d902e089787e244ebe49723652cc.tar.gz"],
+     ),
+     com_github_nodejs_http_parser = dict(
+         sha256 = "ef26268c54c8084d17654ba2ed5140bffeffd2a040a895ffb22a6cca3f6c613f",
+diff --git a/include/envoy/ssl/private_key/private_key.h b/include/envoy/ssl/private_key/private_key.h
+index e972d608cd..8d69e60e99 100644
+--- a/include/envoy/ssl/private_key/private_key.h
++++ b/include/envoy/ssl/private_key/private_key.h
+@@ -20,7 +20,10 @@ class TransportSocketFactoryContext;
+ 
+ namespace Ssl {
+ 
+-using BoringSslPrivateKeyMethodSharedPtr = std::shared_ptr<SSL_PRIVATE_KEY_METHOD>;
++// TODO (dmitri-d) figure out a way to propagate -D compiler option to sub-projects, atm only the top-level is affected
++#ifdef OPENSSL_IS_BORINGSSL
++//using BoringSslPrivateKeyMethodSharedPtr = std::shared_ptr<SSL_PRIVATE_KEY_METHOD>;
++#endif
+ 
+ class PrivateKeyMethodProvider {
+ public:
+@@ -49,12 +52,15 @@ public:
+    */
+   virtual bool checkFips() PURE;
+ 
++// TODO (dmitri-d) figure out a way to propagate -D compiler option to sub-projects, atm only the top-level is affected
++#ifdef OPENSSL_IS_BORINGSSL
+   /**
+    * Get the private key methods from the provider.
+    * @return the private key methods associated with this provider and
+    * configuration.
+    */
+-  virtual BoringSslPrivateKeyMethodSharedPtr getBoringSslPrivateKeyMethod() PURE;
++//  virtual BoringSslPrivateKeyMethodSharedPtr getBoringSslPrivateKeyMethod() PURE;
++#endif
+ };
+ 
+ using PrivateKeyMethodProviderSharedPtr = std::shared_ptr<PrivateKeyMethodProvider>;
+diff --git a/openssl.BUILD b/openssl.BUILD
+new file mode 100644
+index 0000000000..0cc6e93858
+--- /dev/null
++++ b/openssl.BUILD
+@@ -0,0 +1,11 @@
++licenses(["notice"])  # Apache 2
++
++cc_library(
++    name = "openssl-lib",
++    srcs = [
++        "libssl.so.1.1",
++        "libcrypto.so.1.1",
++    ],
++    visibility = ["//visibility:public"],
++    linkstatic=False,
++)
+diff --git a/source/common/common/BUILD b/source/common/common/BUILD
+index c8e4b2ae5b..bbd8dfbc79 100644
+--- a/source/common/common/BUILD
++++ b/source/common/common/BUILD
+@@ -9,7 +9,6 @@ load(
+     "envoy_cc_win32_library",
+     "envoy_include_prefix",
+     "envoy_package",
+-    "envoy_select_boringssl",
+ )
+ 
+ envoy_package()
+@@ -321,10 +320,7 @@ envoy_cc_library(
+         # This is done so that the definitions linked via the linkstamp rule don't cause collisions.
+         "//conditions:default": [":generate_version_linkstamp_empty"],
+     }),
+-    copts = envoy_select_boringssl(
+-        ["-DENVOY_SSL_VERSION=\\\"BoringSSL-FIPS\\\""],
+-        ["-DENVOY_SSL_VERSION=\\\"BoringSSL\\\""],
+-    ),
++    copts = ["-DENVOY_SSL_VERSION=\\\"OpenSSL_1.1.1d\\\""],
+     linkstamp = "version_linkstamp.cc",
+     strip_include_prefix = select({
+         "//bazel:manual_stamp": "lib",
+diff --git a/source/common/config/BUILD b/source/common/config/BUILD
+index 698f040621..49514eb6a3 100644
+--- a/source/common/config/BUILD
++++ b/source/common/config/BUILD
+@@ -328,7 +328,6 @@ envoy_cc_library(
+     srcs = ["remote_data_fetcher.cc"],
+     hdrs = ["remote_data_fetcher.h"],
+     deps = [
+-        "//bazel:crypto_utility_lib",
+         "//include/envoy/upstream:cluster_manager_interface",
+         "//source/common/common:hex_lib",
+         "//source/common/crypto:utility_lib",
+diff --git a/source/common/config/remote_data_fetcher.cc b/source/common/config/remote_data_fetcher.cc
+index 8e79e35fc8..a2220184f8 100644
+--- a/source/common/config/remote_data_fetcher.cc
++++ b/source/common/config/remote_data_fetcher.cc
+@@ -42,8 +42,8 @@ void RemoteDataFetcher::onSuccess(Http::MessagePtr&& response) {
+   if (status_code == enumToInt(Http::Code::OK)) {
+     ENVOY_LOG(debug, "fetch remote data [uri = {}]: success", uri_.uri());
+     if (response->body()) {
+-      const auto content_hash =
+-          Hex::encode(Envoy::Common::Crypto::Utility::getSha256Digest(*response->body()));
++      auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
++      const auto content_hash = Hex::encode(crypto_util.getSha256Digest(*response->body()));
+ 
+       if (content_hash_ != content_hash) {
+         ENVOY_LOG(debug, "fetch remote data [uri = {}]: data is invalid", uri_.uri());
+@@ -72,4 +72,4 @@ void RemoteDataFetcher::onFailure(Http::AsyncClient::FailureReason reason) {
+ 
+ } // namespace DataFetcher
+ } // namespace Config
+-} // namespace Envoy
+\ No newline at end of file
++} // namespace Envoy
+diff --git a/source/common/crypto/BUILD b/source/common/crypto/BUILD
+index dbe408e3fd..e0a99ff004 100644
+--- a/source/common/crypto/BUILD
++++ b/source/common/crypto/BUILD
+@@ -9,7 +9,12 @@ load(
+ envoy_package()
+ 
+ envoy_cc_library(
+-    name = "utility_lib",
++   name = "utility_lib",
++   external_deps = [
++     "ssl",
++     "openssl_cbs_lib",
++     "bssl_wrapper_lib"
++    ],
+     hdrs = [
+         "utility.h",
+     ],
+@@ -18,5 +23,6 @@ envoy_cc_library(
+         "//include/envoy/common/crypto:crypto_interface",
+         "//source/common/common:assert_lib",
+         "//source/common/common:stack_array",
++        "//source/common/singleton:threadsafe_singleton",
+     ],
+ )
+diff --git a/source/common/crypto/utility.h b/source/common/crypto/utility.h
+index 8a45ae14f2..4129f68c81 100644
+--- a/source/common/crypto/utility.h
++++ b/source/common/crypto/utility.h
+@@ -3,9 +3,12 @@
+ #include <cstdint>
+ #include <vector>
+ 
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "envoy/buffer/buffer.h"
+ #include "envoy/common/crypto/crypto.h"
+ 
++#include "common/singleton/threadsafe_singleton.h"
++
+ #include "absl/strings/string_view.h"
+ 
+ namespace Envoy {
+@@ -25,44 +28,50 @@ struct VerificationOutput {
+   std::string error_message_;
+ };
+ 
+-namespace Utility {
++class Utility {
++public:
++  virtual ~Utility() = default;
+ 
+-/**
+- * Computes the SHA-256 digest of a buffer.
+- * @param buffer the buffer.
+- * @return a vector of bytes for the computed digest.
+- */
+-std::vector<uint8_t> getSha256Digest(const Buffer::Instance& buffer);
++  /**
++   * Computes the SHA-256 digest of a buffer.
++   * @param buffer the buffer.
++   * @return a vector of bytes for the computed digest.
++   */
++  virtual std::vector<uint8_t> getSha256Digest(const Buffer::Instance& buffer) PURE;
+ 
+-/**
+- * Computes the SHA-256 HMAC for a given key and message.
+- * @param key the HMAC function key.
+- * @param message message data for the HMAC function.
+- * @return a vector of bytes for the computed HMAC.
+- */
+-std::vector<uint8_t> getSha256Hmac(const std::vector<uint8_t>& key, absl::string_view message);
++  /**
++   * Computes the SHA-256 HMAC for a given key and message.
++   * @param key the HMAC function key.
++   * @param message message data for the HMAC function.
++   * @return a vector of bytes for the computed HMAC.
++   */
++  virtual std::vector<uint8_t> getSha256Hmac(const std::vector<uint8_t>& key,
++                                             absl::string_view message) PURE;
+ 
+-/**
+- * Verify cryptographic signatures.
+- * @param hash hash function(including SHA1, SHA224, SHA256, SHA384, SHA512)
+- * @param key pointer to EVP_PKEY public key
+- * @param signature signature
+- * @param text clear text
+- * @return If the result_ is true, the error_message_ is empty; otherwise,
+- * the error_message_ stores the error message
+- */
+-const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& key,
+-                                         const std::vector<uint8_t>& signature,
+-                                         const std::vector<uint8_t>& text);
++  /**
++   * Verify cryptographic signatures.
++   * @param hash hash function(including SHA1, SHA224, SHA256, SHA384, SHA512)
++   * @param key pointer to EVP_PKEY public key
++   * @param signature signature
++   * @param text clear text
++   * @return If the result_ is true, the error_message_ is empty; otherwise,
++   * the error_message_ stores the error message
++   */
++  virtual const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& key,
++                                                   const std::vector<uint8_t>& signature,
++                                                   const std::vector<uint8_t>& text) PURE;
++
++  /**
++   * Import public key.
++   * @param key key string
++   * @return pointer to EVP_PKEY public key
++   */
++  virtual CryptoObjectPtr importPublicKey(const std::vector<uint8_t>& key) PURE;
++};
+ 
+-/**
+- * Import public key.
+- * @param key key string
+- * @return pointer to EVP_PKEY public key
+- */
+-CryptoObjectPtr importPublicKey(const std::vector<uint8_t>& key);
++using UtilitySingleton = InjectableSingleton<Utility>;
++using ScopedUtilitySingleton = ScopedInjectableLoader<Utility>;
+ 
+-} // namespace Utility
+ } // namespace Crypto
+ } // namespace Common
+-} // namespace Envoy
++} // namespace Envoy
+\ No newline at end of file
+diff --git a/source/common/http/http1/codec_impl.cc b/source/common/http/http1/codec_impl.cc
+index ef6ece4380..ac1826a534 100644
+--- a/source/common/http/http1/codec_impl.cc
++++ b/source/common/http/http1/codec_impl.cc
+@@ -894,7 +894,7 @@ void ClientConnectionImpl::onMessageComplete() {
+     // reused, unwind any outstanding readDisable() calls here. Only do this if there are no
+     // pipelined responses remaining. Also do this before we dispatch end_stream in case the caller
+     // immediately reuses the connection.
+-    if (pending_responses_.empty()) {
++    if (connection_.state() == Network::Connection::State::Open && pending_responses_.empty()) {
+       while (!connection_.readEnabled()) {
+         connection_.readDisable(false);
+       }
+diff --git a/source/common/network/connection_impl.cc b/source/common/network/connection_impl.cc
+index 15e76a9128..1c82507119 100644
+--- a/source/common/network/connection_impl.cc
++++ b/source/common/network/connection_impl.cc
+@@ -292,12 +292,10 @@ void ConnectionImpl::enableHalfClose(bool enabled) {
+ 
+ void ConnectionImpl::readDisable(bool disable) {
+   ASSERT(state() == State::Open);
+-  if (state() != State::Open || file_event_ == nullptr) {
+-    // If readDisable is called on a closed connection in error, do not crash.
+-    return;
+-  }
++  ASSERT(file_event_ != nullptr);
+ 
+-  ENVOY_CONN_LOG(trace, "readDisable: enabled={} disable={}", *this, read_enabled_, disable);
++  ENVOY_CONN_LOG(trace, "readDisable: enabled={} disable={} state={}", *this, read_enabled_,
++                 disable, static_cast<int>(state()));
+ 
+   // When we disable reads, we still allow for early close notifications (the equivalent of
+   // EPOLLRDHUP for an epoll backend). For backends that support it, this allows us to apply
+@@ -314,6 +312,11 @@ void ConnectionImpl::readDisable(bool disable) {
+     ASSERT(read_enabled_);
+     read_enabled_ = false;
+ 
++    if (state() != State::Open || file_event_ == nullptr) {
++      // If readDisable is called on a closed connection, do not crash.
++      return;
++    }
++
+     // If half-close semantics are enabled, we never want early close notifications; we
+     // always want to read all available data, even if the other side has closed.
+     if (detect_early_close_ && !enable_half_close_) {
+@@ -328,6 +331,12 @@ void ConnectionImpl::readDisable(bool disable) {
+     }
+     ASSERT(!read_enabled_);
+     read_enabled_ = true;
++
++    if (state() != State::Open || file_event_ == nullptr) {
++      // If readDisable is called on a closed connection, do not crash.
++      return;
++    }
++
+     // We never ask for both early close and read at the same time. If we are reading, we want to
+     // consume all available data.
+     file_event_->setEnabled(Event::FileReadyType::Read | Event::FileReadyType::Write);
+@@ -358,7 +367,12 @@ void ConnectionImpl::raiseEvent(ConnectionEvent event) {
+   }
+ }
+ 
+-bool ConnectionImpl::readEnabled() const { return read_enabled_; }
++bool ConnectionImpl::readEnabled() const {
++  // Calls to readEnabled on a closed socket are considered to be an error.
++  ASSERT(state() == State::Open);
++  ASSERT(file_event_ != nullptr);
++  return read_enabled_;
++}
+ 
+ void ConnectionImpl::addConnectionCallbacks(ConnectionCallbacks& cb) { callbacks_.push_back(&cb); }
+ 
+diff --git a/source/exe/BUILD b/source/exe/BUILD
+index 719cded40c..43ff9f36fd 100644
+--- a/source/exe/BUILD
++++ b/source/exe/BUILD
+@@ -14,7 +14,7 @@ load(
+     "envoy_all_extensions",
+     "envoy_windows_extensions",
+ )
+-load("//bazel:repositories.bzl", "NOBORINGSSL_SKIP_TARGETS", "PPC_SKIP_TARGETS")
++load("//bazel:repositories.bzl", "PPC_SKIP_TARGETS")
+ 
+ envoy_package()
+ 
+@@ -43,7 +43,6 @@ envoy_cc_library(
+     ] + select({
+         "//bazel:windows_x86_64": envoy_windows_extensions(),
+         "//bazel:linux_ppc": envoy_all_extensions(PPC_SKIP_TARGETS),
+-        "//bazel:boringssl_disabled": envoy_all_extensions(NOBORINGSSL_SKIP_TARGETS),
+         "//conditions:default": envoy_all_extensions(),
+     }),
+ )
+diff --git a/source/extensions/common/crypto/BUILD b/source/extensions/common/crypto/BUILD
+index c669b980ff..e85b9329b3 100644
+--- a/source/extensions/common/crypto/BUILD
++++ b/source/extensions/common/crypto/BUILD
+@@ -12,13 +12,15 @@ envoy_cc_library(
+     name = "utility_lib",
+     srcs = [
+         "crypto_impl.cc",
+-        "utility.cc",
++        "utility_impl.cc",
+     ],
+     hdrs = [
+         "crypto_impl.h",
++        "utility_impl.h",
+     ],
+     external_deps = [
+         "ssl",
++	"bssl_wrapper_lib",
+     ],
+     deps = [
+         "//include/envoy/buffer:buffer_interface",
+diff --git a/source/extensions/common/crypto/crypto_impl.h b/source/extensions/common/crypto/crypto_impl.h
+index 1d0e43c58d..ea409e60c5 100644
+--- a/source/extensions/common/crypto/crypto_impl.h
++++ b/source/extensions/common/crypto/crypto_impl.h
+@@ -2,7 +2,8 @@
+ 
+ #include "envoy/common/crypto/crypto.h"
+ 
+-#include "openssl/base.h"
++//#include "openssl/base.h"
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/evp.h"
+ 
+ namespace Envoy {
+diff --git a/source/extensions/common/crypto/utility.cc b/source/extensions/common/crypto/utility_impl.cc
+similarity index 72%
+rename from source/extensions/common/crypto/utility.cc
+rename to source/extensions/common/crypto/utility_impl.cc
+index d98c95f85b..3b2ab7d633 100644
+--- a/source/extensions/common/crypto/utility.cc
++++ b/source/extensions/common/crypto/utility_impl.cc
+@@ -1,4 +1,4 @@
+-#include "common/crypto/utility.h"
++#include "extensions/common/crypto/utility_impl.h"
+ 
+ #include "common/common/assert.h"
+ #include "common/common/stack_array.h"
+@@ -7,19 +7,12 @@
+ 
+ #include "absl/strings/ascii.h"
+ #include "absl/strings/str_cat.h"
+-#include "openssl/bytestring.h"
+-#include "openssl/hmac.h"
+-#include "openssl/sha.h"
+ 
+ namespace Envoy {
+ namespace Common {
+ namespace Crypto {
+ 
+-namespace Utility {
+-
+-const EVP_MD* getHashFunction(absl::string_view name);
+-
+-std::vector<uint8_t> getSha256Digest(const Buffer::Instance& buffer) {
++std::vector<uint8_t> UtilityImpl::getSha256Digest(const Buffer::Instance& buffer) {
+   std::vector<uint8_t> digest(SHA256_DIGEST_LENGTH);
+   EVP_MD_CTX* ctx(EVP_MD_CTX_new());
+   auto rc = EVP_DigestInit(ctx, EVP_sha256());
+@@ -37,7 +30,8 @@ std::vector<uint8_t> getSha256Digest(const Buffer::Instance& buffer) {
+   return digest;
+ }
+ 
+-std::vector<uint8_t> getSha256Hmac(const std::vector<uint8_t>& key, absl::string_view message) {
++std::vector<uint8_t> UtilityImpl::getSha256Hmac(const std::vector<uint8_t>& key,
++                                                absl::string_view message) {
+   std::vector<uint8_t> hmac(SHA256_DIGEST_LENGTH);
+   const auto ret =
+       HMAC(EVP_sha256(), key.data(), key.size(), reinterpret_cast<const uint8_t*>(message.data()),
+@@ -46,9 +40,9 @@ std::vector<uint8_t> getSha256Hmac(const std::vector<uint8_t>& key, absl::string
+   return hmac;
+ }
+ 
+-const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& key,
+-                                         const std::vector<uint8_t>& signature,
+-                                         const std::vector<uint8_t>& text) {
++const VerificationOutput UtilityImpl::verifySignature(absl::string_view hash, CryptoObject& key,
++                                                      const std::vector<uint8_t>& signature,
++                                                      const std::vector<uint8_t>& text) {
+   // Step 1: initialize EVP_MD_CTX
+   bssl::ScopedEVP_MD_CTX ctx;
+ 
+@@ -58,6 +52,7 @@ const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& k
+   if (md == nullptr) {
+     return {false, absl::StrCat(hash, " is not supported.")};
+   }
++
+   // Step 3: initialize EVP_DigestVerify
+   auto pkey_wrapper = Common::Crypto::Access::getTyped<Common::Crypto::PublicKeyObject>(key);
+   EVP_PKEY* pkey = pkey_wrapper->getEVP_PKEY();
+@@ -83,13 +78,12 @@ const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& k
+   return {false, absl::StrCat("Failed to verify digest. Error code: ", ok)};
+ }
+ 
+-CryptoObjectPtr importPublicKey(const std::vector<uint8_t>& key) {
+-  CBS cbs({key.data(), key.size()});
+-
+-  return std::make_unique<PublicKeyObject>(EVP_parse_public_key(&cbs));
++CryptoObjectPtr UtilityImpl::importPublicKey(const std::vector<uint8_t>& key) {
++  const unsigned char* tmp = key.data();
++  return std::make_unique<PublicKeyObject>(d2i_PUBKEY(nullptr, &tmp, key.size()));
+ }
+ 
+-const EVP_MD* getHashFunction(absl::string_view name) {
++const EVP_MD* UtilityImpl::getHashFunction(absl::string_view name) {
+   const std::string hash = absl::AsciiStrToLower(name);
+ 
+   // Hash algorithms set refers
+@@ -109,7 +103,10 @@ const EVP_MD* getHashFunction(absl::string_view name) {
+   }
+ }
+ 
+-} // namespace Utility
++// Register the crypto utility singleton.
++static Crypto::ScopedUtilitySingleton* utility_ =
++    new Crypto::ScopedUtilitySingleton(std::make_unique<Crypto::UtilityImpl>());
++
+ } // namespace Crypto
+ } // namespace Common
+ } // namespace Envoy
+diff --git a/source/extensions/common/crypto/utility_impl.h b/source/extensions/common/crypto/utility_impl.h
+new file mode 100644
+index 0000000000..152a4d328c
+--- /dev/null
++++ b/source/extensions/common/crypto/utility_impl.h
+@@ -0,0 +1,35 @@
++#pragma once
++
++#include "common/crypto/utility.h"
++
++//#include "openssl/bytestring.h"
++#include "openssl/hmac.h"
++#include "openssl/sha.h"
++
++namespace Envoy {
++namespace Common {
++namespace Crypto {
++
++class UtilityImpl : public Envoy::Common::Crypto::Utility {
++public:
++// a typedef used by BoringSSL
++  typedef struct cbs_st {
++    const uint8_t *data;
++    size_t len;
++  } CBS;
++
++  std::vector<uint8_t> getSha256Digest(const Buffer::Instance& buffer) override;
++  std::vector<uint8_t> getSha256Hmac(const std::vector<uint8_t>& key,
++                                     absl::string_view message) override;
++  const VerificationOutput verifySignature(absl::string_view hash, CryptoObject& key,
++                                           const std::vector<uint8_t>& signature,
++                                           const std::vector<uint8_t>& text) override;
++  CryptoObjectPtr importPublicKey(const std::vector<uint8_t>& key) override;
++private:
++//  EVP_PKEY* EVP_parse_public_key(CBS* cbs);
++  const EVP_MD* getHashFunction(absl::string_view name);
++};
++
++} // namespace Crypto
++} // namespace Common
++} // namespace Envoy
+diff --git a/source/extensions/common/wasm/wasm.cc b/source/extensions/common/wasm/wasm.cc
+index cb98612f8f..216c5ddaa1 100644
+--- a/source/extensions/common/wasm/wasm.cc
++++ b/source/extensions/common/wasm/wasm.cc
+@@ -38,7 +38,7 @@
+ #include "eval/eval/field_backed_list_impl.h"
+ #include "eval/eval/field_backed_map_impl.h"
+ #include "eval/public/cel_value.h"
+-#include "openssl/bytestring.h"
++//#include "openssl/bytestring.h"
+ #include "openssl/hmac.h"
+ #include "openssl/sha.h"
+ 
+diff --git a/source/extensions/extensions_build_config.bzl b/source/extensions/extensions_build_config.bzl
+index 777b5e736b..13eba0e85c 100644
+--- a/source/extensions/extensions_build_config.bzl
++++ b/source/extensions/extensions_build_config.bzl
+@@ -108,6 +108,12 @@ EXTENSIONS = {
+     "envoy.resource_monitors.fixed_heap":               "//source/extensions/resource_monitors/fixed_heap:config",
+     "envoy.resource_monitors.injected_resource":        "//source/extensions/resource_monitors/injected_resource:config",
+ 
++    #
++    # SSL
++    #
++
++    "envoy.extensions.common.crypto.utility_lib":       "//source/extensions/common/crypto:utility_lib",
++
+     #
+     # Stat sinks
+     #
+diff --git a/source/extensions/filters/http/common/aws/signer_impl.cc b/source/extensions/filters/http/common/aws/signer_impl.cc
+index 432396c85c..b081ea7bef 100644
+--- a/source/extensions/filters/http/common/aws/signer_impl.cc
++++ b/source/extensions/filters/http/common/aws/signer_impl.cc
+@@ -65,9 +65,10 @@ std::string SignerImpl::createContentHash(Http::Message& message, bool sign_body
+   if (!sign_body) {
+     return SignatureConstants::get().HashedEmptyString;
+   }
+-  const auto content_hash =
+-      message.body() ? Hex::encode(Envoy::Common::Crypto::Utility::getSha256Digest(*message.body()))
+-                     : SignatureConstants::get().HashedEmptyString;
++  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
++  const auto content_hash = message.body()
++                                ? Hex::encode(crypto_util.getSha256Digest(*message.body()))
++                                : SignatureConstants::get().HashedEmptyString;
+   message.headers().addCopy(SignatureHeaders::get().ContentSha256, content_hash);
+   return content_hash;
+ }
+@@ -80,23 +81,25 @@ std::string SignerImpl::createCredentialScope(absl::string_view short_date) cons
+ std::string SignerImpl::createStringToSign(absl::string_view canonical_request,
+                                            absl::string_view long_date,
+                                            absl::string_view credential_scope) const {
+-  return fmt::format(SignatureConstants::get().StringToSignFormat, long_date, credential_scope,
+-                     Hex::encode(Envoy::Common::Crypto::Utility::getSha256Digest(
+-                         Buffer::OwnedImpl(canonical_request))));
++  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
++  return fmt::format(
++      SignatureConstants::get().StringToSignFormat, long_date, credential_scope,
++      Hex::encode(crypto_util.getSha256Digest(Buffer::OwnedImpl(canonical_request))));
+ }
+ 
+ std::string SignerImpl::createSignature(absl::string_view secret_access_key,
+                                         absl::string_view short_date,
+                                         absl::string_view string_to_sign) const {
++  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
+   const auto secret_key =
+       absl::StrCat(SignatureConstants::get().SignatureVersion, secret_access_key);
+-  const auto date_key = Envoy::Common::Crypto::Utility::getSha256Hmac(
++  const auto date_key = crypto_util.getSha256Hmac(
+       std::vector<uint8_t>(secret_key.begin(), secret_key.end()), short_date);
+-  const auto region_key = Envoy::Common::Crypto::Utility::getSha256Hmac(date_key, region_);
+-  const auto service_key = Envoy::Common::Crypto::Utility::getSha256Hmac(region_key, service_name_);
+-  const auto signing_key = Envoy::Common::Crypto::Utility::getSha256Hmac(
+-      service_key, SignatureConstants::get().Aws4Request);
+-  return Hex::encode(Envoy::Common::Crypto::Utility::getSha256Hmac(signing_key, string_to_sign));
++  const auto region_key = crypto_util.getSha256Hmac(date_key, region_);
++  const auto service_key = crypto_util.getSha256Hmac(region_key, service_name_);
++  const auto signing_key =
++      crypto_util.getSha256Hmac(service_key, SignatureConstants::get().Aws4Request);
++  return Hex::encode(crypto_util.getSha256Hmac(signing_key, string_to_sign));
+ }
+ 
+ std::string
+@@ -113,4 +116,4 @@ SignerImpl::createAuthorizationHeader(absl::string_view access_key_id,
+ } // namespace Common
+ } // namespace HttpFilters
+ } // namespace Extensions
+-} // namespace Envoy
+\ No newline at end of file
++} // namespace Envoy
+diff --git a/source/extensions/filters/http/jwt_authn/BUILD b/source/extensions/filters/http/jwt_authn/BUILD
+index 7ce4b28bfa..5e1c8dca0d 100644
+--- a/source/extensions/filters/http/jwt_authn/BUILD
++++ b/source/extensions/filters/http/jwt_authn/BUILD
+@@ -8,6 +8,13 @@ load(
+ 
+ envoy_package()
+ 
++config_setting(
++    name = "openssl_build",
++    values = {
++        "OPENSSL_IS_BORINGSSL": "false",
++    },
++)
++
+ envoy_cc_library(
+     name = "extractor_lib",
+     srcs = ["extractor.cc"],
+diff --git a/source/extensions/filters/http/lua/BUILD b/source/extensions/filters/http/lua/BUILD
+index dacdd39b21..1b66be88cc 100644
+--- a/source/extensions/filters/http/lua/BUILD
++++ b/source/extensions/filters/http/lua/BUILD
+@@ -15,6 +15,9 @@ envoy_cc_library(
+     name = "lua_filter_lib",
+     srcs = ["lua_filter.cc"],
+     hdrs = ["lua_filter.h"],
++    external_deps = [
++      "openssl_cbs_lib",
++    ],
+     deps = [
+         ":wrappers_lib",
+         "//include/envoy/http:codes_interface",
+diff --git a/source/extensions/filters/http/lua/lua_filter.cc b/source/extensions/filters/http/lua/lua_filter.cc
+index 1e30231b94..bf9c3cfc4b 100644
+--- a/source/extensions/filters/http/lua/lua_filter.cc
++++ b/source/extensions/filters/http/lua/lua_filter.cc
+@@ -457,7 +457,8 @@ int StreamHandleWrapper::luaVerifySignature(lua_State* state) {
+   const std::vector<uint8_t> text_vec(clear_text, clear_text + text_len);
+   // Step 5: verify signature
+   auto crypto = reinterpret_cast<Common::Crypto::CryptoObject*>(ptr);
+-  auto output = Common::Crypto::Utility::verifySignature(hash, *crypto, sig_vec, text_vec);
++  auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
++  auto output = crypto_util.verifySignature(hash, *crypto, sig_vec, text_vec);
+   lua_pushboolean(state, output.result_);
+   if (output.result_) {
+     lua_pushnil(state);
+@@ -475,7 +476,8 @@ int StreamHandleWrapper::luaImportPublicKey(lua_State* state) {
+   if (public_key_wrapper_.get() != nullptr) {
+     public_key_wrapper_.pushStack();
+   } else {
+-    Common::Crypto::CryptoObjectPtr crypto_ptr = Common::Crypto::Utility::importPublicKey(key);
++    auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get();
++    Common::Crypto::CryptoObjectPtr crypto_ptr = crypto_util.importPublicKey(key);
+     public_key_wrapper_.reset(PublicKeyWrapper::create(state, std::move(crypto_ptr)), true);
+   }
+ 
+diff --git a/source/extensions/filters/http/lua/lua_filter.h b/source/extensions/filters/http/lua/lua_filter.h
+index c6676ff09c..2b99219124 100644
+--- a/source/extensions/filters/http/lua/lua_filter.h
++++ b/source/extensions/filters/http/lua/lua_filter.h
+@@ -5,7 +5,6 @@
+ 
+ #include "common/crypto/utility.h"
+ 
+-#include "extensions/common/crypto/crypto_impl.h"
+ #include "extensions/filters/common/lua/wrappers.h"
+ #include "extensions/filters/http/lua/wrappers.h"
+ #include "extensions/filters/http/well_known_names.h"
+diff --git a/source/extensions/filters/listener/tls_inspector/BUILD b/source/extensions/filters/listener/tls_inspector/BUILD
+index af90ed9fcd..f02069946a 100644
+--- a/source/extensions/filters/listener/tls_inspector/BUILD
++++ b/source/extensions/filters/listener/tls_inspector/BUILD
+@@ -15,7 +15,11 @@ envoy_cc_library(
+     name = "tls_inspector_lib",
+     srcs = ["tls_inspector.cc"],
+     hdrs = ["tls_inspector.h"],
+-    external_deps = ["ssl"],
++    external_deps = [
++        "ssl",
++        "bssl_wrapper_lib",
++        "openssl_includes_lib",
++    ],
+     deps = [
+         "//include/envoy/event:dispatcher_interface",
+         "//include/envoy/event:timer_interface",
+@@ -37,4 +41,4 @@ envoy_cc_library(
+         "//source/extensions/filters/listener:well_known_names",
+         "//source/extensions/filters/listener/tls_inspector:tls_inspector_lib",
+     ],
+-)
++)
+\ No newline at end of file
+diff --git a/source/extensions/filters/listener/tls_inspector/openssl_impl.cc b/source/extensions/filters/listener/tls_inspector/openssl_impl.cc
+new file mode 100644
+index 0000000000..3a76a0d7eb
+--- /dev/null
++++ b/source/extensions/filters/listener/tls_inspector/openssl_impl.cc
+@@ -0,0 +1,39 @@
++#include <arpa/inet.h>
++
++#include <algorithm>
++#include <cstdint>
++#include <memory>
++#include <string>
++#include <vector>
++
++#include "absl/strings/string_view.h"
++#include "openssl/hmac.h"
++#include "openssl/rand.h"
++#include "openssl/ssl.h"
++#include "openssl/x509v3.h"
++
++namespace Envoy {
++namespace Extensions {
++namespace ListenerFilters {
++namespace TlsInspector {
++
++std::vector<absl::string_view> getAlpnProtocols(const unsigned char* data, unsigned int len) {
++  std::vector<absl::string_view> protocols;
++  absl::string_view str(reinterpret_cast<const char*>(data));
++  for (int i = 0; i < len;) {
++    uint32_t protocol_length = 0;
++    protocol_length <<= 8;
++    protocol_length |= data[i];
++    ++i;
++    absl::string_view protocol(str.substr(i, protocol_length));
++    protocols.push_back(protocol);
++    i += protocol_length;
++  }
++
++  return protocols;
++}
++
++} // namespace TlsInspector
++} // namespace ListenerFilters
++} // namespace Extensions
++} // namespace Envoy
+diff --git a/source/extensions/filters/listener/tls_inspector/openssl_impl.h b/source/extensions/filters/listener/tls_inspector/openssl_impl.h
+new file mode 100644
+index 0000000000..5c397590f9
+--- /dev/null
++++ b/source/extensions/filters/listener/tls_inspector/openssl_impl.h
+@@ -0,0 +1,24 @@
++#pragma once
++
++#include <functional>
++#include <string>
++#include <vector>
++
++#include "openssl/ssl.h"
++
++/*
++ * MAISTRA
++ * Contains the functions where BoringSSL and OpenSSL diverge. In most cases this means that there are functions in BoringSSL that do not exist
++ * in OpenSSL
++ */
++namespace Envoy {
++namespace Extensions {
++namespace ListenerFilters {
++namespace TlsInspector {
++
++std::vector<absl::string_view> getAlpnProtocols(const unsigned char* data, unsigned int len);
++
++} // namespace TlsInspector
++} // namespace ListenerFilters
++} // namespace Extensions
++} // namespace Envoy
+diff --git a/source/extensions/filters/listener/tls_inspector/tls_inspector.cc b/source/extensions/filters/listener/tls_inspector/tls_inspector.cc
+index 62fd8aa801..a49ee920d2 100644
+--- a/source/extensions/filters/listener/tls_inspector/tls_inspector.cc
++++ b/source/extensions/filters/listener/tls_inspector/tls_inspector.cc
+@@ -17,6 +17,7 @@
+ #include "extensions/transport_sockets/well_known_names.h"
+ 
+ #include "openssl/ssl.h"
++#include "ssl/ssl_locl.h"
+ 
+ namespace Envoy {
+ namespace Extensions {
+@@ -29,7 +30,8 @@ const unsigned Config::TLS_MAX_SUPPORTED_VERSION = TLS1_3_VERSION;
+ 
+ Config::Config(Stats::Scope& scope, uint32_t max_client_hello_size)
+     : stats_{ALL_TLS_INSPECTOR_STATS(POOL_COUNTER_PREFIX(scope, "tls_inspector."))},
+-      ssl_ctx_(SSL_CTX_new(TLS_with_buffers_method())),
++      ssl_ctx_(
++          SSL_CTX_new(TLS_method())),
+       max_client_hello_size_(max_client_hello_size) {
+ 
+   if (max_client_hello_size_ > TLS_MAX_CLIENT_HELLO) {
+@@ -41,26 +43,25 @@ Config::Config(Stats::Scope& scope, uint32_t max_client_hello_size)
+   SSL_CTX_set_max_proto_version(ssl_ctx_.get(), TLS_MAX_SUPPORTED_VERSION);
+   SSL_CTX_set_options(ssl_ctx_.get(), SSL_OP_NO_TICKET);
+   SSL_CTX_set_session_cache_mode(ssl_ctx_.get(), SSL_SESS_CACHE_OFF);
+-  SSL_CTX_set_select_certificate_cb(
+-      ssl_ctx_.get(), [](const SSL_CLIENT_HELLO* client_hello) -> ssl_select_cert_result_t {
+-        const uint8_t* data;
+-        size_t len;
+-        if (SSL_early_callback_ctx_extension_get(
+-                client_hello, TLSEXT_TYPE_application_layer_protocol_negotiation, &data, &len)) {
+-          Filter* filter = static_cast<Filter*>(SSL_get_app_data(client_hello->ssl));
+-          filter->onALPN(data, len);
+-        }
+-        return ssl_select_cert_success;
+-      });
+-  SSL_CTX_set_tlsext_servername_callback(
+-      ssl_ctx_.get(), [](SSL* ssl, int* out_alert, void*) -> int {
+-        Filter* filter = static_cast<Filter*>(SSL_get_app_data(ssl));
+-        filter->onServername(SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name));
+-
+-        // Return an error to stop the handshake; we have what we wanted already.
+-        *out_alert = SSL_AD_USER_CANCELLED;
+-        return SSL_TLSEXT_ERR_ALERT_FATAL;
+-      });
++
++  auto tlsext_servername_cb = +[](SSL* ssl, int* out_alert, void* arg) -> int {
++    Filter* filter = static_cast<Filter*>(SSL_get_app_data(ssl));
++    absl::string_view servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
++    filter->onServername(servername);
++    *out_alert = SSL_AD_USER_CANCELLED;
++    return SSL_TLSEXT_ERR_OK;
++  };
++  SSL_CTX_set_tlsext_servername_callback(ssl_ctx_.get(), tlsext_servername_cb);
++
++  auto cert_cb = [](SSL* ssl, void* arg) -> int {
++    Filter* filter = static_cast<Filter*>(SSL_get_app_data(ssl));
++    // TODO (dmitri-d) move access to SSL internals into bssl_wrapper
++    filter->onALPN(ssl->s3->alpn_proposed, ssl->s3->alpn_proposed_len);
++
++    // Return an error to stop the handshake; we have what we wanted already.
++    return 0;
++  };
++  SSL_CTX_set_cert_cb(ssl_ctx_.get(), cert_cb, nullptr);
+ }
+ 
+ bssl::UniquePtr<SSL> Config::newSsl() { return bssl::UniquePtr<SSL>{SSL_new(ssl_ctx_.get())}; }
+@@ -78,6 +79,7 @@ Network::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {
+   ENVOY_LOG(debug, "tls inspector: new connection accepted");
+   Network::ConnectionSocket& socket = cb.socket();
+   ASSERT(file_event_ == nullptr);
++
+   cb_ = &cb;
+ 
+   ParseState parse_state = onRead();
+@@ -122,21 +124,10 @@ Network::FilterStatus Filter::onAccept(Network::ListenerFilterCallbacks& cb) {
+ }
+ 
+ void Filter::onALPN(const unsigned char* data, unsigned int len) {
+-  CBS wire, list;
+-  CBS_init(&wire, reinterpret_cast<const uint8_t*>(data), static_cast<size_t>(len));
+-  if (!CBS_get_u16_length_prefixed(&wire, &list) || CBS_len(&wire) != 0 || CBS_len(&list) < 2) {
+-    // Don't produce errors, let the real TLS stack do it.
++  std::vector<absl::string_view> protocols = getAlpnProtocols(data, len);
++  if (protocols.empty()) {
+     return;
+   }
+-  CBS name;
+-  std::vector<absl::string_view> protocols;
+-  while (CBS_len(&list) > 0) {
+-    if (!CBS_get_u8_length_prefixed(&list, &name) || CBS_len(&name) == 0) {
+-      // Don't produce errors, let the real TLS stack do it.
+-      return;
+-    }
+-    protocols.emplace_back(reinterpret_cast<const char*>(CBS_data(&name)), CBS_len(&name));
+-  }
+   cb_->socket().setRequestedApplicationProtocols(protocols);
+   alpn_found_ = true;
+ }
+@@ -153,6 +144,7 @@ void Filter::onServername(absl::string_view name) {
+ }
+ 
+ ParseState Filter::onRead() {
++	
+   // This receive code is somewhat complicated, because it must be done as a MSG_PEEK because
+   // there is no way for a listener-filter to pass payload data to the ConnectionImpl and filters
+   // that get created later.
+@@ -231,12 +223,28 @@ ParseState Filter::parseClientHello(const void* data, size_t len) {
+     } else {
+       config_->stats().tls_not_found_.inc();
+     }
+-    return ParseState::Done;
++      return ParseState::Done;
+   default:
+     return ParseState::Error;
+   }
+ }
+ 
++std::vector<absl::string_view> Filter::getAlpnProtocols(const unsigned char* data, unsigned int len) {
++  std::vector<absl::string_view> protocols;
++  absl::string_view str(reinterpret_cast<const char*>(data));
++  for (int i = 0; i < len;) {
++    uint32_t protocol_length = 0;
++    protocol_length <<= 8;
++    protocol_length |= data[i];
++    ++i;
++    absl::string_view protocol(str.substr(i, protocol_length));
++    protocols.push_back(protocol);
++    i += protocol_length;
++  }
++
++  return protocols;
++}
++
+ } // namespace TlsInspector
+ } // namespace ListenerFilters
+ } // namespace Extensions
+diff --git a/source/extensions/filters/listener/tls_inspector/tls_inspector.h b/source/extensions/filters/listener/tls_inspector/tls_inspector.h
+index be232ce792..63ea54d11c 100644
+--- a/source/extensions/filters/listener/tls_inspector/tls_inspector.h
++++ b/source/extensions/filters/listener/tls_inspector/tls_inspector.h
+@@ -8,6 +8,7 @@
+ 
+ #include "common/common/logger.h"
+ 
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/ssl.h"
+ 
+ namespace Envoy {
+@@ -22,6 +23,7 @@ namespace TlsInspector {
+   COUNTER(connection_closed)                                                                       \
+   COUNTER(client_hello_too_large)                                                                  \
+   COUNTER(read_error)                                                                              \
++  COUNTER(read_timeout)                                                                            \
+   COUNTER(tls_found)                                                                               \
+   COUNTER(tls_not_found)                                                                           \
+   COUNTER(alpn_found)                                                                              \
+@@ -44,6 +46,7 @@ enum class ParseState {
+   // Parser reports unrecoverable error.
+   Error
+ };
++
+ /**
+  * Global configuration for TLS inspector.
+  */
+@@ -76,17 +79,21 @@ public:
+ 
+   // Network::ListenerFilter
+   Network::FilterStatus onAccept(Network::ListenerFilterCallbacks& cb) override;
++  void onALPN(const unsigned char* data, unsigned int len);
++  void onCert();
+ 
+ private:
++  std::vector<absl::string_view> getAlpnProtocols(const unsigned char* data, unsigned int len);
+   ParseState parseClientHello(const void* data, size_t len);
+   ParseState onRead();
++  void onTimeout();
+   void done(bool success);
+-  void onALPN(const unsigned char* data, unsigned int len);
+   void onServername(absl::string_view name);
+ 
+   ConfigSharedPtr config_;
+   Network::ListenerFilterCallbacks* cb_;
+   Event::FileEventPtr file_event_;
++  Event::TimerPtr timer_;
+ 
+   bssl::UniquePtr<SSL> ssl_;
+   uint64_t read_{0};
+diff --git a/source/extensions/quic_listeners/quiche/BUILD b/source/extensions/quic_listeners/quiche/BUILD
+deleted file mode 100644
+index 63f9046607..0000000000
+--- a/source/extensions/quic_listeners/quiche/BUILD
++++ /dev/null
+@@ -1,269 +0,0 @@
+-licenses(["notice"])  # Apache 2
+-
+-load(
+-    "//bazel:envoy_build_system.bzl",
+-    "envoy_cc_library",
+-    "envoy_package",
+-)
+-
+-envoy_package()
+-
+-envoy_cc_library(
+-    name = "envoy_quic_alarm_lib",
+-    srcs = ["envoy_quic_alarm.cc"],
+-    hdrs = ["envoy_quic_alarm.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/event:dispatcher_interface",
+-        "//include/envoy/event:timer_interface",
+-        "@com_googlesource_quiche//:quic_core_alarm_interface_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_alarm_factory_lib",
+-    srcs = ["envoy_quic_alarm_factory.cc"],
+-    hdrs = ["envoy_quic_alarm_factory.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_alarm_lib",
+-        "@com_googlesource_quiche//:quic_core_alarm_factory_interface_lib",
+-        "@com_googlesource_quiche//:quic_core_arena_scoped_ptr_lib",
+-        "@com_googlesource_quiche//:quic_core_one_block_arena_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_connection_helper_lib",
+-    hdrs = ["envoy_quic_connection_helper.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche/platform:envoy_quic_clock_lib",
+-        "@com_googlesource_quiche//:quic_core_buffer_allocator_lib",
+-        "@com_googlesource_quiche//:quic_core_connection_lib",
+-        "@com_googlesource_quiche//:quic_core_crypto_random_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_packet_writer_lib",
+-    srcs = ["envoy_quic_packet_writer.cc"],
+-    hdrs = ["envoy_quic_packet_writer.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_utils_lib",
+-        "@com_googlesource_quiche//:quic_core_packet_writer_interface_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_proof_source_lib",
+-    hdrs = ["envoy_quic_fake_proof_source.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "@com_googlesource_quiche//:quic_core_crypto_proof_source_interface_lib",
+-        "@com_googlesource_quiche//:quic_core_versions_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_proof_verifier_lib",
+-    hdrs = ["envoy_quic_fake_proof_verifier.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "@com_googlesource_quiche//:quic_core_crypto_crypto_handshake_lib",
+-        "@com_googlesource_quiche//:quic_core_versions_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "spdy_server_push_utils_for_envoy_lib",
+-    srcs = ["spdy_server_push_utils_for_envoy.cc"],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "//source/common/common:assert_lib",
+-        "@com_googlesource_quiche//:quic_core_http_spdy_server_push_utils_header",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_stream_lib",
+-    hdrs = ["envoy_quic_stream.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/http:codec_interface",
+-        "//source/common/http:codec_helper_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_server_stream_lib",
+-    srcs = ["envoy_quic_server_stream.cc"],
+-    hdrs = ["envoy_quic_server_stream.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_stream_lib",
+-        ":envoy_quic_utils_lib",
+-        "//source/common/buffer:buffer_lib",
+-        "//source/common/common:assert_lib",
+-        "//source/common/http:header_map_lib",
+-        "@com_googlesource_quiche//:quic_core_http_spdy_session_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "codec_lib",
+-    srcs = ["codec_impl.cc"],
+-    hdrs = ["codec_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_server_session_lib",
+-        "//include/envoy/http:codec_interface",
+-        "@com_googlesource_quiche//:quic_core_http_spdy_session_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_filter_manager_connection_lib",
+-    srcs = ["quic_filter_manager_connection_impl.cc"],
+-    hdrs = ["quic_filter_manager_connection_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_connection_lib",
+-        "//include/envoy/event:dispatcher_interface",
+-        "//include/envoy/network:connection_interface",
+-        "//source/common/common:empty_string",
+-        "//source/common/network:filter_manager_lib",
+-        "//source/common/stream_info:stream_info_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_server_session_lib",
+-    srcs = ["envoy_quic_server_session.cc"],
+-    hdrs = ["envoy_quic_server_session.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_server_stream_lib",
+-        ":quic_filter_manager_connection_lib",
+-        "@com_googlesource_quiche//:quic_core_http_spdy_session_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_io_handle_wrapper_lib",
+-    hdrs = ["quic_io_handle_wrapper.h"],
+-    deps = [
+-        "//include/envoy/network:io_handle_interface",
+-        "//source/common/network:io_socket_error_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_connection_lib",
+-    srcs = ["envoy_quic_connection.cc"],
+-    hdrs = ["envoy_quic_connection.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_io_handle_wrapper_lib",
+-        "//include/envoy/network:connection_interface",
+-        "//source/common/network:listen_socket_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_utils_lib",
+-        "//source/extensions/transport_sockets:well_known_names",
+-        "@com_googlesource_quiche//:quic_core_connection_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_server_connection_lib",
+-    srcs = ["envoy_quic_server_connection.cc"],
+-    hdrs = ["envoy_quic_server_connection.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_connection_lib",
+-        "//source/server:connection_handler_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_dispatcher_lib",
+-    srcs = ["envoy_quic_dispatcher.cc"],
+-    hdrs = ["envoy_quic_dispatcher.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_proof_source_lib",
+-        ":envoy_quic_server_connection_lib",
+-        ":envoy_quic_server_session_lib",
+-        "//include/envoy/network:listener_interface",
+-        "//source/server:connection_handler_lib",
+-        "@com_googlesource_quiche//:quic_core_server_lib",
+-        "@com_googlesource_quiche//:quic_core_utils_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "active_quic_listener_lib",
+-    srcs = ["active_quic_listener.cc"],
+-    hdrs = ["active_quic_listener.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":envoy_quic_alarm_factory_lib",
+-        ":envoy_quic_connection_helper_lib",
+-        ":envoy_quic_dispatcher_lib",
+-        ":envoy_quic_packet_writer_lib",
+-        ":envoy_quic_proof_source_lib",
+-        ":envoy_quic_utils_lib",
+-        "//include/envoy/network:listener_interface",
+-        "//source/common/network:listener_lib",
+-        "//source/common/protobuf:utility_lib",
+-        "//source/server:connection_handler_lib",
+-        "@envoy_api//envoy/api/v2/listener:pkg_cc_proto",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "active_quic_listener_config_lib",
+-    srcs = ["active_quic_listener_config.cc"],
+-    hdrs = ["active_quic_listener_config.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":active_quic_listener_lib",
+-        "//include/envoy/registry",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_utils_lib",
+-    srcs = ["envoy_quic_utils.cc"],
+-    hdrs = ["envoy_quic_utils.h"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/http:codec_interface",
+-        "//source/common/http:header_map_lib",
+-        "//source/common/network:address_lib",
+-        "@com_googlesource_quiche//:quic_core_http_header_list_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_transport_socket_factory_lib",
+-    srcs = ["quic_transport_socket_factory.cc"],
+-    hdrs = ["quic_transport_socket_factory.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/network:transport_socket_interface",
+-        "//include/envoy/server:transport_socket_config_interface",
+-        "//include/envoy/ssl:context_config_interface",
+-        "//source/common/common:assert_lib",
+-        "//source/extensions/transport_sockets:well_known_names",
+-        "//source/extensions/transport_sockets/tls:context_config_lib",
+-        "@envoy_api//envoy/api/v2/auth:pkg_cc_proto",
+-    ],
+-)
+diff --git a/source/extensions/quic_listeners/quiche/active_quic_listener.cc b/source/extensions/quic_listeners/quiche/active_quic_listener.cc
+deleted file mode 100644
+index 57be66ad6e..0000000000
+--- a/source/extensions/quic_listeners/quiche/active_quic_listener.cc
++++ /dev/null
+@@ -1,86 +0,0 @@
+-#include "extensions/quic_listeners/quiche/active_quic_listener.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection_helper.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_dispatcher.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_packet_writer.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-ActiveQuicListener::ActiveQuicListener(Event::Dispatcher& dispatcher,
+-                                       Network::ConnectionHandler& parent,
+-                                       Network::ListenerConfig& listener_config,
+-                                       const quic::QuicConfig& quic_config)
+-    : ActiveQuicListener(dispatcher, parent,
+-                         dispatcher.createUdpListener(listener_config.socket(), *this),
+-                         listener_config, quic_config) {}
+-
+-ActiveQuicListener::ActiveQuicListener(Event::Dispatcher& dispatcher,
+-                                       Network::ConnectionHandler& parent,
+-                                       Network::UdpListenerPtr&& listener,
+-                                       Network::ListenerConfig& listener_config,
+-                                       const quic::QuicConfig& quic_config)
+-    : ActiveQuicListener(dispatcher, parent,
+-                         std::make_unique<EnvoyQuicPacketWriter>(listener_config.socket()),
+-                         std::move(listener), listener_config, quic_config) {}
+-
+-ActiveQuicListener::ActiveQuicListener(Event::Dispatcher& dispatcher,
+-                                       Network::ConnectionHandler& parent,
+-                                       std::unique_ptr<quic::QuicPacketWriter> writer,
+-                                       Network::UdpListenerPtr&& listener,
+-                                       Network::ListenerConfig& listener_config,
+-                                       const quic::QuicConfig& quic_config)
+-    : Server::ConnectionHandlerImpl::ActiveListenerImplBase(parent, listener_config),
+-      udp_listener_(std::move(listener)), dispatcher_(dispatcher),
+-      version_manager_(quic::CurrentSupportedVersions()) {
+-  quic::QuicRandom* const random = quic::QuicRandom::GetInstance();
+-  random->RandBytes(random_seed_, sizeof(random_seed_));
+-  crypto_config_ = std::make_unique<quic::QuicCryptoServerConfig>(
+-      quic::QuicStringPiece(reinterpret_cast<char*>(random_seed_), sizeof(random_seed_)),
+-      quic::QuicRandom::GetInstance(), std::make_unique<EnvoyQuicFakeProofSource>(),
+-      quic::KeyExchangeSource::Default());
+-  auto connection_helper = std::make_unique<EnvoyQuicConnectionHelper>(dispatcher_);
+-  auto alarm_factory =
+-      std::make_unique<EnvoyQuicAlarmFactory>(dispatcher_, *connection_helper->GetClock());
+-  quic_dispatcher_ = std::make_unique<EnvoyQuicDispatcher>(
+-      crypto_config_.get(), quic_config, &version_manager_, std::move(connection_helper),
+-      std::move(alarm_factory), quic::kQuicDefaultConnectionIdLength, parent, config_, stats_,
+-      dispatcher);
+-  quic_dispatcher_->InitializeWithWriter(writer.release());
+-}
+-
+-void ActiveQuicListener::onListenerShutdown() {
+-  ENVOY_LOG(info, "Quic listener {} shutdown.", config_.name());
+-  quic_dispatcher_->Shutdown();
+-}
+-
+-void ActiveQuicListener::onData(Network::UdpRecvData& data) {
+-  quic::QuicSocketAddress peer_address(envoyAddressInstanceToQuicSocketAddress(data.peer_address_));
+-  quic::QuicSocketAddress self_address(
+-      envoyAddressInstanceToQuicSocketAddress(data.local_address_));
+-  quic::QuicTime timestamp =
+-      quic::QuicTime::Zero() +
+-      quic::QuicTime::Delta::FromMilliseconds(std::chrono::duration_cast<std::chrono::milliseconds>(
+-                                                  data.receive_time_.time_since_epoch())
+-                                                  .count());
+-  uint64_t num_slice = data.buffer_->getRawSlices(nullptr, 0);
+-  ASSERT(num_slice == 1);
+-  Buffer::RawSlice slice;
+-  data.buffer_->getRawSlices(&slice, 1);
+-  // TODO(danzh): pass in TTL and UDP header.
+-  quic::QuicReceivedPacket packet(reinterpret_cast<char*>(slice.mem_), slice.len_, timestamp,
+-                                  /*owns_buffer=*/false, /*ttl=*/0, /*ttl_valid=*/true,
+-                                  /*packet_headers=*/nullptr, /*headers_length=*/0,
+-                                  /*owns_header_buffer*/ false);
+-  quic_dispatcher_->ProcessPacket(self_address, peer_address, packet);
+-}
+-
+-void ActiveQuicListener::onWriteReady(const Network::Socket& /*socket*/) {
+-  quic_dispatcher_->OnCanWrite();
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/active_quic_listener.h b/source/extensions/quic_listeners/quiche/active_quic_listener.h
+deleted file mode 100644
+index 28edc1d112..0000000000
+--- a/source/extensions/quic_listeners/quiche/active_quic_listener.h
++++ /dev/null
+@@ -1,98 +0,0 @@
+-#pragma once
+-
+-#include "envoy/api/v2/listener/quic_config.pb.h"
+-#include "envoy/network/connection_handler.h"
+-#include "envoy/network/listener.h"
+-
+-#include "common/protobuf/utility.h"
+-
+-#include "server/connection_handler_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_dispatcher.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// QUIC specific UdpListenerCallbacks implementation which delegates incoming
+-// packets, write signals and listener errors to QuicDispatcher.
+-class ActiveQuicListener : public Network::UdpListenerCallbacks,
+-                           public Server::ConnectionHandlerImpl::ActiveListenerImplBase,
+-                           Logger::Loggable<Logger::Id::quic> {
+-public:
+-  ActiveQuicListener(Event::Dispatcher& dispatcher, Network::ConnectionHandler& parent,
+-                     Network::ListenerConfig& listener_config, const quic::QuicConfig& quic_config);
+-
+-  ActiveQuicListener(Event::Dispatcher& dispatcher, Network::ConnectionHandler& parent,
+-                     Network::UdpListenerPtr&& listener, Network::ListenerConfig& listener_config,
+-                     const quic::QuicConfig& quic_config);
+-
+-  // TODO(#7465): Make this a callback.
+-  void onListenerShutdown();
+-
+-  // Network::UdpListenerCallbacks
+-  void onData(Network::UdpRecvData& data) override;
+-  void onWriteReady(const Network::Socket& socket) override;
+-  void onReceiveError(const Network::UdpListenerCallbacks::ErrorCode& /*error_code*/,
+-                      Api::IoError::IoErrorCode /*err*/) override {
+-    // No-op. Quic can't do anything upon listener error.
+-  }
+-
+-  // ActiveListenerImplBase
+-  Network::Listener* listener() override { return udp_listener_.get(); }
+-  void destroy() override { udp_listener_.reset(); }
+-
+-private:
+-  friend class ActiveQuicListenerPeer;
+-
+-  ActiveQuicListener(Event::Dispatcher& dispatcher, Network::ConnectionHandler& parent,
+-                     std::unique_ptr<quic::QuicPacketWriter> writer,
+-                     Network::UdpListenerPtr&& listener, Network::ListenerConfig& listener_config,
+-                     const quic::QuicConfig& quic_config);
+-
+-  Network::UdpListenerPtr udp_listener_;
+-  uint8_t random_seed_[16];
+-  std::unique_ptr<quic::QuicCryptoServerConfig> crypto_config_;
+-  Event::Dispatcher& dispatcher_;
+-  quic::QuicVersionManager version_manager_;
+-  std::unique_ptr<EnvoyQuicDispatcher> quic_dispatcher_;
+-};
+-
+-using ActiveQuicListenerPtr = std::unique_ptr<ActiveQuicListener>;
+-
+-// A factory to create ActiveQuicListener based on given config.
+-class ActiveQuicListenerFactory : public Network::ActiveUdpListenerFactory {
+-public:
+-  ActiveQuicListenerFactory(const envoy::api::v2::listener::QuicProtocolOptions& config) {
+-    uint64_t idle_network_timeout_ms =
+-        config.has_idle_timeout() ? DurationUtil::durationToMilliseconds(config.idle_timeout())
+-                                  : 300000;
+-    quic_config_.SetIdleNetworkTimeout(
+-        quic::QuicTime::Delta::FromMilliseconds(idle_network_timeout_ms),
+-        quic::QuicTime::Delta::FromMilliseconds(idle_network_timeout_ms));
+-    int32_t max_time_before_crypto_handshake_ms =
+-        config.has_crypto_handshake_timeout()
+-            ? DurationUtil::durationToMilliseconds(config.crypto_handshake_timeout())
+-            : 20000;
+-    quic_config_.set_max_time_before_crypto_handshake(
+-        quic::QuicTime::Delta::FromMilliseconds(max_time_before_crypto_handshake_ms));
+-    int32_t max_streams = PROTOBUF_GET_WRAPPED_OR_DEFAULT(config, max_concurrent_streams, 100);
+-    quic_config_.SetMaxIncomingBidirectionalStreamsToSend(max_streams);
+-    quic_config_.SetMaxIncomingUnidirectionalStreamsToSend(max_streams);
+-  }
+-
+-  // Network::ActiveUdpListenerFactory.
+-  Network::ConnectionHandler::ActiveListenerPtr
+-  createActiveUdpListener(Network::ConnectionHandler& parent, Event::Dispatcher& disptacher,
+-                          Network::ListenerConfig& config) const override {
+-    return std::make_unique<ActiveQuicListener>(disptacher, parent, config, quic_config_);
+-  }
+-  bool isTransportConnectionless() const override { return false; }
+-
+-private:
+-  friend class ActiveQuicListenerFactoryPeer;
+-
+-  quic::QuicConfig quic_config_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/active_quic_listener_config.cc b/source/extensions/quic_listeners/quiche/active_quic_listener_config.cc
+deleted file mode 100644
+index 3cdadd8e0a..0000000000
+--- a/source/extensions/quic_listeners/quiche/active_quic_listener_config.cc
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#include "extensions/quic_listeners/quiche/active_quic_listener_config.h"
+-
+-#include "envoy/api/v2/listener/quic_config.pb.h"
+-
+-#include "extensions/quic_listeners/quiche/active_quic_listener.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-ProtobufTypes::MessagePtr ActiveQuicListenerConfigFactory::createEmptyConfigProto() {
+-  return std::make_unique<envoy::api::v2::listener::QuicProtocolOptions>();
+-}
+-
+-Network::ActiveUdpListenerFactoryPtr
+-ActiveQuicListenerConfigFactory::createActiveUdpListenerFactory(const Protobuf::Message& message) {
+-  auto& config = dynamic_cast<const envoy::api::v2::listener::QuicProtocolOptions&>(message);
+-  return std::make_unique<ActiveQuicListenerFactory>(config);
+-}
+-
+-std::string ActiveQuicListenerConfigFactory::name() { return QuicListenerName; }
+-
+-REGISTER_FACTORY(ActiveQuicListenerConfigFactory, Server::ActiveUdpListenerConfigFactory);
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/active_quic_listener_config.h b/source/extensions/quic_listeners/quiche/active_quic_listener_config.h
+deleted file mode 100644
+index 78d6e7bb88..0000000000
+--- a/source/extensions/quic_listeners/quiche/active_quic_listener_config.h
++++ /dev/null
+@@ -1,27 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-#include "envoy/registry/registry.h"
+-#include "envoy/server/active_udp_listener_config.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-const std::string QuicListenerName{"quiche_quic_listener"};
+-
+-// A factory to create ActiveQuicListenerFactory based on given protobuf.
+-class ActiveQuicListenerConfigFactory : public Server::ActiveUdpListenerConfigFactory {
+-public:
+-  ProtobufTypes::MessagePtr createEmptyConfigProto() override;
+-
+-  Network::ActiveUdpListenerFactoryPtr
+-  createActiveUdpListenerFactory(const Protobuf::Message&) override;
+-
+-  std::string name() override;
+-};
+-
+-DECLARE_FACTORY(ActiveQuicListenerConfigFactory);
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/codec_impl.cc b/source/extensions/quic_listeners/quiche/codec_impl.cc
+deleted file mode 100644
+index fdb060cb7c..0000000000
+--- a/source/extensions/quic_listeners/quiche/codec_impl.cc
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#include "extensions/quic_listeners/quiche/codec_impl.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-bool QuicHttpConnectionImplBase::wantsToWrite() { return quic_session_.HasDataToWrite(); }
+-
+-// TODO(danzh): modify QUIC stack to react based on aggregated bytes across all
+-// the streams. And call StreamCallbackHelper::runHighWatermarkCallbacks() for each stream.
+-void QuicHttpConnectionImplBase::onUnderlyingConnectionAboveWriteBufferHighWatermark() {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-void QuicHttpConnectionImplBase::onUnderlyingConnectionBelowWriteBufferLowWatermark() {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-void QuicHttpServerConnectionImpl::goAway() {
+-  quic_server_session_.SendGoAway(quic::QUIC_PEER_GOING_AWAY, "server shutdown imminent");
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/codec_impl.h b/source/extensions/quic_listeners/quiche/codec_impl.h
+deleted file mode 100644
+index debff738cb..0000000000
+--- a/source/extensions/quic_listeners/quiche/codec_impl.h
++++ /dev/null
+@@ -1,61 +0,0 @@
+-#include "envoy/http/codec.h"
+-
+-#include "common/common/assert.h"
+-#include "common/common/logger.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_session.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// QuicHttpConnectionImplBase instance is a thin QUIC codec just providing quic interface to HCM.
+-// Owned by HCM and created during onNewConnection() if the network connection
+-// is a QUIC connection.
+-class QuicHttpConnectionImplBase : public virtual Http::Connection,
+-                                   protected Logger::Loggable<Logger::Id::quic> {
+-public:
+-  QuicHttpConnectionImplBase(quic::QuicSpdySession& quic_session) : quic_session_(quic_session) {}
+-
+-  // Http::Connection
+-  void dispatch(Buffer::Instance& /*data*/) override {
+-    // Bypassed. QUIC connection already hands all data to streams.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  Http::Protocol protocol() override {
+-    // From HCM's view, QUIC should behave the same as Http2, only the stats
+-    // should be different.
+-    // TODO(danzh) add Http3 enum value for QUIC.
+-    return Http::Protocol::Http2;
+-  }
+-  // Returns true if the session has data to send but queued in connection or
+-  // stream send buffer.
+-  bool wantsToWrite() override;
+-  void onUnderlyingConnectionAboveWriteBufferHighWatermark() override;
+-  void onUnderlyingConnectionBelowWriteBufferLowWatermark() override;
+-
+-protected:
+-  quic::QuicSpdySession& quic_session_;
+-};
+-
+-class QuicHttpServerConnectionImpl : public QuicHttpConnectionImplBase,
+-                                     public Http::ServerConnection {
+-public:
+-  QuicHttpServerConnectionImpl(EnvoyQuicServerSession& quic_session,
+-                               Http::ServerConnectionCallbacks& callbacks)
+-      : QuicHttpConnectionImplBase(quic_session), quic_server_session_(quic_session) {
+-    quic_session.setHttpConnectionCallbacks(callbacks);
+-  }
+-
+-  // Http::Connection
+-  void goAway() override;
+-  void shutdownNotice() override {
+-    // TODO(danzh): Add double-GOAWAY support in QUIC.
+-    ENVOY_CONN_LOG(error, "Shutdown notice is not propagated to QUIC.", quic_server_session_);
+-  }
+-
+-private:
+-  EnvoyQuicServerSession& quic_server_session_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_alarm.cc b/source/extensions/quic_listeners/quiche/envoy_quic_alarm.cc
+deleted file mode 100644
+index b490aff8b9..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_alarm.cc
++++ /dev/null
+@@ -1,35 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-EnvoyQuicAlarm::EnvoyQuicAlarm(Event::Dispatcher& dispatcher, const quic::QuicClock& clock,
+-                               quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate> delegate)
+-    : QuicAlarm(std::move(delegate)), dispatcher_(dispatcher),
+-      timer_(dispatcher_.createTimer([this]() { Fire(); })), clock_(clock) {}
+-
+-void EnvoyQuicAlarm::CancelImpl() { timer_->disableTimer(); }
+-
+-void EnvoyQuicAlarm::SetImpl() {
+-  // TODO(#7170) switch to use microseconds if it is supported.
+-  timer_->enableTimer(std::chrono::milliseconds(getDurationBeforeDeadline().ToMilliseconds()));
+-}
+-
+-void EnvoyQuicAlarm::UpdateImpl() {
+-  // Since Timer::enableTimer() overrides its deadline from previous calls,
+-  // there is no need to disable the timer before enabling it again.
+-  SetImpl();
+-}
+-
+-quic::QuicTime::Delta EnvoyQuicAlarm::getDurationBeforeDeadline() {
+-  quic::QuicTime::Delta duration(quic::QuicTime::Delta::Zero());
+-  quic::QuicTime now = clock_.ApproximateNow();
+-  quic::QuicTime tmp = deadline();
+-  if (tmp > now) {
+-    duration = tmp - now;
+-  }
+-  return duration;
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_alarm.h b/source/extensions/quic_listeners/quiche/envoy_quic_alarm.h
+deleted file mode 100644
+index 4152f4c101..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_alarm.h
++++ /dev/null
+@@ -1,40 +0,0 @@
+-#pragma once
+-
+-#include "envoy/event/dispatcher.h"
+-#include "envoy/event/timer.h"
+-
+-#include "common/common/assert.h"
+-
+-#include "quiche/quic/core/quic_alarm.h"
+-#include "quiche/quic/core/quic_time.h"
+-#include "quiche/quic/platform/api/quic_clock.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Implements QUIC interface
+-// https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/core/quic_alarm.h This class
+-// wraps an Event::Timer object and provide interface for QUIC to interact with the timer.
+-class EnvoyQuicAlarm : public quic::QuicAlarm {
+-public:
+-  EnvoyQuicAlarm(Event::Dispatcher& dispatcher, const quic::QuicClock& clock,
+-                 quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate> delegate);
+-
+-  ~EnvoyQuicAlarm() override { ASSERT(!IsSet()); };
+-
+-  // quic::QuicAlarm
+-  void CancelImpl() override;
+-  void SetImpl() override;
+-  // Overridden to avoid cancel before set.
+-  void UpdateImpl() override;
+-
+-private:
+-  quic::QuicTime::Delta getDurationBeforeDeadline();
+-
+-  Event::Dispatcher& dispatcher_;
+-  Event::TimerPtr timer_;
+-  const quic::QuicClock& clock_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.cc b/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.cc
+deleted file mode 100644
+index cdea1ed16f..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.cc
++++ /dev/null
+@@ -1,22 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-quic::QuicAlarm* EnvoyQuicAlarmFactory::CreateAlarm(quic::QuicAlarm::Delegate* delegate) {
+-  return new EnvoyQuicAlarm(dispatcher_, clock_,
+-                            quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate>(delegate));
+-}
+-
+-quic::QuicArenaScopedPtr<quic::QuicAlarm>
+-EnvoyQuicAlarmFactory::CreateAlarm(quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate> delegate,
+-                                   quic::QuicConnectionArena* arena) {
+-  if (arena != nullptr) {
+-    return arena->New<EnvoyQuicAlarm>(dispatcher_, clock_, std::move(delegate));
+-  }
+-  return quic::QuicArenaScopedPtr<quic::QuicAlarm>(
+-      new EnvoyQuicAlarm(dispatcher_, clock_, std::move(delegate)));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h b/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h
+deleted file mode 100644
+index c373ed4229..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h
++++ /dev/null
+@@ -1,39 +0,0 @@
+-#pragma once
+-
+-#include "common/common/non_copyable.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm.h"
+-
+-#pragma GCC diagnostic push
+-
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-#include "quiche/quic/core/quic_alarm_factory.h"
+-#include "quiche/quic/core/quic_arena_scoped_ptr.h"
+-#include "quiche/quic/core/quic_one_block_arena.h"
+-
+-#pragma GCC diagnostic pop
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicAlarmFactory : public quic::QuicAlarmFactory, NonCopyable {
+-public:
+-  EnvoyQuicAlarmFactory(Event::Dispatcher& dispatcher, const quic::QuicClock& clock)
+-      : dispatcher_(dispatcher), clock_(clock) {}
+-
+-  ~EnvoyQuicAlarmFactory() override = default;
+-
+-  // QuicAlarmFactory
+-  quic::QuicAlarm* CreateAlarm(quic::QuicAlarm::Delegate* delegate) override;
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm>
+-  CreateAlarm(quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate> delegate,
+-              quic::QuicConnectionArena* arena) override;
+-
+-private:
+-  Event::Dispatcher& dispatcher_;
+-  const quic::QuicClock& clock_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_connection.cc b/source/extensions/quic_listeners/quiche/envoy_quic_connection.cc
+deleted file mode 100644
+index dcc311a6ea..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_connection.cc
++++ /dev/null
+@@ -1,25 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-EnvoyQuicConnection::EnvoyQuicConnection(const quic::QuicConnectionId& server_connection_id,
+-                                         quic::QuicSocketAddress initial_peer_address,
+-                                         quic::QuicConnectionHelperInterface& helper,
+-                                         quic::QuicAlarmFactory& alarm_factory,
+-                                         quic::QuicPacketWriter* writer, bool owns_writer,
+-                                         quic::Perspective perspective,
+-                                         const quic::ParsedQuicVersionVector& supported_versions,
+-                                         Network::ConnectionSocketPtr&& connection_socket)
+-    : quic::QuicConnection(server_connection_id, initial_peer_address, &helper, &alarm_factory,
+-                           writer, owns_writer, perspective, supported_versions),
+-      connection_socket_(std::move(connection_socket)) {}
+-
+-EnvoyQuicConnection::~EnvoyQuicConnection() { connection_socket_->close(); }
+-
+-uint64_t EnvoyQuicConnection::id() const { return envoy_connection_->id(); }
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_connection.h b/source/extensions/quic_listeners/quiche/envoy_quic_connection.h
+deleted file mode 100644
+index dbc73e9057..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_connection.h
++++ /dev/null
+@@ -1,68 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_connection.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <memory>
+-
+-#include "common/common/logger.h"
+-#include "envoy/network/connection.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Derived for network filter chain, stats and QoS. This is used on both client
+-// and server side.
+-class EnvoyQuicConnection : public quic::QuicConnection,
+-                            protected Logger::Loggable<Logger::Id::connection> {
+-public:
+-  EnvoyQuicConnection(const quic::QuicConnectionId& server_connection_id,
+-                      quic::QuicSocketAddress initial_peer_address,
+-                      quic::QuicConnectionHelperInterface& helper,
+-                      quic::QuicAlarmFactory& alarm_factory, quic::QuicPacketWriter* writer,
+-                      bool owns_writer, quic::Perspective perspective,
+-                      const quic::ParsedQuicVersionVector& supported_versions,
+-                      Network::ConnectionSocketPtr&& connection_socket);
+-
+-  ~EnvoyQuicConnection() override;
+-
+-  // Called by EnvoyQuicSession::setConnectionStats().
+-  void setConnectionStats(const Network::Connection::ConnectionStats& stats) {
+-    connection_stats_ = std::make_unique<Network::Connection::ConnectionStats>(stats);
+-  }
+-
+-  // Called in session Initialize().
+-  void setEnvoyConnection(Network::Connection& connection) { envoy_connection_ = &connection; }
+-
+-  const Network::ConnectionSocketPtr& connectionSocket() const { return connection_socket_; }
+-
+-  // Needed for ENVOY_CONN_LOG.
+-  uint64_t id() const;
+-
+-protected:
+-  Network::Connection::ConnectionStats& connectionStats() const { return *connection_stats_; }
+-
+-  Network::Connection& envoyConnection() const {
+-    ASSERT(envoy_connection_ != nullptr);
+-    return *envoy_connection_;
+-  }
+-
+-private:
+-  // TODO(danzh): populate stats.
+-  std::unique_ptr<Network::Connection::ConnectionStats> connection_stats_;
+-  // Assigned upon construction. Constructed with empty local address if unknown
+-  // by then.
+-  Network::ConnectionSocketPtr connection_socket_;
+-  // Points to an instance of EnvoyQuicServerSession or EnvoyQuicClientSession.
+-  Network::Connection* envoy_connection_{nullptr};
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_connection_helper.h b/source/extensions/quic_listeners/quiche/envoy_quic_connection_helper.h
+deleted file mode 100644
+index 6af08fdece..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_connection_helper.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-#pragma GCC diagnostic ignored "-Wtype-limits"
+-
+-#include "quiche/quic/core/crypto/quic_random.h"
+-#include "quiche/quic/core/quic_connection.h"
+-#include "quiche/quic/core/quic_simple_buffer_allocator.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Derived to provide EnvoyQuicClock and default random generator and buffer
+-// allocator.
+-class EnvoyQuicConnectionHelper : public quic::QuicConnectionHelperInterface {
+-public:
+-  EnvoyQuicConnectionHelper(Event::Dispatcher& dispatcher)
+-      : clock_(dispatcher), random_generator_(quic::QuicRandom::GetInstance()) {}
+-
+-  ~EnvoyQuicConnectionHelper() override = default;
+-
+-  // QuicConnectionHelperInterface
+-  const quic::QuicClock* GetClock() const override { return &clock_; }
+-  quic::QuicRandom* GetRandomGenerator() override { return random_generator_; }
+-  quic::QuicBufferAllocator* GetStreamSendBufferAllocator() override { return &buffer_allocator_; }
+-
+-private:
+-  EnvoyQuicClock clock_;
+-  quic::QuicRandom* random_generator_ = nullptr;
+-  quic::SimpleBufferAllocator buffer_allocator_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.cc b/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.cc
+deleted file mode 100644
+index cc353f0f7e..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.cc
++++ /dev/null
+@@ -1,60 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_dispatcher.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_connection.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_session.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-EnvoyQuicDispatcher::EnvoyQuicDispatcher(
+-    const quic::QuicCryptoServerConfig* crypto_config, const quic::QuicConfig& quic_config,
+-    quic::QuicVersionManager* version_manager,
+-    std::unique_ptr<quic::QuicConnectionHelperInterface> helper,
+-    std::unique_ptr<quic::QuicAlarmFactory> alarm_factory,
+-    uint8_t expected_server_connection_id_length, Network::ConnectionHandler& connection_handler,
+-    Network::ListenerConfig& listener_config, Server::ListenerStats& listener_stats,
+-    Event::Dispatcher& dispatcher)
+-    : quic::QuicDispatcher(&quic_config, crypto_config, version_manager, std::move(helper),
+-                           std::make_unique<EnvoyQuicCryptoServerStreamHelper>(),
+-                           std::move(alarm_factory), expected_server_connection_id_length),
+-      connection_handler_(connection_handler), listener_config_(listener_config),
+-      listener_stats_(listener_stats), dispatcher_(dispatcher) {
+-  // Turn off chlo buffering in QuicDispatcher because per event loop clean
+-  // up is not implemented.
+-  // TODO(danzh): Add a per event loop callback to
+-  // Network::UdpListenerCallbacks which should be called at the beginning
+-  // of HandleReadEvent(). And this callback should call quic::Dispatcher::ProcessBufferedChlos().
+-  SetQuicFlag(FLAGS_quic_allow_chlo_buffering, false);
+-}
+-
+-void EnvoyQuicDispatcher::OnConnectionClosed(quic::QuicConnectionId connection_id,
+-                                             quic::QuicErrorCode error,
+-                                             const std::string& error_details,
+-                                             quic::ConnectionCloseSource source) {
+-  quic::QuicDispatcher::OnConnectionClosed(connection_id, error, error_details, source);
+-  connection_handler_.decNumConnections();
+-}
+-
+-quic::QuicSession* EnvoyQuicDispatcher::CreateQuicSession(
+-    quic::QuicConnectionId server_connection_id, const quic::QuicSocketAddress& peer_address,
+-    quic::QuicStringPiece /*alpn*/, const quic::ParsedQuicVersion& version) {
+-  auto quic_connection = std::make_unique<EnvoyQuicServerConnection>(
+-      server_connection_id, peer_address, *helper(), *alarm_factory(), writer(),
+-      /*owns_writer=*/false, quic::ParsedQuicVersionVector{version}, listener_config_,
+-      listener_stats_);
+-  auto quic_session = new EnvoyQuicServerSession(
+-      config(), quic::ParsedQuicVersionVector{version}, std::move(quic_connection), this,
+-      session_helper(), crypto_config(), compressed_certs_cache(), dispatcher_);
+-  quic_session->Initialize();
+-  // Filter chain can't be retrieved here as self address is unknown at this
+-  // point.
+-  // TODO(danzh): change QUIC interface to pass in self address as it is already
+-  // known. In this way, filter chain can be retrieved at this point. But one
+-  // thing to pay attention is that if the retrieval fails, connection needs to
+-  // be closed, and it should be added to time wait list instead of session map.
+-  connection_handler_.incNumConnections();
+-  return quic_session;
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.h b/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.h
+deleted file mode 100644
+index bdc5808026..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_dispatcher.h
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-#pragma GCC diagnostic ignored "-Wtype-limits"
+-
+-#include "quiche/quic/core/quic_dispatcher.h"
+-#include "quiche/quic/core/quic_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <string>
+-
+-#include "envoy/network/listener.h"
+-#include "server/connection_handler_impl.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Envoy specific provider of server connection id and decision maker of
+-// accepting new connection or not.
+-class EnvoyQuicCryptoServerStreamHelper : public quic::QuicCryptoServerStream::Helper {
+-public:
+-  ~EnvoyQuicCryptoServerStreamHelper() override = default;
+-
+-  // quic::QuicCryptoServerStream::Helper
+-  quic::QuicConnectionId
+-  GenerateConnectionIdForReject(quic::QuicTransportVersion /*version*/,
+-                                quic::QuicConnectionId /*connection_id*/) const override {
+-    // TODO(danzh): create reject connection id based on given connection_id.
+-    return quic::QuicUtils::CreateRandomConnectionId();
+-  }
+-
+-  bool CanAcceptClientHello(const quic::CryptoHandshakeMessage& /*message*/,
+-                            const quic::QuicSocketAddress& /*client_address*/,
+-                            const quic::QuicSocketAddress& /*peer_address*/,
+-                            const quic::QuicSocketAddress& /*self_address*/,
+-                            std::string* /*error_details*/) const override {
+-    // TODO(danzh): decide to accept or not based on information from given handshake message, i.e.
+-    // user agent and SNI.
+-    return true;
+-  }
+-};
+-
+-class EnvoyQuicDispatcher : public quic::QuicDispatcher {
+-public:
+-  EnvoyQuicDispatcher(const quic::QuicCryptoServerConfig* crypto_config,
+-                      const quic::QuicConfig& quic_config,
+-                      quic::QuicVersionManager* version_manager,
+-                      std::unique_ptr<quic::QuicConnectionHelperInterface> helper,
+-                      std::unique_ptr<quic::QuicAlarmFactory> alarm_factory,
+-                      uint8_t expected_server_connection_id_length,
+-                      Network::ConnectionHandler& connection_handler,
+-                      Network::ListenerConfig& listener_config,
+-                      Server::ListenerStats& listener_stats, Event::Dispatcher& dispatcher);
+-
+-  void OnConnectionClosed(quic::QuicConnectionId connection_id, quic::QuicErrorCode error,
+-                          const std::string& error_details,
+-                          quic::ConnectionCloseSource source) override;
+-
+-protected:
+-  quic::QuicSession* CreateQuicSession(quic::QuicConnectionId server_connection_id,
+-                                       const quic::QuicSocketAddress& peer_address,
+-                                       quic::QuicStringPiece alpn,
+-                                       const quic::ParsedQuicVersion& version) override;
+-
+-private:
+-  Network::ConnectionHandler& connection_handler_;
+-  Network::ListenerConfig& listener_config_;
+-  Server::ListenerStats& listener_stats_;
+-  Event::Dispatcher& dispatcher_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h b/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h
+deleted file mode 100644
+index f55ae96562..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-#include "common/common/assert.h"
+-
+-#include "absl/strings/str_cat.h"
+-
+-#pragma GCC diagnostic push
+-
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-#include "quiche/quic/core/crypto/proof_source.h"
+-#include "quiche/quic/core/quic_versions.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "quiche/quic/platform/api/quic_reference_counted.h"
+-#include "quiche/quic/platform/api/quic_socket_address.h"
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// A fake implementation of quic::ProofSource which returns a fake cert and
+-// a fake signature for a given QUIC server config.
+-class EnvoyQuicFakeProofSource : public quic::ProofSource {
+-public:
+-  ~EnvoyQuicFakeProofSource() override = default;
+-
+-  // quic::ProofSource
+-  // Returns a fake certs chain and its fake SCT "Fake timestamp" and fake TLS signature wrapped
+-  // in QuicCryptoProof.
+-  void GetProof(const quic::QuicSocketAddress& server_address, const std::string& hostname,
+-                const std::string& server_config, quic::QuicTransportVersion /*transport_version*/,
+-                quic::QuicStringPiece /*chlo_hash*/,
+-                std::unique_ptr<quic::ProofSource::Callback> callback) override {
+-    quic::QuicReferenceCountedPointer<quic::ProofSource::Chain> chain =
+-        GetCertChain(server_address, hostname);
+-    quic::QuicCryptoProof proof;
+-    bool success = false;
+-    auto signature_callback = std::make_unique<FakeSignatureCallback>(success, proof.signature);
+-    ComputeTlsSignature(server_address, hostname, 0, server_config, std::move(signature_callback));
+-    ASSERT(success);
+-    proof.leaf_cert_scts = "Fake timestamp";
+-    callback->Run(true, chain, proof, nullptr /* details */);
+-  }
+-
+-  // Returns a certs chain with a fake certificate "Fake cert from [host_name]".
+-  quic::QuicReferenceCountedPointer<quic::ProofSource::Chain>
+-  GetCertChain(const quic::QuicSocketAddress& /*server_address*/,
+-               const std::string& /*hostname*/) override {
+-    std::vector<std::string> certs;
+-    certs.push_back(absl::StrCat("Fake cert"));
+-    return quic::QuicReferenceCountedPointer<quic::ProofSource::Chain>(
+-        new quic::ProofSource::Chain(certs));
+-  }
+-
+-  // Always call callback with a signature "Fake signature for { [server_config] }".
+-  void
+-  ComputeTlsSignature(const quic::QuicSocketAddress& /*server_address*/,
+-                      const std::string& /*hostname*/, uint16_t /*signature_algorithm*/,
+-                      quic::QuicStringPiece in,
+-                      std::unique_ptr<quic::ProofSource::SignatureCallback> callback) override {
+-    callback->Run(true, absl::StrCat("Fake signature for { ", in, " }"));
+-  }
+-
+-private:
+-  // Used by GetProof() to get fake signature.
+-  class FakeSignatureCallback : public quic::ProofSource::SignatureCallback {
+-  public:
+-    FakeSignatureCallback(bool& success, std::string& signature)
+-        : success_(success), signature_(signature) {}
+-
+-    // quic::ProofSource::SignatureCallback
+-    void Run(bool ok, std::string signature) override {
+-      success_ = ok;
+-      signature_ = signature;
+-    }
+-
+-  private:
+-    bool& success_;
+-    std::string& signature_;
+-  };
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h b/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h
+deleted file mode 100644
+index 0861e09fb4..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h
++++ /dev/null
+@@ -1,61 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/str_cat.h"
+-
+-#pragma GCC diagnostic push
+-
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-
+-#include "quiche/quic/core/crypto/proof_verifier.h"
+-#include "quiche/quic/core/quic_versions.h"
+-
+-#pragma GCC diagnostic pop
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// A fake implementation of quic::ProofVerifier which approves the certs and
+-// signature produced by EnvoyQuicFakeProofSource.
+-class EnvoyQuicFakeProofVerifier : public quic::ProofVerifier {
+-public:
+-  ~EnvoyQuicFakeProofVerifier() override = default;
+-
+-  // quic::ProofVerifier
+-  // Return success if the certs chain is valid and signature is "Fake signature for {
+-  // [server_config] }". Otherwise failure.
+-  quic::QuicAsyncStatus
+-  VerifyProof(const std::string& hostname, const uint16_t /*port*/,
+-              const std::string& server_config, quic::QuicTransportVersion /*quic_version*/,
+-              absl::string_view /*chlo_hash*/, const std::vector<std::string>& certs,
+-              const std::string& cert_sct, const std::string& signature,
+-              const quic::ProofVerifyContext* context, std::string* error_details,
+-              std::unique_ptr<quic::ProofVerifyDetails>* details,
+-              std::unique_ptr<quic::ProofVerifierCallback> callback) override {
+-    if (VerifyCertChain(hostname, certs, "", cert_sct, context, error_details, details,
+-                        std::move(callback)) == quic::QUIC_SUCCESS &&
+-        signature == absl::StrCat("Fake signature for { ", server_config, " }")) {
+-      return quic::QUIC_SUCCESS;
+-    }
+-    return quic::QUIC_FAILURE;
+-  }
+-
+-  // Return success if the certs chain has only one fake certificate "Fake cert from [host_name]"
+-  // and its SCT is "Fake timestamp". Otherwise failure.
+-  quic::QuicAsyncStatus
+-  VerifyCertChain(const std::string& /*hostname*/, const std::vector<std::string>& certs,
+-                  const std::string& /*ocsp_response*/, const std::string& cert_sct,
+-                  const quic::ProofVerifyContext* /*context*/, std::string* /*error_details*/,
+-                  std::unique_ptr<quic::ProofVerifyDetails>* /*details*/,
+-                  std::unique_ptr<quic::ProofVerifierCallback> /*callback*/) override {
+-    if (cert_sct == "Fake timestamp" && certs.size() == 1 && certs[0] == "Fake cert") {
+-      return quic::QUIC_SUCCESS;
+-    }
+-    return quic::QUIC_FAILURE;
+-  }
+-
+-  std::unique_ptr<quic::ProofVerifyContext> CreateDefaultContext() override { return nullptr; }
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.cc b/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.cc
+deleted file mode 100644
+index 02360ae9b6..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.cc
++++ /dev/null
+@@ -1,55 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_packet_writer.h"
+-
+-#include <sys/socket.h>
+-
+-#pragma GCC diagnostic push
+-
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_types.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "common/buffer/buffer_impl.h"
+-#include "common/network/utility.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-EnvoyQuicPacketWriter::EnvoyQuicPacketWriter(Network::Socket& socket)
+-    : write_blocked_(false), socket_(socket) {}
+-
+-quic::WriteResult EnvoyQuicPacketWriter::WritePacket(const char* buffer, size_t buf_len,
+-                                                     const quic::QuicIpAddress& self_ip,
+-                                                     const quic::QuicSocketAddress& peer_address,
+-                                                     quic::PerPacketOptions* options) {
+-  ASSERT(options == nullptr, "Per packet option is not supported yet.");
+-  ASSERT(!write_blocked_, "Cannot write while IO handle is blocked.");
+-
+-  Buffer::RawSlice slice;
+-  slice.mem_ = const_cast<char*>(buffer);
+-  slice.len_ = buf_len;
+-  quic::QuicSocketAddress self_address(self_ip, /*port=*/0);
+-  Network::Address::InstanceConstSharedPtr local_addr =
+-      quicAddressToEnvoyAddressInstance(self_address);
+-  Network::Address::InstanceConstSharedPtr remote_addr =
+-      quicAddressToEnvoyAddressInstance(peer_address);
+-  Api::IoCallUint64Result result = Network::Utility::writeToSocket(
+-      socket_, &slice, 1, local_addr == nullptr ? nullptr : local_addr->ip(), *remote_addr);
+-  if (result.ok()) {
+-    return {quic::WRITE_STATUS_OK, static_cast<int>(result.rc_)};
+-  }
+-  quic::WriteStatus status = result.err_->getErrorCode() == Api::IoError::IoErrorCode::Again
+-                                 ? quic::WRITE_STATUS_BLOCKED
+-                                 : quic::WRITE_STATUS_ERROR;
+-  if (quic::IsWriteBlockedStatus(status)) {
+-    write_blocked_ = true;
+-  }
+-  return {status, static_cast<int>(result.err_->getErrorCode())};
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.h b/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.h
+deleted file mode 100644
+index 55a6e5146d..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_packet_writer.h
++++ /dev/null
+@@ -1,50 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_packet_writer.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "envoy/network/listener.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicPacketWriter : public quic::QuicPacketWriter {
+-public:
+-  EnvoyQuicPacketWriter(Network::Socket& socket);
+-
+-  quic::WriteResult WritePacket(const char* buffer, size_t buf_len,
+-                                const quic::QuicIpAddress& self_address,
+-                                const quic::QuicSocketAddress& peer_address,
+-                                quic::PerPacketOptions* options) override;
+-
+-  // quic::QuicPacketWriter
+-  bool IsWriteBlocked() const override { return write_blocked_; }
+-  void SetWritable() override { write_blocked_ = false; }
+-  quic::QuicByteCount
+-  GetMaxPacketSize(const quic::QuicSocketAddress& /*peer_address*/) const override {
+-    return quic::kMaxOutgoingPacketSize;
+-  }
+-  // Currently this writer doesn't support pacing offload or batch writing.
+-  bool SupportsReleaseTime() const override { return false; }
+-  bool IsBatchMode() const override { return false; }
+-  char* GetNextWriteLocation(const quic::QuicIpAddress& /*self_address*/,
+-                             const quic::QuicSocketAddress& /*peer_address*/) override {
+-    return nullptr;
+-  }
+-  quic::WriteResult Flush() override { return {quic::WRITE_STATUS_OK, 0}; }
+-
+-private:
+-  // Modified by WritePacket() to indicate underlying IoHandle status.
+-  bool write_blocked_;
+-  Network::Socket& socket_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.cc b/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.cc
+deleted file mode 100644
+index eb4cce541a..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.cc
++++ /dev/null
+@@ -1,61 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_connection.h"
+-
+-#include "common/network/listen_socket_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "extensions/quic_listeners/quiche/quic_io_handle_wrapper.h"
+-#include "extensions/transport_sockets/well_known_names.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-EnvoyQuicServerConnection::EnvoyQuicServerConnection(
+-    const quic::QuicConnectionId& server_connection_id,
+-    quic::QuicSocketAddress initial_peer_address, quic::QuicConnectionHelperInterface& helper,
+-    quic::QuicAlarmFactory& alarm_factory, quic::QuicPacketWriter* writer, bool owns_writer,
+-    const quic::ParsedQuicVersionVector& supported_versions,
+-    Network::ListenerConfig& listener_config, Server::ListenerStats& listener_stats)
+-    : EnvoyQuicConnection(
+-          server_connection_id, initial_peer_address, helper, alarm_factory, writer, owns_writer,
+-          quic::Perspective::IS_SERVER, supported_versions,
+-          std::make_unique<Network::ConnectionSocketImpl>(
+-              // Wraps the real IoHandle instance so that if the connection socket gets closed,
+-              // the real IoHandle won't be affected.
+-              std::make_unique<QuicIoHandleWrapper>(listener_config.socket().ioHandle()), nullptr,
+-              quicAddressToEnvoyAddressInstance(initial_peer_address))),
+-      listener_config_(listener_config), listener_stats_(listener_stats) {}
+-
+-bool EnvoyQuicServerConnection::OnPacketHeader(const quic::QuicPacketHeader& header) {
+-  if (!EnvoyQuicConnection::OnPacketHeader(header)) {
+-    return false;
+-  }
+-  if (connectionSocket()->localAddress() != nullptr) {
+-    return true;
+-  }
+-  ASSERT(self_address().IsInitialized());
+-  // Self address should be initialized by now. It's time to install filters.
+-  connectionSocket()->setLocalAddress(quicAddressToEnvoyAddressInstance(self_address()));
+-  connectionSocket()->setDetectedTransportProtocol(
+-      Extensions::TransportSockets::TransportProtocolNames::get().Quic);
+-  ASSERT(filter_chain_ == nullptr);
+-  filter_chain_ = listener_config_.filterChainManager().findFilterChain(*connectionSocket());
+-  if (filter_chain_ == nullptr) {
+-    listener_stats_.no_filter_chain_match_.inc();
+-    CloseConnection(quic::QUIC_CRYPTO_INTERNAL_ERROR,
+-                    "closing connection: no matching filter chain found for handshake",
+-                    quic::ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
+-    return false;
+-  }
+-  const bool empty_filter_chain = !listener_config_.filterChainFactory().createNetworkFilterChain(
+-      envoyConnection(), filter_chain_->networkFilterFactories());
+-  if (empty_filter_chain) {
+-    // TODO(danzh) check empty filter chain at config load time instead of here.
+-    CloseConnection(quic::QUIC_CRYPTO_INTERNAL_ERROR, "closing connection: filter chain is empty",
+-                    quic::ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
+-    return false;
+-  }
+-  return true;
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.h b/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.h
+deleted file mode 100644
+index 587e3a3e5f..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_connection.h
++++ /dev/null
+@@ -1,34 +0,0 @@
+-#include "envoy/network/listener.h"
+-
+-#include "server/connection_handler_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicServerConnection : public EnvoyQuicConnection {
+-public:
+-  EnvoyQuicServerConnection(const quic::QuicConnectionId& server_connection_id,
+-                            quic::QuicSocketAddress initial_peer_address,
+-                            quic::QuicConnectionHelperInterface& helper,
+-                            quic::QuicAlarmFactory& alarm_factory, quic::QuicPacketWriter* writer,
+-                            bool owns_writer,
+-                            const quic::ParsedQuicVersionVector& supported_versions,
+-                            Network::ListenerConfig& listener_config,
+-                            Server::ListenerStats& listener_stats);
+-
+-  // EnvoyQuicConnection
+-  // Overridden to set connection_socket_ with initialized self address and retrieve filter chain.
+-  bool OnPacketHeader(const quic::QuicPacketHeader& header) override;
+-
+-private:
+-  Network::ListenerConfig& listener_config_;
+-  Server::ListenerStats& listener_stats_;
+-  // Latched to the corresponding quic FilterChain after connection_socket_ is
+-  // initialized.
+-  const Network::FilterChain* filter_chain_{nullptr};
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_session.cc b/source/extensions/quic_listeners/quiche/envoy_quic_server_session.cc
+deleted file mode 100644
+index 021c390e47..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_session.cc
++++ /dev/null
+@@ -1,93 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_session.h"
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_crypto_server_stream.h"
+-#pragma GCC diagnostic pop
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_stream.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-EnvoyQuicServerSession::EnvoyQuicServerSession(
+-    const quic::QuicConfig& config, const quic::ParsedQuicVersionVector& supported_versions,
+-    std::unique_ptr<EnvoyQuicConnection> connection, quic::QuicSession::Visitor* visitor,
+-    quic::QuicCryptoServerStream::Helper* helper, const quic::QuicCryptoServerConfig* crypto_config,
+-    quic::QuicCompressedCertsCache* compressed_certs_cache, Event::Dispatcher& dispatcher)
+-    : quic::QuicServerSessionBase(config, supported_versions, connection.get(), visitor, helper,
+-                                  crypto_config, compressed_certs_cache),
+-      QuicFilterManagerConnectionImpl(std::move(connection), dispatcher) {}
+-
+-absl::string_view EnvoyQuicServerSession::requestedServerName() const {
+-  return {GetCryptoStream()->crypto_negotiated_params().sni};
+-}
+-
+-quic::QuicCryptoServerStreamBase* EnvoyQuicServerSession::CreateQuicCryptoServerStream(
+-    const quic::QuicCryptoServerConfig* crypto_config,
+-    quic::QuicCompressedCertsCache* compressed_certs_cache) {
+-  return new quic::QuicCryptoServerStream(crypto_config, compressed_certs_cache, this,
+-                                          stream_helper());
+-}
+-
+-quic::QuicSpdyStream* EnvoyQuicServerSession::CreateIncomingStream(quic::QuicStreamId id) {
+-  if (!ShouldCreateIncomingStream(id)) {
+-    return nullptr;
+-  }
+-  auto stream = new EnvoyQuicServerStream(id, this, quic::BIDIRECTIONAL);
+-  ActivateStream(absl::WrapUnique(stream));
+-  setUpRequestDecoder(*stream);
+-  return stream;
+-}
+-
+-quic::QuicSpdyStream*
+-EnvoyQuicServerSession::CreateIncomingStream(quic::PendingStream* /*pending*/) {
+-  // Only client side server push stream should trigger this call.
+-  NOT_REACHED_GCOVR_EXCL_LINE;
+-}
+-
+-quic::QuicSpdyStream* EnvoyQuicServerSession::CreateOutgoingBidirectionalStream() {
+-  // Disallow server initiated stream.
+-  NOT_REACHED_GCOVR_EXCL_LINE;
+-}
+-
+-quic::QuicSpdyStream* EnvoyQuicServerSession::CreateOutgoingUnidirectionalStream() {
+-  NOT_REACHED_GCOVR_EXCL_LINE;
+-}
+-
+-void EnvoyQuicServerSession::setUpRequestDecoder(EnvoyQuicStream& stream) {
+-  ASSERT(http_connection_callbacks_ != nullptr);
+-  Http::StreamDecoder& decoder = http_connection_callbacks_->newStream(stream);
+-  stream.setDecoder(decoder);
+-}
+-
+-void EnvoyQuicServerSession::OnConnectionClosed(const quic::QuicConnectionCloseFrame& frame,
+-                                                quic::ConnectionCloseSource source) {
+-  quic::QuicServerSessionBase::OnConnectionClosed(frame, source);
+-  onConnectionCloseEvent(frame, source);
+-}
+-
+-void EnvoyQuicServerSession::Initialize() {
+-  quic::QuicServerSessionBase::Initialize();
+-  quic_connection_->setEnvoyConnection(*this);
+-}
+-
+-void EnvoyQuicServerSession::SendGoAway(quic::QuicErrorCode error_code, const std::string& reason) {
+-  if (transport_version() < quic::QUIC_VERSION_99) {
+-    quic::QuicServerSessionBase::SendGoAway(error_code, reason);
+-  }
+-}
+-
+-void EnvoyQuicServerSession::OnCryptoHandshakeEvent(CryptoHandshakeEvent event) {
+-  quic::QuicServerSessionBase::OnCryptoHandshakeEvent(event);
+-  if (event == HANDSHAKE_CONFIRMED) {
+-    raiseEvent(Network::ConnectionEvent::Connected);
+-  }
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_session.h b/source/extensions/quic_listeners/quiche/envoy_quic_server_session.h
+deleted file mode 100644
+index d849aa0161..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_session.h
++++ /dev/null
+@@ -1,73 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-#pragma GCC diagnostic ignored "-Wtype-limits"
+-
+-#include "quiche/quic/core/http/quic_server_session_base.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <memory>
+-
+-#include "extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_stream.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Act as a Network::Connection to HCM and a FilterManager to FilterFactoryCb.
+-class EnvoyQuicServerSession : public quic::QuicServerSessionBase,
+-                               public QuicFilterManagerConnectionImpl {
+-public:
+-  EnvoyQuicServerSession(const quic::QuicConfig& config,
+-                         const quic::ParsedQuicVersionVector& supported_versions,
+-                         std::unique_ptr<EnvoyQuicConnection> connection,
+-                         quic::QuicSession::Visitor* visitor,
+-                         quic::QuicCryptoServerStream::Helper* helper,
+-                         const quic::QuicCryptoServerConfig* crypto_config,
+-                         quic::QuicCompressedCertsCache* compressed_certs_cache,
+-                         Event::Dispatcher& dispatcher);
+-
+-  // Network::Connection
+-  absl::string_view requestedServerName() const override;
+-
+-  // Called by QuicHttpServerConnectionImpl before creating data streams.
+-  void setHttpConnectionCallbacks(Http::ServerConnectionCallbacks& callbacks) {
+-    http_connection_callbacks_ = &callbacks;
+-  }
+-
+-  // quic::QuicSession
+-  void OnConnectionClosed(const quic::QuicConnectionCloseFrame& frame,
+-                          quic::ConnectionCloseSource source) override;
+-  void Initialize() override;
+-  void SendGoAway(quic::QuicErrorCode error_code, const std::string& reason) override;
+-  // quic::QuicSpdySession
+-  void OnCryptoHandshakeEvent(CryptoHandshakeEvent event) override;
+-
+-protected:
+-  // quic::QuicServerSessionBase
+-  quic::QuicCryptoServerStreamBase*
+-  CreateQuicCryptoServerStream(const quic::QuicCryptoServerConfig* crypto_config,
+-                               quic::QuicCompressedCertsCache* compressed_certs_cache) override;
+-
+-  // quic::QuicSession
+-  // Overridden to create stream as encoder and associate it with an decoder.
+-  quic::QuicSpdyStream* CreateIncomingStream(quic::QuicStreamId id) override;
+-  quic::QuicSpdyStream* CreateIncomingStream(quic::PendingStream* pending) override;
+-  quic::QuicSpdyStream* CreateOutgoingBidirectionalStream() override;
+-  quic::QuicSpdyStream* CreateOutgoingUnidirectionalStream() override;
+-
+-private:
+-  void setUpRequestDecoder(EnvoyQuicStream& stream);
+-
+-  // These callbacks are owned by network filters and quic session should out live
+-  // them.
+-  Http::ServerConnectionCallbacks* http_connection_callbacks_{nullptr};
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.cc b/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.cc
+deleted file mode 100644
+index 35bd63f811..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.cc
++++ /dev/null
+@@ -1,132 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_stream.h"
+-
+-#include <openssl/bio.h>
+-#include <openssl/evp.h>
+-
+-#include <cstddef>
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/http/quic_header_list.h"
+-#include "quiche/quic/core/quic_session.h"
+-#include "quiche/spdy/core/spdy_header_block.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "common/buffer/buffer_impl.h"
+-#include "common/http/header_map_impl.h"
+-#include "common/common/assert.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-void EnvoyQuicServerStream::encode100ContinueHeaders(const Http::HeaderMap& headers) {
+-  ASSERT(headers.Status()->value() == "100");
+-  encodeHeaders(headers, false);
+-}
+-void EnvoyQuicServerStream::encodeHeaders(const Http::HeaderMap& /*headers*/, bool /*end_stream*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-void EnvoyQuicServerStream::encodeData(Buffer::Instance& /*data*/, bool /*end_stream*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-void EnvoyQuicServerStream::encodeTrailers(const Http::HeaderMap& /*trailers*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-void EnvoyQuicServerStream::encodeMetadata(const Http::MetadataMapVector& /*metadata_map_vector*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-void EnvoyQuicServerStream::resetStream(Http::StreamResetReason /*reason*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-void EnvoyQuicServerStream::readDisable(bool /*disable*/) { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }
+-
+-void EnvoyQuicServerStream::OnInitialHeadersComplete(bool fin, size_t frame_len,
+-                                                     const quic::QuicHeaderList& header_list) {
+-  quic::QuicSpdyServerStreamBase::OnInitialHeadersComplete(fin, frame_len, header_list);
+-  ASSERT(decoder() != nullptr);
+-  ASSERT(headers_decompressed());
+-  decoder()->decodeHeaders(quicHeadersToEnvoyHeaders(header_list), /*end_stream=*/fin);
+-  ConsumeHeaderList();
+-}
+-
+-void EnvoyQuicServerStream::OnBodyAvailable() {
+-  Buffer::InstancePtr buffer = std::make_unique<Buffer::OwnedImpl>();
+-  // TODO(danzh): check Envoy per stream buffer limit.
+-  // Currently read out all the data.
+-  while (HasBytesToRead()) {
+-    struct iovec iov;
+-    int num_regions = GetReadableRegions(&iov, 1);
+-    ASSERT(num_regions > 0);
+-    size_t bytes_read = iov.iov_len;
+-    Buffer::RawSlice slice;
+-    buffer->reserve(bytes_read, &slice, 1);
+-    ASSERT(slice.len_ >= bytes_read);
+-    slice.len_ = bytes_read;
+-    memcpy(slice.mem_, iov.iov_base, iov.iov_len);
+-    buffer->commit(&slice, 1);
+-    MarkConsumed(bytes_read);
+-  }
+-
+-  // True if no trailer and FIN read.
+-  bool finished_reading = IsDoneReading();
+-  // If this is the last stream data, set end_stream if there is no
+-  // trailers.
+-  ASSERT(decoder() != nullptr);
+-  decoder()->decodeData(*buffer, finished_reading);
+-  if (!quic::VersionUsesQpack(transport_version()) && sequencer()->IsClosed() &&
+-      !FinishedReadingTrailers()) {
+-    // For Google QUIC implementation, trailers may arrived earlier and wait to
+-    // be consumed after reading all the body. Consume it here.
+-    // IETF QUIC shouldn't reach here because trailers are sent on same stream.
+-    decoder()->decodeTrailers(spdyHeaderBlockToEnvoyHeaders(received_trailers()));
+-    MarkTrailersConsumed();
+-  }
+-}
+-
+-void EnvoyQuicServerStream::OnTrailingHeadersComplete(bool fin, size_t frame_len,
+-                                                      const quic::QuicHeaderList& header_list) {
+-  quic::QuicSpdyServerStreamBase::OnTrailingHeadersComplete(fin, frame_len, header_list);
+-  if (session()->connection()->connected() &&
+-      (quic::VersionUsesQpack(transport_version()) || sequencer()->IsClosed()) &&
+-      !FinishedReadingTrailers()) {
+-    // Before QPack trailers can arrive before body. Only decode trailers after finishing decoding
+-    // body.
+-    ASSERT(decoder() != nullptr);
+-    decoder()->decodeTrailers(spdyHeaderBlockToEnvoyHeaders(received_trailers()));
+-    MarkTrailersConsumed();
+-  }
+-}
+-
+-void EnvoyQuicServerStream::OnStreamReset(const quic::QuicRstStreamFrame& frame) {
+-  quic::QuicSpdyServerStreamBase::OnStreamReset(frame);
+-  Http::StreamResetReason reason;
+-  if (frame.error_code == quic::QUIC_REFUSED_STREAM) {
+-    reason = Http::StreamResetReason::RemoteRefusedStreamReset;
+-  } else {
+-    reason = Http::StreamResetReason::RemoteReset;
+-  }
+-  runResetCallbacks(reason);
+-}
+-
+-void EnvoyQuicServerStream::OnConnectionClosed(quic::QuicErrorCode error,
+-                                               quic::ConnectionCloseSource source) {
+-  quic::QuicSpdyServerStreamBase::OnConnectionClosed(error, source);
+-  Http::StreamResetReason reason;
+-  if (error == quic::QUIC_NO_ERROR) {
+-    reason = Http::StreamResetReason::ConnectionTermination;
+-  } else {
+-    reason = Http::StreamResetReason::ConnectionFailure;
+-  }
+-  runResetCallbacks(reason);
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.h b/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.h
+deleted file mode 100644
+index 047970f4fd..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_server_stream.h
++++ /dev/null
+@@ -1,52 +0,0 @@
+-#pragma once
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-#include "quiche/quic/core/http/quic_spdy_server_stream_base.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_stream.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// This class is a quic stream and also a response encoder.
+-class EnvoyQuicServerStream : public quic::QuicSpdyServerStreamBase, public EnvoyQuicStream {
+-public:
+-  EnvoyQuicServerStream(quic::QuicStreamId id, quic::QuicSpdySession* session,
+-                        quic::StreamType type)
+-      : quic::QuicSpdyServerStreamBase(id, session, type) {}
+-  EnvoyQuicServerStream(quic::PendingStream* pending, quic::QuicSpdySession* session,
+-                        quic::StreamType type)
+-      : quic::QuicSpdyServerStreamBase(pending, session, type) {}
+-
+-  // Http::StreamEncoder
+-  void encode100ContinueHeaders(const Http::HeaderMap& headers) override;
+-  void encodeHeaders(const Http::HeaderMap& headers, bool end_stream) override;
+-  void encodeData(Buffer::Instance& data, bool end_stream) override;
+-  void encodeTrailers(const Http::HeaderMap& trailers) override;
+-  void encodeMetadata(const Http::MetadataMapVector& metadata_map_vector) override;
+-
+-  // Http::Stream
+-  void resetStream(Http::StreamResetReason reason) override;
+-  void readDisable(bool disable) override;
+-  // quic::QuicSpdyStream
+-  void OnBodyAvailable() override;
+-  void OnStreamReset(const quic::QuicRstStreamFrame& frame) override;
+-  // quic::QuicServerSessionBase
+-  void OnConnectionClosed(quic::QuicErrorCode error, quic::ConnectionCloseSource source) override;
+-
+-protected:
+-  // quic::QuicSpdyStream
+-  void OnInitialHeadersComplete(bool fin, size_t frame_len,
+-                                const quic::QuicHeaderList& header_list) override;
+-  void OnTrailingHeadersComplete(bool fin, size_t frame_len,
+-                                 const quic::QuicHeaderList& header_list) override;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_stream.h b/source/extensions/quic_listeners/quiche/envoy_quic_stream.h
+deleted file mode 100644
+index a6126224cc..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_stream.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#pragma once
+-
+-#include "envoy/http/codec.h"
+-
+-#include "common/http/codec_helper.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Base class for EnvoyQuicServer|ClientStream.
+-class EnvoyQuicStream : public Http::StreamEncoder,
+-                        public Http::Stream,
+-                        public Http::StreamCallbackHelper {
+-public:
+-  // Http::StreamEncoder
+-  Stream& getStream() override { return *this; }
+-
+-  // Http::Stream
+-  void addCallbacks(Http::StreamCallbacks& callbacks) override {
+-    ASSERT(!local_end_stream_);
+-    addCallbacks_(callbacks);
+-  }
+-  void removeCallbacks(Http::StreamCallbacks& callbacks) override { removeCallbacks_(callbacks); }
+-  uint32_t bufferLimit() override { NOT_IMPLEMENTED_GCOVR_EXCL_LINE; }
+-
+-  // Needs to be called during quic stream creation before the stream receives
+-  // any headers and data.
+-  void setDecoder(Http::StreamDecoder& decoder) { decoder_ = &decoder; }
+-
+-protected:
+-  Http::StreamDecoder* decoder() {
+-    ASSERT(decoder_ != nullptr);
+-    return decoder_;
+-  }
+-
+-private:
+-  // Not owned.
+-  Http::StreamDecoder* decoder_{nullptr};
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_utils.cc b/source/extensions/quic_listeners/quiche/envoy_quic_utils.cc
+deleted file mode 100644
+index 33e0c43fc0..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_utils.cc
++++ /dev/null
+@@ -1,66 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-
+-#include <sys/socket.h>
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// TODO(danzh): this is called on each write. Consider to return an address instance on the stack if
+-// the heap allocation is too expensive.
+-Network::Address::InstanceConstSharedPtr
+-quicAddressToEnvoyAddressInstance(const quic::QuicSocketAddress& quic_address) {
+-  return quic_address.IsInitialized()
+-             ? Network::Address::addressFromSockAddr(quic_address.generic_address(),
+-                                                     quic_address.host().address_family() ==
+-                                                             quic::IpAddressFamily::IP_V4
+-                                                         ? sizeof(sockaddr_in)
+-                                                         : sizeof(sockaddr_in6),
+-                                                     false)
+-             : nullptr;
+-}
+-
+-quic::QuicSocketAddress envoyAddressInstanceToQuicSocketAddress(
+-    const Network::Address::InstanceConstSharedPtr& envoy_address) {
+-  ASSERT(envoy_address != nullptr && envoy_address->type() == Network::Address::Type::Ip);
+-  uint32_t port = envoy_address->ip()->port();
+-  sockaddr_storage ss;
+-  if (envoy_address->ip()->version() == Network::Address::IpVersion::v4) {
+-    auto ipv4_addr = reinterpret_cast<sockaddr_in*>(&ss);
+-    memset(ipv4_addr, 0, sizeof(sockaddr_in));
+-    ipv4_addr->sin_family = AF_INET;
+-    ipv4_addr->sin_port = htons(port);
+-    ipv4_addr->sin_addr.s_addr = envoy_address->ip()->ipv4()->address();
+-  } else {
+-    auto ipv6_addr = reinterpret_cast<sockaddr_in6*>(&ss);
+-    memset(ipv6_addr, 0, sizeof(sockaddr_in6));
+-    ipv6_addr->sin6_family = AF_INET6;
+-    ipv6_addr->sin6_port = htons(port);
+-    ASSERT(sizeof(ipv6_addr->sin6_addr.s6_addr) == 16u);
+-    *reinterpret_cast<absl::uint128*>(ipv6_addr->sin6_addr.s6_addr) =
+-        envoy_address->ip()->ipv6()->address();
+-  }
+-  return quic::QuicSocketAddress(ss);
+-}
+-
+-Http::HeaderMapImplPtr quicHeadersToEnvoyHeaders(const quic::QuicHeaderList& header_list) {
+-  Http::HeaderMapImplPtr headers = std::make_unique<Http::HeaderMapImpl>();
+-  for (const auto& entry : header_list) {
+-    // TODO(danzh): Avoid copy by referencing entry as header_list is already validated by QUIC.
+-    headers->addCopy(Http::LowerCaseString(entry.first), entry.second);
+-  }
+-  return headers;
+-}
+-
+-Http::HeaderMapImplPtr spdyHeaderBlockToEnvoyHeaders(const spdy::SpdyHeaderBlock& header_block) {
+-  Http::HeaderMapImplPtr headers = std::make_unique<Http::HeaderMapImpl>();
+-  for (auto entry : header_block) {
+-    // TODO(danzh): Avoid temporary strings and addCopy() with std::string_view.
+-    std::string key(entry.first);
+-    std::string value(entry.second);
+-    headers->addCopy(Http::LowerCaseString(key), value);
+-  }
+-  return headers;
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/envoy_quic_utils.h b/source/extensions/quic_listeners/quiche/envoy_quic_utils.h
+deleted file mode 100644
+index 54b1bf07f6..0000000000
+--- a/source/extensions/quic_listeners/quiche/envoy_quic_utils.h
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#include "envoy/http/codec.h"
+-
+-#include "common/common/assert.h"
+-#include "common/http/header_map_impl.h"
+-#include "common/network/address_impl.h"
+-
+-#include "quiche/quic/core/http/quic_header_list.h"
+-#include "quiche/quic/core/quic_error_codes.h"
+-#include "quiche/quic/platform/api/quic_ip_address.h"
+-#include "quiche/quic/platform/api/quic_socket_address.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// TODO(danzh): this is called on each write. Consider to return an address instance on the stack if
+-// the heap allocation is too expensive.
+-Network::Address::InstanceConstSharedPtr
+-quicAddressToEnvoyAddressInstance(const quic::QuicSocketAddress& quic_address);
+-
+-quic::QuicSocketAddress envoyAddressInstanceToQuicSocketAddress(
+-    const Network::Address::InstanceConstSharedPtr& envoy_address);
+-
+-// The returned header map has all keys in lower case.
+-Http::HeaderMapImplPtr quicHeadersToEnvoyHeaders(const quic::QuicHeaderList& header_list);
+-
+-Http::HeaderMapImplPtr spdyHeaderBlockToEnvoyHeaders(const spdy::SpdyHeaderBlock& header_block);
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/platform/BUILD b/source/extensions/quic_listeners/quiche/platform/BUILD
+deleted file mode 100644
+index 1f781a100b..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/BUILD
++++ /dev/null
+@@ -1,325 +0,0 @@
+-licenses(["notice"])  # Apache 2
+-
+-load(
+-    "//bazel:envoy_build_system.bzl",
+-    "envoy_cc_library",
+-    "envoy_cc_test_library",
+-    "envoy_package",
+-)
+-
+-envoy_package()
+-
+-# Build targets in this package are part of the QUICHE platform implementation.
+-# These implementations are the infrastructure building block for QUIC. They are
+-# used in 2 different ways:
+-#
+-# Most of them are not to be consumed or referenced directly by other Envoy code.
+-# Their only consumers should be build rules under @com_googlesource_quiche//...,
+-# and tests. In a monorepo, this would be enforced via visibility attribute, but
+-# Bazel does not support limiting visibility to specific external dependencies.
+-#
+-# Very few of them are used by Envoy to interact with QUIC. They are used as a shim
+-# to match a non-virtualized API required by the external Quiche implementation.
+-#
+-# See a detailed description of QUIC platform API dependency model at:
+-# https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/platform/api/README.md
+-
+-# These implementations are tested through their APIs with tests mostly brought in from
+-# QUICHE, thus new unit tests for them are deliberately omitted in Envoy tree. These
+-# tests are added to @com_googlesource_quiche//:quic_platform_api_test. And all tests
+-# under @com_googlesource_quiche// are configured in test/coverage/gen_build.sh to run in
+-# CI.
+-# For some APIs which are not covered in QUICHE tests, their tests is added into
+-# //test/extensions/quic_listeners/quiche/platform/.
+-
+-# TODO: add build target for quic_platform_impl_lib
+-
+-envoy_cc_library(
+-    name = "flags_impl_lib",
+-    srcs = ["flags_impl.cc"],
+-    hdrs = [
+-        "flags_impl.h",
+-        "flags_list.h",
+-    ],
+-    external_deps = [
+-        "abseil_base",
+-        "abseil_synchronization",
+-    ],
+-    visibility = ["//visibility:public"],
+-)
+-
+-envoy_cc_library(
+-    name = "string_utils_lib",
+-    srcs = ["string_utils.cc"],
+-    hdrs = ["string_utils.h"],
+-    external_deps = ["abseil_str_format"],
+-    visibility = ["//visibility:private"],
+-    deps = [
+-        "//source/common/common:assert_lib",
+-        "//source/common/common:base64_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "http2_platform_impl_lib",
+-    hdrs = [
+-        "http2_arraysize_impl.h",
+-        "http2_bug_tracker_impl.h",
+-        "http2_containers_impl.h",
+-        "http2_estimate_memory_usage_impl.h",
+-        "http2_export_impl.h",
+-        "http2_flag_utils_impl.h",
+-        "http2_flags_impl.h",
+-        "http2_logging_impl.h",
+-        "http2_macros_impl.h",
+-        "http2_optional_impl.h",
+-        "http2_ptr_util_impl.h",
+-        "http2_string_impl.h",
+-        "http2_string_piece_impl.h",
+-        "http2_string_utils_impl.h",
+-    ],
+-    external_deps = [
+-        "abseil_base",
+-        "abseil_optional",
+-        "abseil_str_format",
+-    ],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        ":flags_impl_lib",
+-        ":quic_platform_logging_impl_lib",
+-        ":string_utils_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_export_impl_lib",
+-    hdrs = ["quic_export_impl.h"],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_logging_impl_lib",
+-    srcs = ["quic_logging_impl.cc"],
+-    hdrs = [
+-        "quic_bug_tracker_impl.h",
+-        "quic_logging_impl.h",
+-    ],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "//source/common/common:assert_lib",
+-        "//source/common/common:stl_helpers",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_base_impl_lib",
+-    srcs = [
+-        "quic_mem_slice_impl.cc",
+-    ],
+-    hdrs = [
+-        "quic_aligned_impl.h",
+-        "quic_arraysize_impl.h",
+-        "quic_client_stats_impl.h",
+-        "quic_containers_impl.h",
+-        "quic_endian_impl.h",
+-        "quic_error_code_wrappers_impl.h",
+-        "quic_estimate_memory_usage_impl.h",
+-        "quic_fallthrough_impl.h",
+-        "quic_flag_utils_impl.h",
+-        "quic_flags_impl.h",
+-        "quic_iovec_impl.h",
+-        "quic_macros_impl.h",
+-        "quic_map_util_impl.h",
+-        "quic_mem_slice_impl.h",
+-        "quic_optional_impl.h",
+-        "quic_prefetch_impl.h",
+-        "quic_ptr_util_impl.h",
+-        "quic_reference_counted_impl.h",
+-        "quic_server_stats_impl.h",
+-        "quic_stack_trace_impl.h",
+-        "quic_str_cat_impl.h",
+-        "quic_stream_buffer_allocator_impl.h",
+-        "quic_string_piece_impl.h",
+-        "quic_text_utils_impl.h",
+-        "quic_uint128_impl.h",
+-    ],
+-    external_deps = [
+-        "abseil_base",
+-        "abseil_hash",
+-        "abseil_inlined_vector",
+-        "abseil_memory",
+-        "abseil_node_hash_map",
+-        "abseil_node_hash_set",
+-        "abseil_optional",
+-        "googletest",
+-    ],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        ":flags_impl_lib",
+-        ":string_utils_lib",
+-        "//include/envoy/api:io_error_interface",
+-        "//source/common/buffer:buffer_lib",
+-        "//source/common/common:assert_lib",
+-        "//source/common/common:byte_order_lib",
+-        "//source/server:backtrace_lib",
+-        "@com_googlesource_quiche//:quic_core_buffer_allocator_lib",
+-        "@com_googlesource_quiche//:quic_platform_export",
+-        "@com_googlesource_quiche//:quic_platform_ip_address_family",
+-        "@com_googlesource_quiche//:quiche_common_platform",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_impl_lib",
+-    srcs = [
+-        "quic_cert_utils_impl.cc",
+-        "quic_file_utils_impl.cc",
+-        "quic_hostname_utils_impl.cc",
+-    ],
+-    hdrs = [
+-        "quic_cert_utils_impl.h",
+-        "quic_file_utils_impl.h",
+-        "quic_hostname_utils_impl.h",
+-        "quic_mutex_impl.h",
+-        "quic_pcc_sender_impl.h",
+-        "quic_string_utils_impl.h",
+-    ],
+-    external_deps = [
+-        "quiche_quic_platform_base",
+-        "abseil_str_format",
+-        "abseil_synchronization",
+-        "abseil_time",
+-        "ssl",
+-    ],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "//source/common/common:assert_lib",
+-        "//source/common/filesystem:directory_lib",
+-        "//source/common/filesystem:filesystem_lib",
+-        "//source/common/http:utility_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_mem_slice_span_impl_lib",
+-    srcs = ["quic_mem_slice_span_impl.cc"],
+-    hdrs = ["quic_mem_slice_span_impl.h"],
+-    copts = select({
+-        "//bazel:windows_x86_64": [],
+-        "//conditions:default": ["-Wno-unused-parameter"],
+-    }),
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "//include/envoy/buffer:buffer_interface",
+-        "//source/common/common:stack_array",
+-        "@com_googlesource_quiche//:quic_core_types_lib",
+-        "@com_googlesource_quiche//:quic_platform_base",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_mem_slice_storage_impl_lib",
+-    srcs = ["quic_mem_slice_storage_impl.cc"],
+-    hdrs = ["quic_mem_slice_storage_impl.h"],
+-    copts = select({
+-        "//bazel:windows_x86_64": [],
+-        "//conditions:default": [
+-            "-Wno-error=invalid-offsetof",
+-            "-Wno-unused-parameter",
+-        ],
+-    }),
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "@com_googlesource_quiche//:quic_core_buffer_allocator_lib",
+-        "@com_googlesource_quiche//:quic_core_utils_lib",
+-        "@com_googlesource_quiche//:quic_platform_mem_slice_span",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quic_platform_bbr2_sender_impl_lib",
+-    hdrs = ["quic_bbr2_sender_impl.h"],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = ["@com_googlesource_quiche//:quic_core_congestion_control_bbr_lib"],
+-)
+-
+-envoy_cc_library(
+-    name = "envoy_quic_clock_lib",
+-    srcs = ["envoy_quic_clock.cc"],
+-    hdrs = ["envoy_quic_clock.h"],
+-    tags = ["nofips"],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        "//include/envoy/event:dispatcher_interface",
+-        "@com_googlesource_quiche//:quic_platform",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "quiche_common_platform_impl_lib",
+-    hdrs = [
+-        "quiche_logging_impl.h",
+-        "quiche_ptr_util_impl.h",
+-        "quiche_unordered_containers_impl.h",
+-    ],
+-    external_deps = [
+-        "abseil_hash",
+-        "abseil_node_hash_map",
+-    ],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        ":quic_platform_logging_impl_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "spdy_platform_impl_lib",
+-    hdrs = [
+-        "spdy_arraysize_impl.h",
+-        "spdy_bug_tracker_impl.h",
+-        "spdy_containers_impl.h",
+-        "spdy_endianness_util_impl.h",
+-        "spdy_estimate_memory_usage_impl.h",
+-        "spdy_export_impl.h",
+-        "spdy_flags_impl.h",
+-        "spdy_logging_impl.h",
+-        "spdy_macros_impl.h",
+-        "spdy_map_util_impl.h",
+-        "spdy_mem_slice_impl.h",
+-        "spdy_ptr_util_impl.h",
+-        "spdy_string_impl.h",
+-        "spdy_string_piece_impl.h",
+-        "spdy_string_utils_impl.h",
+-        "spdy_test_helpers_impl.h",
+-        "spdy_test_utils_prod_impl.h",
+-    ],
+-    external_deps = [
+-        "abseil_base",
+-        "abseil_hash",
+-        "abseil_inlined_vector",
+-        "abseil_memory",
+-        "abseil_str_format",
+-    ],
+-    visibility = ["//visibility:public"],
+-    deps = [
+-        ":flags_impl_lib",
+-        ":quic_platform_logging_impl_lib",
+-        ":string_utils_lib",
+-        "//source/common/common:assert_lib",
+-        "@com_googlesource_quiche//:quiche_common_lib",
+-    ],
+-)
+-
+-envoy_cc_library(
+-    name = "spdy_platform_unsafe_arena_impl_lib",
+-    hdrs = ["spdy_unsafe_arena_impl.h"],
+-    visibility = ["//visibility:public"],
+-    deps = ["@com_googlesource_quiche//:spdy_simple_arena_lib"],
+-)
+diff --git a/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.cc b/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.cc
+deleted file mode 100644
+index 10091a1c99..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.cc
++++ /dev/null
+@@ -1,30 +0,0 @@
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-quic::QuicTime EnvoyQuicClock::ApproximateNow() const {
+-  return quic::QuicTime::Zero() + quic::QuicTime::Delta::FromMicroseconds(microsecondsSinceEpoch(
+-                                      dispatcher_.approximateMonotonicTime()));
+-}
+-
+-quic::QuicTime EnvoyQuicClock::Now() const {
+-  // Since the expensive operation of obtaining time has to be performed anyway,
+-  // make Dispatcher update approximate time. Without this, alarms might fire
+-  // one event loop later. const_cast is necessary here because
+-  // updateApproximateMonotonicTime() is a non-const operation, and Now() is
+-  // conceptually const (even though this particular implementation has a
+-  // visible side effect). Changing Now() to non-const would necessitate
+-  // changing a number of other methods and members to non-const, which would
+-  // not increase clarity.
+-  const_cast<Event::Dispatcher&>(dispatcher_).updateApproximateMonotonicTime();
+-  return ApproximateNow();
+-}
+-
+-quic::QuicWallTime EnvoyQuicClock::WallNow() const {
+-  return quic::QuicWallTime::FromUNIXMicroseconds(
+-      microsecondsSinceEpoch(dispatcher_.timeSource().systemTime()));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.h b/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.h
+deleted file mode 100644
+index 5a85ebf932..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/envoy_quic_clock.h
++++ /dev/null
+@@ -1,30 +0,0 @@
+-#pragma once
+-
+-#include <chrono>
+-
+-#include "envoy/event/dispatcher.h"
+-
+-#include "quiche/quic/platform/api/quic_clock.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicClock : public quic::QuicClock {
+-public:
+-  EnvoyQuicClock(Event::Dispatcher& dispatcher) : dispatcher_(dispatcher) {}
+-
+-  // quic::QuicClock
+-  quic::QuicTime ApproximateNow() const override;
+-  quic::QuicTime Now() const override;
+-  quic::QuicWallTime WallNow() const override;
+-
+-private:
+-  template <typename T> int64_t microsecondsSinceEpoch(std::chrono::time_point<T> time) const {
+-    return std::chrono::duration_cast<std::chrono::microseconds>(time.time_since_epoch()).count();
+-  }
+-
+-  Event::Dispatcher& dispatcher_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/platform/flags_impl.cc b/source/extensions/quic_listeners/quiche/platform/flags_impl.cc
+deleted file mode 100644
+index 70fb182d67..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/flags_impl.cc
++++ /dev/null
+@@ -1,102 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#include <set>
+-
+-#include "absl/strings/ascii.h"
+-#include "absl/strings/numbers.h"
+-
+-namespace quiche {
+-
+-namespace {
+-
+-absl::flat_hash_map<std::string, Flag*> MakeFlagMap() {
+-  absl::flat_hash_map<std::string, Flag*> flags;
+-
+-#define QUICHE_FLAG(type, flag, value, help) flags.emplace(FLAGS_##flag->name(), FLAGS_##flag);
+-#include "extensions/quic_listeners/quiche/platform/flags_list.h"
+-#undef QUICHE_FLAG
+-
+-  return flags;
+-}
+-
+-} // namespace
+-
+-// static
+-FlagRegistry& FlagRegistry::GetInstance() {
+-  static auto* instance = new FlagRegistry();
+-  return *instance;
+-}
+-
+-FlagRegistry::FlagRegistry() : flags_(MakeFlagMap()) {}
+-
+-void FlagRegistry::ResetFlags() const {
+-  for (auto& kv : flags_) {
+-    kv.second->ResetValue();
+-  }
+-}
+-
+-Flag* FlagRegistry::FindFlag(const std::string& name) const {
+-  auto it = flags_.find(name);
+-  return (it != flags_.end()) ? it->second : nullptr;
+-}
+-
+-template <> bool TypedFlag<bool>::SetValueFromString(const std::string& value_str) {
+-  static const auto* kTrueValues = new std::set<std::string>({"1", "t", "true", "y", "yes"});
+-  static const auto* kFalseValues = new std::set<std::string>({"0", "f", "false", "n", "no"});
+-  auto lower = absl::AsciiStrToLower(value_str);
+-  if (kTrueValues->find(lower) != kTrueValues->end()) {
+-    SetValue(true);
+-    return true;
+-  }
+-  if (kFalseValues->find(lower) != kFalseValues->end()) {
+-    SetValue(false);
+-    return true;
+-  }
+-  return false;
+-}
+-
+-template <> bool TypedFlag<int32_t>::SetValueFromString(const std::string& value_str) {
+-  int32_t value;
+-  if (absl::SimpleAtoi(value_str, &value)) {
+-    SetValue(value);
+-    return true;
+-  }
+-  return false;
+-}
+-
+-template <> bool TypedFlag<int64_t>::SetValueFromString(const std::string& value_str) {
+-  int64_t value;
+-  if (absl::SimpleAtoi(value_str, &value)) {
+-    SetValue(value);
+-    return true;
+-  }
+-  return false;
+-}
+-
+-template <> bool TypedFlag<double>::SetValueFromString(const std::string& value_str) {
+-  double value;
+-  if (absl::SimpleAtod(value_str, &value)) {
+-    SetValue(value);
+-    return true;
+-  }
+-  return false;
+-}
+-
+-template <> bool TypedFlag<std::string>::SetValueFromString(const std::string& value_str) {
+-  SetValue(value_str);
+-  return true;
+-}
+-
+-// Flag definitions
+-#define QUICHE_FLAG(type, flag, value, help)                                                       \
+-  TypedFlag<type>* FLAGS_##flag = new TypedFlag<type>(#flag, value, help);
+-#include "extensions/quic_listeners/quiche/platform/flags_list.h"
+-#undef QUICHE_FLAG
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/platform/flags_impl.h b/source/extensions/quic_listeners/quiche/platform/flags_impl.h
+deleted file mode 100644
+index 22aca0ef99..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/flags_impl.h
++++ /dev/null
+@@ -1,110 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-
+-#include "absl/container/flat_hash_map.h"
+-#include "absl/synchronization/mutex.h"
+-
+-namespace quiche {
+-
+-class Flag;
+-
+-// TODO: modify flags implementation to be backed by
+-// Runtime::runtimeFeatureEnabled(), which is the canonical Envoy way of
+-// enabling and disabling features.
+-
+-// Registry of QUICHE flags. Can be used to reset all flags to default values,
+-// and to look up and set flags by name.
+-class FlagRegistry {
+-public:
+-  ~FlagRegistry() = default;
+-
+-  // Return singleton instance.
+-  static FlagRegistry& GetInstance();
+-
+-  // Reset all registered flags to their default values.
+-  void ResetFlags() const;
+-
+-  // Look up a flag by name.
+-  Flag* FindFlag(const std::string& name) const;
+-
+-private:
+-  FlagRegistry();
+-
+-  const absl::flat_hash_map<std::string, Flag*> flags_;
+-};
+-
+-// Abstract class for QUICHE protocol and feature flags.
+-class Flag {
+-public:
+-  // Construct Flag with the given name and help string.
+-  Flag(const char* name, const char* help) : name_(name), help_(help) {}
+-  virtual ~Flag() = default;
+-
+-  // Set flag value from given string, returning true iff successful.
+-  virtual bool SetValueFromString(const std::string& value_str) = 0;
+-
+-  // Reset flag to default value.
+-  virtual void ResetValue() = 0;
+-
+-  // Return flag name.
+-  std::string name() const { return name_; }
+-
+-  // Return flag help string.
+-  std::string help() const { return help_; }
+-
+-private:
+-  std::string name_;
+-  std::string help_;
+-};
+-
+-// Concrete class for QUICHE protocol and feature flags, templated by flag type.
+-template <typename T> class TypedFlag : public Flag {
+-public:
+-  TypedFlag(const char* name, T default_value, const char* help)
+-      : Flag(name, help), value_(default_value), default_value_(default_value) {}
+-
+-  bool SetValueFromString(const std::string& value_str) override;
+-
+-  void ResetValue() override {
+-    absl::MutexLock lock(&mutex_);
+-    value_ = default_value_;
+-  }
+-
+-  // Set flag value.
+-  void SetValue(T value) {
+-    absl::MutexLock lock(&mutex_);
+-    value_ = value;
+-  }
+-
+-  // Return flag value.
+-  T value() const {
+-    absl::MutexLock lock(&mutex_);
+-    return value_;
+-  }
+-
+-private:
+-  mutable absl::Mutex mutex_;
+-  T value_ GUARDED_BY(mutex_);
+-  T default_value_;
+-};
+-
+-// SetValueFromString specializations
+-template <> bool TypedFlag<bool>::SetValueFromString(const std::string& value_str);
+-template <> bool TypedFlag<int32_t>::SetValueFromString(const std::string& value_str);
+-template <> bool TypedFlag<int64_t>::SetValueFromString(const std::string& value_str);
+-template <> bool TypedFlag<double>::SetValueFromString(const std::string& value_str);
+-template <> bool TypedFlag<std::string>::SetValueFromString(const std::string& value_str);
+-
+-// Flag declarations
+-#define QUICHE_FLAG(type, flag, value, help) extern TypedFlag<type>* FLAGS_##flag;
+-#include "extensions/quic_listeners/quiche/platform/flags_list.h"
+-#undef QUICHE_FLAG
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/platform/flags_list.h b/source/extensions/quic_listeners/quiche/platform/flags_list.h
+deleted file mode 100644
+index 11b8f31171..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/flags_list.h
++++ /dev/null
+@@ -1,503 +0,0 @@
+-// This file intentionally does not have header guards, it's intended to be
+-// included multiple times, each time with a different definition of QUICHE_FLAG.
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-// The contents of this file are based off of
+-// //third_party/quic/core:quic_flags_list in google3, with the addition of
+-// test-only flags for testing http2 and spdy flags APIs.
+-// TODO(mpwarres): include generated flags_list.h as part of QUICHE.
+-
+-#if defined(QUICHE_FLAG)
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_advertise_quic_for_https_for_debugips, false, "")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_advertise_quic_for_https_for_external_users, false, "")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_active_streams_never_negative, false,
+-            "If true, static streams should never be closed before QuicSession "
+-            "destruction.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_add_upper_limit_of_buffered_control_frames, false,
+-            "If true, close connection if there are too many (> 1000) buffered "
+-            "control frames.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_aggressive_connection_aliveness, false,
+-            "If true, QuicSession::ShouldKeepConnectionAlive() will not consider "
+-            "locally closed streams whose highest byte offset is not received yet.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_allow_backend_set_stream_ttl, false,
+-            "If true, check backend response header for X-Response-Ttl. If it is "
+-            "provided, the stream TTL is set. A QUIC stream will be immediately "
+-            "canceled when tries to write data if this TTL expired.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_allow_client_enabled_bbr_v2, false,
+-            "If true, allow client to enable BBRv2 on server via connection "
+-            "option 'B2ON'.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_alpn_dispatch, false,
+-            "Support different QUIC sessions, as indicated by ALPN. Used for QBONE.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_avoid_empty_frame_after_empty_headers, true,
+-            "If enabled, do not call OnStreamFrame() with empty frame after "
+-            "receiving empty or too large headers with FIN.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_flexible_app_limited, false,
+-            "When true and the BBR9 connection option is present, BBR only considers "
+-            "bandwidth samples app-limited if they're not filling the pipe.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_less_probe_rtt, false,
+-            "Enables 3 new connection options to make PROBE_RTT more aggressive.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_no_bytes_acked_in_startup_recovery, false,
+-            "When in STARTUP and recovery, do not add bytes_acked to QUIC BBR's "
+-            "CWND in CalculateCongestionWindow()")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_one_mss_conservation, false,
+-            "When true, ensure BBR allows at least one MSS to be sent in "
+-            "response to an ACK in packet conservation.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_slower_startup4, false,
+-            "Enables the BBQ5 connection option, which forces saved aggregation values "
+-            "to expire when the bandwidth increases more than 25% in QUIC BBR STARTUP.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_bbr_startup_rate_reduction, false,
+-            "When true, enables the BBS4 and BBS5 connection options, which reduce "
+-            "BBR's pacing rate in STARTUP as more losses occur as a fraction of CWND.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_change_default_lumpy_pacing_size_to_two, false,
+-            "If true and --quic_lumpy_pacing_size is 1, QUIC will use a lumpy "
+-            "size of two for pacing.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_clear_queued_packets_on_connection_close, false,
+-            "Calls ClearQueuedPackets after sending a connection close packet")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_conservative_bursts, false,
+-            "If true, set burst token to 2 in cwnd bootstrapping experiment.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_conservative_cwnd_and_pacing_gains, false,
+-            "If true, uses conservative cwnd gain and pacing gain when cwnd gets "
+-            "bootstrapped.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_debug_wrong_qos, false,
+-            "If true, consider getting QoS after stream has been detached as GFE bug.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_default_to_bbr, true,
+-            "When true, defaults to BBR congestion control instead of Cubic.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_default_to_bbr_v2, false,
+-            "If true, use BBRv2 as the default congestion controller. Takes "
+-            "precedence over --quic_default_to_bbr.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_disable_connection_migration_for_udp_proxying, true,
+-            "If true, GFE disables connection migration in connection option for "
+-            "proxied sessions.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_disable_version_39, false,
+-            "If true, disable QUIC version 39.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_disable_version_44, true,
+-            "If true, disable QUIC version 44.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_do_not_accept_stop_waiting, false,
+-            "In v44 and above, where STOP_WAITING is never sent, close the "
+-            "connection if it's received.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_donot_reset_ideal_next_packet_send_time, false,
+-            "If true, stop resetting ideal_next_packet_send_time_ in pacing sender.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_drop_invalid_small_initial_connection_id, true,
+-            "When true, QuicDispatcher will drop packets that have an initial "
+-            "destination connection ID that is too short, instead of responding "
+-            "with a Version Negotiation packet to reject it.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_eighth_rtt_loss_detection, false,
+-            "When true, the LOSS connection option allows for 1/8 RTT of "
+-            "reording instead of the current 1/8th threshold which has been "
+-            "found to be too large for fast loss recovery.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_ack_decimation, false,
+-            "Default enables QUIC ack decimation and adds a connection option to "
+-            "disable it.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_fifo_write_scheduler, false,
+-            "If true and FIFO connection option is received, write_blocked_streams "
+-            "uses FIFO(stream with smallest ID has highest priority) write scheduler.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_lifo_write_scheduler, false,
+-            "If true and LIFO connection option is received, write_blocked_streams "
+-            "uses LIFO(stream with largest ID has highest priority) write scheduler.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_pcc3, false,
+-            "If true, enable experiment for testing PCC congestion-control.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_version_47, false,
+-            "If true, enable QUIC version 47 which adds support for variable "
+-            "length connection IDs.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_version_48, false,
+-            "If true, enable QUIC version 48.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enable_version_99, false, "If true, enable version 99.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_enabled, false, "")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_fix_adaptive_time_loss, false,
+-            "Simplify QUICHE's adaptive time loss detection to measure the "
+-            "necessary reordering window for every spurious retransmit.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_fix_bbr_cwnd_in_bandwidth_resumption, true,
+-            "If true, adjust congestion window when doing bandwidth resumption in BBR.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_fix_get_packet_header_size, false,
+-            "Fixes quic::GetPacketHeaderSize and callsites when "
+-            "QuicVersionHasLongHeaderLengths is false.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_fix_packets_acked, true,
+-            "If true, when detecting losses, use packets_acked of corresponding "
+-            "packet number space.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_fix_rto_retransmission2, false,
+-            "If true, when RTO fires and there is no packet to be RTOed, let "
+-            "connection send.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_handle_staticness_for_spdy_stream, false,
+-            "If true, QuicSpdySession::GetSpdyDataStream() will close the "
+-            "connection if the returned stream is static.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_ignore_tlpr_if_no_pending_stream_data, false,
+-            "If true, ignore TLPR if there is no pending stream data")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_inline_getorcreatedynamicstream, false,
+-            "If true, QuicSession::GetOrCreateDynamicStream() is deprecated, and "
+-            "its contents are moved to GetOrCreateStream().")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_listener_never_fake_epollout, false,
+-            "If true, QuicListener::OnSocketIsWritable will always return false, "
+-            "which means there will never be a fake EPOLLOUT event in the next "
+-            "epoll iteration.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_log_cert_name_for_empty_sct, true,
+-            "If true, log leaf cert subject name into warning log.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_loss_removes_from_inflight, true,
+-            "When true, remove packets from inflight where they're declared "
+-            "lost, rather than in MarkForRetransmission. Also no longer marks "
+-            "handshake packets as no longer inflight when they're retransmitted.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_monotonic_epoll_clock, false,
+-            "If true, QuicEpollClock::Now() will monotonically increase.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_negotiate_ack_delay_time, false,
+-            "If true, will negotiate the ACK delay time.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_no_cloud_domain_sni_lookup_on_missing_sni, false,
+-            "Do not attempt to match an empty Server Name Indication (SNI) "
+-            "against names extracted from Cloud customer certificates.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_no_dup_experiment_id_2, false,
+-            "If true, transport connection stats doesn't report duplicated "
+-            "experiments for same connection.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_no_stream_data_after_reset, false,
+-            "If true, QuicStreamSequencer will not take in new data if the stream is reset.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_no_v2_scaling_factor, false,
+-            "When true, don't use an extra scaling factor when reading packets "
+-            "from QUICHE's RX_RING with TPACKET_V2.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_no_window_update_on_read_only_stream, false,
+-            "If true, QuicConnection will be closed if a WindowUpdate frame is "
+-            "received on a READ_UNIDIRECTIONAL stream.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_proxy_check_toss_on_insertion_failure, false,
+-            "If true, enable the code that fixes a race condition for quic udp "
+-            "proxying in L0. See b/70036019.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_proxy_read_packed_strings, true,
+-            "If true, QuicProxyDispatcher will prefer to extract client_address "
+-            "and server_vip from packed_client_address and packed_server_vip, "
+-            "respectively.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_proxy_supports_length_prefix, false,
+-            "When true, QuicProxyUtils::GetConnectionId supports length prefixed "
+-            "connection IDs.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_proxy_write_packed_strings, false,
+-            "If true, QuicProxyDispatcher will write packed_client_address and "
+-            "packed_server_vip in TcpProxyHeaderProto.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_length_prefix_from_packet_info, false,
+-            "When true, QuicDispatcher::MaybeDispatchPacket will use packet_info.use_length_prefix "
+-            "instead of an incorrect local computation.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_record_frontend_service_vip_mapping, false,
+-            "If true, for L1 GFE, as requests come in, record frontend service to VIP "
+-            "mapping which is used to announce VIP in SHLO for proxied sessions. ")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_reject_all_traffic, false, "")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_reject_unprocessable_packets_statelessly, false,
+-            "If true, do not add connection ID of packets with unknown connection ID "
+-            "and no version to time wait list, instead, send appropriate responses "
+-            "depending on the packets' sizes and drop them.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_require_handshake_confirmation, false,
+-            "If true, require handshake confirmation for QUIC connections, "
+-            "functionally disabling 0-rtt handshakes.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_send_timestamps, false,
+-            "When the STMP connection option is sent by the client, timestamps "
+-            "in the QUIC ACK frame are sent and processed.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_sent_packet_manager_cleanup, false,
+-            "When true, remove obsolete functionality intended to test IETF QUIC "
+-            "recovery.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_server_push, true,
+-            "If true, enable server push feature on QUICHE.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_simplify_stop_waiting, true,
+-            "If true, do not send STOP_WAITING if no_stop_waiting_frame_.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_stop_reading_when_level_triggered, false,
+-            "When true, calling StopReading() on a level-triggered QUIC stream "
+-            "sequencer will cause the sequencer to discard future data.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_testonly_default_false, false,
+-            "A testonly reloadable flag that will always default to false.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_testonly_default_true, true,
+-            "A testonly reloadable flag that will always default to true.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_tracegraf_populate_ack_packet_number, false,
+-            "If true, populate packet_number of received ACK in tracegraf.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_track_ack_height_in_bandwidth_sampler, false,
+-            "If true, QUIC will track max ack height in BandwidthSampler.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_unified_iw_options, false,
+-            "When true, set the initial congestion control window from connection "
+-            "options in QuicSentPacketManager rather than TcpCubicSenderBytes.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_common_stream_check, false,
+-            "If true, use common code for checking whether a new stream ID may "
+-            "be allocated.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_connection_clock_for_last_ack_time, false,
+-            "If true, QuicFasterStatsGatherer will use a GFEConnectionClock to "
+-            "get the time when the last ack is received.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_header_stage_idle_list2, false,
+-            "If true, use header stage idle list for QUIC connections in GFE.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_http2_priority_write_scheduler, false,
+-            "If true and H2PR connection option is received, write_blocked_streams_ "
+-            "uses HTTP2 (tree-style) priority write scheduler.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_leto_key_exchange, false,
+-            "If true, QUIC will attempt to use the Leto key exchange service and "
+-            "only fall back to local key exchange if that fails.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_parse_public_header, false,
+-            "When true, QuicDispatcher will always use QuicFramer::ParsePublicHeader")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_pigeon_sockets, false,
+-            "Use USPS Direct Path for QUIC egress.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_use_quic_time_for_received_timestamp, false,
+-            "If true, use QuicClock::Now() for the fallback source of packet "
+-            "received time instead of WallNow().")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_quic_version_negotiation_grease, false,
+-            "When true, QUIC Version Negotiation packets will randomly include "
+-            "fake versions.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_send_quic_fallback_server_config_on_leto_error, false,
+-            "If true and using Leto for QUIC shared-key calculations, GFE will react "
+-            "to a failure to contact Leto by sending a REJ containing a fallback "
+-            "ServerConfig, allowing the client to continue the handshake.")
+-
+-QUICHE_FLAG(bool, quic_reloadable_flag_simplify_spdy_quic_https_scheme_detection, false,
+-            "If true, simplify the logic for detecting REQUEST_HAS_HTTPS_SCHEME in "
+-            "NetSpdyRequester::SetRequestUrlAndHost and "
+-            "NetQuicRequester::SetRequestUrlAndHost. Fixes a bug where internal "
+-            "redirects for QUIC connections would be treated as having an http scheme.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_do_not_create_raw_socket_selector_if_quic_enabled, false,
+-            "If true, do not create the RawSocketSelector in "
+-            "QuicListener::Initialize() if QUIC is disabled by flag.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_dont_fetch_quic_private_keys_from_leto, false,
+-            "If true, GFE will not request private keys when fetching QUIC "
+-            "ServerConfigs from Leto.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_allow_loas_multipacket_chlo, false,
+-            "If true, inspects QUIC CHLOs for kLOAS and early creates sessions "
+-            "to allow multi-packet CHLOs")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_connection_id_use_siphash, false,
+-            "When true, QuicConnectionId::Hash uses SipHash instead of XOR.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_dispatcher_hands_chlo_extractor_one_version, false,
+-            "When true, QuicDispatcher will pass the version from the packet to "
+-            "the ChloExtractor instead of all supported versions.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_enable_gso_for_udp_egress, false,
+-            "If 1) flag is true, 2) UDP egress_method is used in GFE config, and "
+-            "3) UDP GSO is supported by the kernel, GFE will use UDP GSO for "
+-            "egress, except for UDP proxy.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_enable_sendmmsg_for_udp_egress, false,
+-            "If 1) flag is true, 2) UDP egress_method is used in GFE config, and "
+-            "3) --gfe2_restart_flag_quic_enable_gso_for_udp_egress is false OR "
+-            "gso is not supported by kernel, GFE will use sendmmsg for egress, "
+-            "except for UDP proxy.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_no_fallback_for_pigeon_socket, false,
+-            "If true, GFEs using USPS egress will not fallback to raw ip socket.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_offload_pacing_to_usps2, false,
+-            "If true, QUIC offload pacing when using USPS as egress method.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_pigeon_use_memfd_packet_memory, false,
+-            "If true, GFE QUIC will forcefully use memfd to create packet memory "
+-            "for pigeon socket. Otherwise memfd is used if "
+-            "--pigeon_sealable_files_enabled is true.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_rx_ring_use_tpacket_v3, false,
+-            "If true, use TPACKET_V3 for QuicRxRing instead of TPACKET_V2.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_server_handle_egress_epoll_err, false,
+-            "If true, handle EPOLLERRs from QUIC server egress sockets.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_testonly_default_false, false,
+-            "A testonly restart flag that will always default to false.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_testonly_default_true, true,
+-            "A testonly restart flag that will always default to true.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_use_allocated_connection_ids, true,
+-            "When true, QuicConnectionId will allocate long connection IDs on "
+-            "the heap instead of inline in the object.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_use_leto_for_quic_configs, false,
+-            "If true, use Leto to fetch QUIC server configs instead of using the "
+-            "seeds from Memento.")
+-
+-QUICHE_FLAG(bool, quic_restart_flag_quic_use_pigeon_socket_to_backend, false,
+-            "If true, create a shared pigeon socket for all quic to backend "
+-            "connections and switch to use it after successful handshake.")
+-
+-QUICHE_FLAG(bool, quic_allow_chlo_buffering, true,
+-            "If true, allows packets to be buffered in anticipation of a "
+-            "future CHLO, and allow CHLO packets to be buffered until next "
+-            "iteration of the event loop.")
+-
+-QUICHE_FLAG(bool, quic_disable_pacing_for_perf_tests, false, "If true, disable pacing in QUICHE")
+-
+-QUICHE_FLAG(bool, quic_enforce_single_packet_chlo, true,
+-            "If true, enforce that QUIC CHLOs fit in one packet")
+-
+-// Currently, this number is quite conservative. At a hypothetical 1000 qps,
+-// this means that the longest time-wait list we should see is:
+-//   200 seconds * 1000 qps = 200000.
+-// Of course, there are usually many queries per QUIC connection, so we allow a
+-// factor of 3 leeway.
+-QUICHE_FLAG(int64_t, // allow-non-std-int
+-            quic_time_wait_list_max_connections, 600000,
+-            "Maximum number of connections on the time-wait list. "
+-            "A negative value implies no configured limit.")
+-
+-QUICHE_FLAG(int64_t, // allow-non-std-int
+-            quic_time_wait_list_seconds, 200,
+-            "Time period for which a given connection_id should live in "
+-            "the time-wait state.")
+-
+-QUICHE_FLAG(double, quic_bbr_cwnd_gain, 2.0f,
+-            "Congestion window gain for QUIC BBR during PROBE_BW phase.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_buffered_data_threshold, 8 * 1024,
+-            "If buffered data in QUIC stream is less than this "
+-            "threshold, buffers all provided data or asks upper layer for more data")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_send_buffer_max_data_slice_size, 4 * 1024,
+-            "Max size of data slice in bytes for QUIC stream send buffer.")
+-
+-QUICHE_FLAG(bool, quic_supports_tls_handshake, false,
+-            "If true, QUIC supports both QUIC Crypto and TLS 1.3 for the "
+-            "handshake protocol")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_lumpy_pacing_size, 1,
+-            "Number of packets that the pacing sender allows in bursts during pacing.")
+-
+-QUICHE_FLAG(double, quic_lumpy_pacing_cwnd_fraction, 0.25f,
+-            "Congestion window fraction that the pacing sender allows in bursts "
+-            "during pacing.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_max_pace_time_into_future_ms, 10,
+-            "Max time that QUIC can pace packets into the future in ms.")
+-
+-QUICHE_FLAG(double, quic_pace_time_into_future_srtt_fraction,
+-            0.125f, // One-eighth smoothed RTT
+-            "Smoothed RTT fraction that a connection can pace packets into the future.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_ietf_draft_version, 0,
+-            "Mechanism to override version label and ALPN for IETF interop.")
+-
+-QUICHE_FLAG(bool, quic_export_server_num_packets_per_write_histogram, false,
+-            "If true, export number of packets written per write operation histogram.")
+-
+-QUICHE_FLAG(bool, quic_disable_version_negotiation_grease_randomness, false,
+-            "If true, use predictable version negotiation versions.")
+-
+-QUICHE_FLAG(int64_t, // allow-non-std-int
+-            quic_max_tracked_packet_count, 10000, "Maximum number of tracked packets.")
+-
+-QUICHE_FLAG(bool, quic_prober_uses_length_prefixed_connection_ids, false,
+-            "If true, QuicFramer::WriteClientVersionNegotiationProbePacket uses "
+-            "length-prefixed connection IDs.")
+-
+-QUICHE_FLAG(bool, quic_client_convert_http_header_name_to_lowercase, true,
+-            "If true, HTTP request header names sent from QuicSpdyClientBase(and "
+-            "descendents) will be automatically converted to lower case.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_bbr2_default_probe_bw_base_duration_ms, 2000,
+-            "The default minimum duration for BBRv2-native probes, in milliseconds.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_bbr2_default_probe_bw_max_rand_duration_ms, 1000,
+-            "The default upper bound of the random amount of BBRv2-native "
+-            "probes, in milliseconds.")
+-
+-QUICHE_FLAG(int32_t, // allow-non-std-int
+-            quic_bbr2_default_probe_rtt_period_ms, 10000,
+-            "The default period for entering PROBE_RTT, in milliseconds.")
+-
+-QUICHE_FLAG(double, quic_bbr2_default_loss_threshold, 0.02,
+-            "The default loss threshold for QUIC BBRv2, should be a value "
+-            "between 0 and 1.")
+-
+-QUICHE_FLAG(bool, http2_reloadable_flag_http2_testonly_default_false, false,
+-            "A testonly reloadable flag that will always default to false.")
+-
+-QUICHE_FLAG(bool, http2_restart_flag_http2_testonly_default_false, false,
+-            "A testonly restart flag that will always default to false.")
+-
+-QUICHE_FLAG(bool, spdy_reloadable_flag_spdy_testonly_default_false, false,
+-            "A testonly reloadable flag that will always default to false.")
+-
+-QUICHE_FLAG(bool, spdy_restart_flag_spdy_testonly_default_false, false,
+-            "A testonly restart flag that will always default to false.")
+-
+-#endif
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_arraysize_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_arraysize_impl.h
+deleted file mode 100644
+index edeaf02f10..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_arraysize_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-#include "absl/base/macros.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define HTTP2_ARRAYSIZE_IMPL(x) ABSL_ARRAYSIZE(x)
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_bug_tracker_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_bug_tracker_impl.h
+deleted file mode 100644
+index 58c7039d53..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_bug_tracker_impl.h
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h"
+-
+-#define HTTP2_BUG_IMPL QUIC_BUG_IMPL
+-#define HTTP2_BUG_IF_IMPL QUIC_BUG_IF_IMPL
+-#define FLAGS_http2_always_log_bugs_for_tests_IMPL true
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_containers_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_containers_impl.h
+deleted file mode 100644
+index e43ec40bfc..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_containers_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include <deque>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-template <typename T> using Http2DequeImpl = std::deque<T>;
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_estimate_memory_usage_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_estimate_memory_usage_impl.h
+deleted file mode 100644
+index 7f7617f53b..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_estimate_memory_usage_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include <cstddef>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-template <class T> size_t Http2EstimateMemoryUsageImpl(const T& /*object*/) { return 0; }
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_export_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_export_impl.h
+deleted file mode 100644
+index 802f6fb591..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_export_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define HTTP2_EXPORT
+-#define HTTP2_EXPORT_PRIVATE
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_flag_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_flag_utils_impl.h
+deleted file mode 100644
+index 550b919514..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_flag_utils_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define HTTP2_RELOADABLE_FLAG_COUNT_IMPL(flag)                                                     \
+-  do {                                                                                             \
+-  } while (0)
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_flags_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_flags_impl.h
+deleted file mode 100644
+index f1b53f4067..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_flags_impl.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#define GetHttp2ReloadableFlagImpl(flag) quiche::FLAGS_http2_reloadable_flag_##flag->value()
+-
+-#define SetHttp2ReloadableFlagImpl(flag, value)                                                    \
+-  quiche::FLAGS_http2_reloadable_flag_##flag->SetValue(value)
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_logging_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_logging_impl.h
+deleted file mode 100644
+index 473c2d00d4..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_logging_impl.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-#define HTTP2_LOG_IMPL(severity) QUIC_LOG_IMPL(severity)
+-
+-#define HTTP2_VLOG_IMPL(verbose_level) QUIC_VLOG_IMPL(verbose_level)
+-
+-#define HTTP2_DLOG_IMPL(severity) QUIC_DLOG_IMPL(severity)
+-
+-#define HTTP2_DLOG_IF_IMPL(severity, condition) QUIC_DLOG_IF_IMPL(severity, condition)
+-
+-#define HTTP2_DVLOG_IMPL(verbose_level) QUIC_DVLOG_IMPL(verbose_level)
+-
+-#define HTTP2_DVLOG_IF_IMPL(verbose_level, condition) QUIC_DVLOG_IF_IMPL(verbose_level, condition)
+-
+-#define HTTP2_DLOG_EVERY_N_IMPL(severity, n) QUIC_DLOG_EVERY_N_IMPL(severity, n)
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_macros_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_macros_impl.h
+deleted file mode 100644
+index 4f99f2d2f4..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_macros_impl.h
++++ /dev/null
+@@ -1,26 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <utility>
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-#include "absl/base/macros.h"
+-
+-#define HTTP2_FALLTHROUGH_IMPL ABSL_FALLTHROUGH_INTENDED
+-#define HTTP2_DIE_IF_NULL_IMPL(ptr) dieIfNull(ptr)
+-#define HTTP2_UNREACHABLE_IMPL() DCHECK(false)
+-
+-namespace http2 {
+-
+-template <typename T> inline T dieIfNull(T&& ptr) {
+-  CHECK((ptr) != nullptr);
+-  return std::forward<T>(ptr);
+-}
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_optional_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_optional_impl.h
+deleted file mode 100644
+index 5f1cd8b30b..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_optional_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include "absl/types/optional.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-template <typename T> using Http2OptionalImpl = absl::optional<T>;
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_ptr_util_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_ptr_util_impl.h
+deleted file mode 100644
+index 7ef0bd5828..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_ptr_util_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-#include <utility>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-template <typename T, typename... Args> std::unique_ptr<T> Http2MakeUniqueImpl(Args&&... args) {
+-  return std::make_unique<T>(std::forward<Args>(args)...);
+-}
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_string_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_string_impl.h
+deleted file mode 100644
+index fc54f8938f..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_string_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-using Http2StringImpl = std::string;
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_string_piece_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_string_piece_impl.h
+deleted file mode 100644
+index 711372c021..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_string_piece_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/string_view.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace http2 {
+-
+-using Http2StringPieceImpl = absl::string_view;
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/http2_string_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/http2_string_utils_impl.h
+deleted file mode 100644
+index d4df004f4c..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/http2_string_utils_impl.h
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/string_utils.h"
+-
+-#include "absl/strings/escaping.h"
+-#include "absl/strings/str_cat.h"
+-#include "absl/strings/str_format.h"
+-#include "fmt/printf.h"
+-
+-namespace http2 {
+-
+-template <typename... Args> inline std::string Http2StrCatImpl(const Args&... args) {
+-  return absl::StrCat(std::forward<const Args&>(args)...);
+-}
+-
+-template <typename... Args>
+-inline void Http2StrAppendImpl(std::string* output, const Args&... args) {
+-  absl::StrAppend(output, std::forward<const Args&>(args)...);
+-}
+-
+-template <typename... Args> inline std::string Http2StringPrintfImpl(const Args&... args) {
+-  return fmt::sprintf(std::forward<const Args&>(args)...);
+-}
+-
+-inline std::string Http2HexEncodeImpl(const void* bytes, size_t size) {
+-  return absl::BytesToHexString(absl::string_view(static_cast<const char*>(bytes), size));
+-}
+-
+-inline std::string Http2HexDecodeImpl(absl::string_view data) {
+-  return absl::HexStringToBytes(data);
+-}
+-
+-inline std::string Http2HexDumpImpl(absl::string_view data) { return quiche::HexDump(data); }
+-
+-inline std::string Http2HexEscapeImpl(absl::string_view data) { return absl::CHexEscape(data); }
+-
+-template <typename Number> inline std::string Http2HexImpl(Number number) {
+-  return absl::StrCat(absl::Hex(number));
+-}
+-
+-} // namespace http2
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_aligned_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_aligned_impl.h
+deleted file mode 100644
+index 73659ace0e..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_aligned_impl.h
++++ /dev/null
+@@ -1,14 +0,0 @@
+-#pragma once
+-
+-#include "absl/base/optimization.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define QUIC_ALIGN_OF_IMPL alignof
+-#define QUIC_ALIGNED_IMPL(X) __attribute__((aligned(X)))
+-#define QUIC_CACHELINE_ALIGNED_IMPL ABSL_CACHELINE_ALIGNED
+-#define QUIC_CACHELINE_SIZE_IMPL ABSL_CACHELINE_SIZE
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_arraysize_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_arraysize_impl.h
+deleted file mode 100644
+index 7ed9e03411..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_arraysize_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-#include "absl/base/macros.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define QUIC_ARRAYSIZE_IMPL(array) ABSL_ARRAYSIZE(array)
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_bbr2_sender_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_bbr2_sender_impl.h
+deleted file mode 100644
+index 8995e1a443..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_bbr2_sender_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/quic/core/congestion_control/bbr_sender.h"
+-
+-namespace quic {
+-
+-using QuicBbr2SenderImpl = BbrSender;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h
+deleted file mode 100644
+index 050bd385d8..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-// TODO(wub): Implement exponential back off to avoid performance problems due
+-// to excessive QUIC_BUG.
+-#define QUIC_BUG_IMPL QUIC_LOG_IMPL(DFATAL)
+-#define QUIC_BUG_IF_IMPL(condition) QUIC_LOG_IF_IMPL(DFATAL, condition)
+-#define QUIC_PEER_BUG_IMPL QUIC_LOG_IMPL(ERROR)
+-#define QUIC_PEER_BUG_IF_IMPL(condition) QUIC_LOG_IF_IMPL(ERROR, condition)
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.cc
+deleted file mode 100644
+index c9b347d57d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.cc
++++ /dev/null
+@@ -1,68 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.h"
+-
+-#include "openssl/bytestring.h"
+-
+-namespace quic {
+-
+-// static
+-bool QuicCertUtilsImpl::ExtractSubjectNameFromDERCert(QuicStringPiece cert,
+-                                                      QuicStringPiece* subject_out) {
+-  CBS tbs_certificate;
+-  if (!SeekToSubject(cert, &tbs_certificate)) {
+-    return false;
+-  }
+-
+-  CBS subject;
+-  if (!CBS_get_asn1_element(&tbs_certificate, &subject, CBS_ASN1_SEQUENCE)) {
+-    return false;
+-  }
+-  *subject_out =
+-      absl::string_view(reinterpret_cast<const char*>(CBS_data(&subject)), CBS_len(&subject));
+-  return true;
+-}
+-
+-// static
+-bool QuicCertUtilsImpl::SeekToSubject(QuicStringPiece cert, CBS* tbs_certificate) {
+-  CBS der;
+-  CBS_init(&der, reinterpret_cast<const uint8_t*>(cert.data()), cert.size());
+-  CBS certificate;
+-  // From RFC 5280, section 4.1
+-  //    Certificate  ::=  SEQUENCE  {
+-  //      tbsCertificate       TBSCertificate,
+-  //      signatureAlgorithm   AlgorithmIdentifier,
+-  //      signatureValue       BIT STRING  }
+-
+-  // TBSCertificate  ::=  SEQUENCE  {
+-  //      version         [0]  EXPLICIT Version DEFAULT v1,
+-  //      serialNumber         CertificateSerialNumber,
+-  //      signature            AlgorithmIdentifier,
+-  //      issuer               Name,
+-  //      validity             Validity,
+-  //      subject              Name,
+-  //      subjectPublicKeyInfo SubjectPublicKeyInfo,
+-  if (!CBS_get_asn1(&der, &certificate, CBS_ASN1_SEQUENCE) ||
+-      CBS_len(&der) != 0 || // We don't allow junk after the certificate.
+-      !CBS_get_asn1(&certificate, tbs_certificate, CBS_ASN1_SEQUENCE) ||
+-      // version.
+-      !CBS_get_optional_asn1(tbs_certificate, nullptr, nullptr,
+-                             CBS_ASN1_CONSTRUCTED | CBS_ASN1_CONTEXT_SPECIFIC | 0) ||
+-      // Serial number.
+-      !CBS_get_asn1(tbs_certificate, nullptr, CBS_ASN1_INTEGER) ||
+-      // Signature.
+-      !CBS_get_asn1(tbs_certificate, nullptr, CBS_ASN1_SEQUENCE) ||
+-      // Issuer.
+-      !CBS_get_asn1(tbs_certificate, nullptr, CBS_ASN1_SEQUENCE) ||
+-      // Validity.
+-      !CBS_get_asn1(tbs_certificate, nullptr, CBS_ASN1_SEQUENCE)) {
+-    return false;
+-  }
+-  return true;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.h
+deleted file mode 100644
+index fea2a75ad7..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_cert_utils_impl.h
++++ /dev/null
+@@ -1,22 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "openssl/base.h"
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace quic {
+-
+-class QuicCertUtilsImpl {
+-public:
+-  static bool ExtractSubjectNameFromDERCert(QuicStringPiece cert, QuicStringPiece* subject_out);
+-
+-private:
+-  static bool SeekToSubject(QuicStringPiece cert, CBS* tbs_certificate);
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_client_stats_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_client_stats_impl.h
+deleted file mode 100644
+index af9850d0bd..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_client_stats_impl.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-
+-// NOTE(wub): These macros are currently NOOP because they are supposed to be
+-// used by client-side stats. They should be implemented when QUIC client code
+-// is used by Envoy to connect to backends.
+-
+-#define QUIC_CLIENT_HISTOGRAM_ENUM_IMPL(name, sample, enum_size, docstring)                        \
+-  do {                                                                                             \
+-    (void)(sample);                                                                                \
+-  } while (0)
+-#define QUIC_CLIENT_HISTOGRAM_BOOL_IMPL(name, sample, docstring)                                   \
+-  (void)(sample);                                                                                  \
+-  do {                                                                                             \
+-  } while (0)
+-#define QUIC_CLIENT_HISTOGRAM_TIMES_IMPL(name, sample, min, max, num_buckets, docstring)           \
+-  do {                                                                                             \
+-    (void)(sample);                                                                                \
+-  } while (0)
+-#define QUIC_CLIENT_HISTOGRAM_COUNTS_IMPL(name, sample, min, max, num_buckets, docstring)          \
+-  do {                                                                                             \
+-    (void)(sample);                                                                                \
+-  } while (0)
+-
+-namespace quic {
+-
+-inline void QuicClientSparseHistogramImpl(const std::string& /*name*/, int /*sample*/) {}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_containers_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_containers_impl.h
+deleted file mode 100644
+index e2638f8e21..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_containers_impl.h
++++ /dev/null
+@@ -1,41 +0,0 @@
+-#pragma once
+-
+-#include <deque>
+-#include <memory>
+-#include <queue>
+-
+-#include "absl/container/flat_hash_map.h"
+-#include "absl/container/inlined_vector.h"
+-#include "absl/container/node_hash_map.h"
+-#include "absl/container/node_hash_set.h"
+-#include "quiche/common/simple_linked_hash_map.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-template <typename Key> using QuicDefaultHasherImpl = absl::Hash<Key>;
+-
+-template <typename Key, typename Value, typename Hash>
+-using QuicUnorderedMapImpl = absl::node_hash_map<Key, Value, Hash>;
+-
+-template <typename Key, typename Hash> using QuicUnorderedSetImpl = absl::node_hash_set<Key, Hash>;
+-
+-template <typename Key, typename Value, typename Hash>
+-using QuicLinkedHashMapImpl = quiche::SimpleLinkedHashMap<Key, Value, Hash>;
+-
+-template <typename Key, typename Value, int Size>
+-using QuicSmallMapImpl = absl::flat_hash_map<Key, Value>;
+-
+-template <typename T> using QuicQueueImpl = std::queue<T>;
+-
+-template <typename T> using QuicDequeImpl = std::deque<T>;
+-
+-template <typename T, size_t N, typename A = std::allocator<T>>
+-using QuicInlinedVectorImpl = absl::InlinedVector<T, N, A>;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_endian_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_endian_impl.h
+deleted file mode 100644
+index c456da321f..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_endian_impl.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <cstdint>
+-
+-#include "common/common/byte_order.h"
+-
+-namespace quic {
+-
+-class QuicEndianImpl {
+-public:
+-  static uint16_t HostToNet16(uint16_t x) { return toEndianness<ByteOrder::BigEndian>(x); }
+-  static uint32_t HostToNet32(uint32_t x) { return toEndianness<ByteOrder::BigEndian>(x); }
+-  static uint64_t HostToNet64(uint64_t x) { return toEndianness<ByteOrder::BigEndian>(x); }
+-
+-  static uint16_t NetToHost16(uint16_t x) { return fromEndianness<ByteOrder::BigEndian>(x); }
+-  static uint32_t NetToHost32(uint32_t x) { return fromEndianness<ByteOrder::BigEndian>(x); }
+-  static uint64_t NetToHost64(uint64_t x) { return fromEndianness<ByteOrder::BigEndian>(x); }
+-
+-  static bool HostIsLittleEndian() { return NetToHost16(0x1234) != 0x1234; }
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_error_code_wrappers_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_error_code_wrappers_impl.h
+deleted file mode 100644
+index a593581253..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_error_code_wrappers_impl.h
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <memory>
+-
+-#include "envoy/api/io_error.h"
+-
+-#define QUIC_EMSGSIZE_IMPL static_cast<int>(Envoy::Api::IoError::IoErrorCode::MessageTooBig)
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_estimate_memory_usage_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_estimate_memory_usage_impl.h
+deleted file mode 100644
+index e65815ee38..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_estimate_memory_usage_impl.h
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#pragma once
+-
+-#include <cstddef>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-// Dummy implementation.
+-template <class T> size_t QuicEstimateMemoryUsageImpl(const T& /*object*/) { return 0; }
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_export_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_export_impl.h
+deleted file mode 100644
+index e3da61c839..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_export_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define QUIC_EXPORT
+-#define QUIC_EXPORT_PRIVATE
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_fallthrough_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_fallthrough_impl.h
+deleted file mode 100644
+index aa9d6bc36a..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_fallthrough_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/base/macros.h"
+-
+-#define QUIC_FALLTHROUGH_INTENDED_IMPL ABSL_FALLTHROUGH_INTENDED
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.cc
+deleted file mode 100644
+index 00aaeef016..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.cc
++++ /dev/null
+@@ -1,55 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_file_utils_impl.h"
+-
+-#include "common/filesystem/directory.h"
+-#include "common/filesystem/filesystem_impl.h"
+-
+-#include "absl/strings/str_cat.h"
+-
+-namespace quic {
+-namespace {
+-
+-void depthFirstTraverseDirectory(const std::string& dirname, std::vector<std::string>& files) {
+-  Envoy::Filesystem::Directory directory(dirname);
+-  for (const Envoy::Filesystem::DirectoryEntry& entry : directory) {
+-    switch (entry.type_) {
+-    case Envoy::Filesystem::FileType::Regular:
+-      files.push_back(absl::StrCat(dirname, "/", entry.name_));
+-      break;
+-    case Envoy::Filesystem::FileType::Directory:
+-      if (entry.name_ != "." && entry.name_ != "..") {
+-        depthFirstTraverseDirectory(absl::StrCat(dirname, "/", entry.name_), files);
+-      }
+-      break;
+-    default:
+-      ASSERT(false,
+-             absl::StrCat("Unknow file entry type ", entry.type_, " under directory ", dirname));
+-    }
+-  }
+-}
+-
+-} // namespace
+-
+-// Traverses the directory |dirname| and returns all of the files it contains.
+-std::vector<std::string> ReadFileContentsImpl(const std::string& dirname) {
+-  std::vector<std::string> files;
+-  depthFirstTraverseDirectory(dirname, files);
+-  return files;
+-}
+-
+-// Reads the contents of |filename| as a string into |contents|.
+-void ReadFileContentsImpl(QuicStringPiece filename, std::string* contents) {
+-#ifdef WIN32
+-  Envoy::Filesystem::InstanceImplWin32 fs;
+-#else
+-  Envoy::Filesystem::InstanceImplPosix fs;
+-#endif
+-  *contents = fs.fileReadToEnd(std::string(filename.data(), filename.size()));
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.h
+deleted file mode 100644
+index ceef1dabba..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_file_utils_impl.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <vector>
+-
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace quic {
+-
+-/**
+- * Traverses the directory |dirname| and returns all of the files it contains.
+- * @param dirname full path without trailing '/'.
+- */
+-std::vector<std::string> ReadFileContentsImpl(const std::string& dirname);
+-
+-/**
+- * Reads the contents of |filename| as a string into |contents|.
+- *  @param filename the full path to the file.
+- *  @param contents output location of the file content.
+- */
+-void ReadFileContentsImpl(QuicStringPiece filename, std::string* contents);
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_flag_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_flag_utils_impl.h
+deleted file mode 100644
+index aed1ac88a6..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_flag_utils_impl.h
++++ /dev/null
+@@ -1,31 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define QUIC_RELOADABLE_FLAG_COUNT_IMPL(flag)                                                      \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_RELOADABLE_FLAG_COUNT_N_IMPL(flag, instance, total)                                   \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_RESTART_FLAG_COUNT_IMPL(flag)                                                         \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_RESTART_FLAG_COUNT_N_IMPL(flag, instance, total)                                      \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_CODE_COUNT_IMPL(name)                                                                 \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_CODE_COUNT_N_IMPL(name, instance, total)                                              \
+-  do {                                                                                             \
+-  } while (0)
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_flags_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_flags_impl.h
+deleted file mode 100644
+index 872495f2db..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_flags_impl.h
++++ /dev/null
+@@ -1,44 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-#include <vector>
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-// |flag| is the global flag variable, which is a pointer to TypedFlag<type>.
+-#define GetQuicFlagImpl(flag) (quiche::flag)->value()
+-
+-// |flag| is the global flag variable, which is a pointer to TypedFlag<type>.
+-#define SetQuicFlagImpl(flag, value) (quiche::flag)->SetValue(value)
+-
+-#define GetQuicReloadableFlagImpl(flag) quiche::FLAGS_quic_reloadable_flag_##flag->value()
+-
+-#define SetQuicReloadableFlagImpl(flag, value)                                                     \
+-  quiche::FLAGS_quic_reloadable_flag_##flag->SetValue(value)
+-
+-#define GetQuicRestartFlagImpl(flag) quiche::FLAGS_quic_restart_flag_##flag->value()
+-
+-#define SetQuicRestartFlagImpl(flag, value) quiche::FLAGS_quic_restart_flag_##flag->SetValue(value)
+-
+-// Not wired into command-line parsing.
+-#define DEFINE_QUIC_COMMAND_LINE_FLAG_IMPL(type, flag, value, help)                                \
+-  quiche::TypedFlag<type>* FLAGS_##flag = new TypedFlag<type>(#flag, value, help);
+-
+-namespace quic {
+-
+-// TODO(mpwarres): implement. Lower priority since only used by QUIC command-line tools.
+-inline std::vector<std::string> QuicParseCommandLineFlagsImpl(const char* /*usage*/, int /*argc*/,
+-                                                              const char* const* /*argv*/) {
+-  return std::vector<std::string>();
+-}
+-
+-// TODO(mpwarres): implement. Lower priority since only used by QUIC command-line tools.
+-inline void QuicPrintCommandLineFlagHelpImpl(const char* /*usage*/) {}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.cc
+deleted file mode 100644
+index e047e08672..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.cc
++++ /dev/null
+@@ -1,48 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.h"
+-
+-#include <string>
+-
+-#include "common/http/utility.h"
+-
+-#include "absl/strings/ascii.h"
+-#include "absl/strings/str_cat.h"
+-
+-// TODO(wub): Implement both functions on top of GoogleUrl, then enable
+-// quiche/quic/platform/api/quic_hostname_utils_test.cc.
+-
+-namespace quic {
+-
+-// static
+-bool QuicHostnameUtilsImpl::IsValidSNI(QuicStringPiece sni) {
+-  // TODO(wub): Implement it on top of GoogleUrl, once it is available.
+-
+-  return sni.find_last_of('.') != std::string::npos &&
+-         Envoy::Http::Utility::Url().initialize(absl::StrCat("http://", sni));
+-}
+-
+-// static
+-std::string QuicHostnameUtilsImpl::NormalizeHostname(QuicStringPiece hostname) {
+-  // TODO(wub): Implement it on top of GoogleUrl, once it is available.
+-  std::string host = absl::AsciiStrToLower(hostname);
+-
+-  // Walk backwards over the string, stopping at the first trailing dot.
+-  size_t host_end = host.length();
+-  while (host_end != 0 && host[host_end - 1] == '.') {
+-    host_end--;
+-  }
+-
+-  // Erase the trailing dots.
+-  if (host_end != host.length()) {
+-    host.erase(host_end, host.length() - host_end);
+-  }
+-
+-  return host;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.h
+deleted file mode 100644
+index 97d99b2903..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_hostname_utils_impl.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/quic/platform/api/quic_export.h"
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace quic {
+-
+-class QUIC_EXPORT_PRIVATE QuicHostnameUtilsImpl {
+-public:
+-  // Returns true if the sni is valid, false otherwise.
+-  //  (1) disallow IP addresses;
+-  //  (2) check that the hostname contains valid characters only; and
+-  //  (3) contains at least one dot.
+-  // NOTE(wub): Only (3) is implemented for now.
+-  static bool IsValidSNI(QuicStringPiece sni);
+-
+-  // Normalize a hostname:
+-  //  (1) Canonicalize it, similar to what Chromium does in
+-  //  https://cs.chromium.org/chromium/src/net/base/url_util.h?q=net::CanonicalizeHost
+-  //  (2) Convert it to lower case.
+-  //  (3) Remove the trailing '.'.
+-  // WARNING: May mutate |hostname| in place.
+-  // NOTE(wub): Only (2) and (3) are implemented for now.
+-  static std::string NormalizeHostname(QuicStringPiece hostname);
+-
+-private:
+-  QuicHostnameUtilsImpl() = delete;
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_iovec_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_iovec_impl.h
+deleted file mode 100644
+index 66ed85ce1a..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_iovec_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-// TODO(danzh) Add Windows support for iovec.
+-// Only works in platforms supports POSIX for now.
+-#include <sys/uio.h>
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.cc
+deleted file mode 100644
+index 60870a742f..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.cc
++++ /dev/null
+@@ -1,81 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-#include <atomic>
+-
+-namespace quic {
+-
+-namespace {
+-std::atomic<int> g_verbosity_threshold;
+-std::atomic<bool> g_dfatal_exit_disabled;
+-
+-// Pointer to the global log sink, usually it is nullptr.
+-// If not nullptr, as in some tests, the sink will receive a copy of the log message right after the
+-// message is emitted from the QUIC_LOG... macros.
+-std::atomic<QuicLogSink*> g_quic_log_sink;
+-absl::Mutex g_quic_log_sink_mutex;
+-} // namespace
+-
+-QuicLogEmitter::QuicLogEmitter(QuicLogLevel level) : level_(level), saved_errno_(errno) {}
+-
+-QuicLogEmitter::~QuicLogEmitter() {
+-  if (is_perror_) {
+-    // TODO(wub): Change to a thread-safe version of strerror.
+-    stream_ << ": " << strerror(saved_errno_) << " [" << saved_errno_ << "]";
+-  }
+-  std::string content = stream_.str();
+-  if (!content.empty() && content.back() == '\n') {
+-    // strip the last trailing '\n' because spd log will add a trailing '\n' to
+-    // the output.
+-    content.back() = '\0';
+-  }
+-  GetLogger().log(level_, "{}", content.c_str());
+-
+-  // Normally there is no log sink and we can avoid acquiring the lock.
+-  if (g_quic_log_sink.load(std::memory_order_relaxed) != nullptr) {
+-    absl::MutexLock lock(&g_quic_log_sink_mutex);
+-    QuicLogSink* sink = g_quic_log_sink.load(std::memory_order_relaxed);
+-    if (sink != nullptr) {
+-      sink->Log(level_, content);
+-    }
+-  }
+-
+-  if (level_ == FATAL) {
+-    GetLogger().flush();
+-#ifdef NDEBUG
+-    // Release mode.
+-    abort();
+-#else
+-    // Debug mode.
+-    if (!g_dfatal_exit_disabled) {
+-      abort();
+-    }
+-#endif
+-  }
+-}
+-
+-int GetVerbosityLogThreshold() { return g_verbosity_threshold.load(std::memory_order_relaxed); }
+-
+-void SetVerbosityLogThreshold(int new_verbosity) {
+-  g_verbosity_threshold.store(new_verbosity, std::memory_order_relaxed);
+-}
+-
+-bool IsDFatalExitDisabled() { return g_dfatal_exit_disabled.load(std::memory_order_relaxed); }
+-
+-void SetDFatalExitDisabled(bool is_disabled) {
+-  g_dfatal_exit_disabled.store(is_disabled, std::memory_order_relaxed);
+-}
+-
+-QuicLogSink* SetLogSink(QuicLogSink* new_sink) {
+-  absl::MutexLock lock(&g_quic_log_sink_mutex);
+-  QuicLogSink* old_sink = g_quic_log_sink.load(std::memory_order_relaxed);
+-  g_quic_log_sink.store(new_sink, std::memory_order_relaxed);
+-  return old_sink;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.h
+deleted file mode 100644
+index 43dfe66613..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_logging_impl.h
++++ /dev/null
+@@ -1,184 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <cerrno>
+-#include <cstring>
+-#include <iostream>
+-#include <sstream>
+-#include <string>
+-
+-#include "common/common/assert.h"
+-#include "common/common/logger.h"
+-#include "common/common/stl_helpers.h"
+-
+-#include "absl/base/optimization.h"
+-#include "absl/synchronization/mutex.h"
+-
+-// This implementation is only used by Quiche code, use macros provided by
+-// assert.h and logger.h in Envoy code instead. See QUIC platform API
+-// dependency model described in
+-// https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/platform/api/README.md
+-//
+-// The implementation is backed by Envoy::Logger.
+-
+-// If |condition| is true, use |logstream| to stream the log message and send it to spdlog.
+-// If |condition| is false, |logstream| will not be instantiated.
+-// The switch(0) is used to suppress a compiler warning on ambiguous "else".
+-#define QUIC_LOG_IMPL_INTERNAL(condition, logstream)                                               \
+-  switch (0)                                                                                       \
+-  default:                                                                                         \
+-    if (!(condition)) {                                                                            \
+-    } else                                                                                         \
+-      logstream
+-
+-#define QUIC_LOG_IF_IMPL(severity, condition)                                                      \
+-  QUIC_LOG_IMPL_INTERNAL((condition) && quic::IsLogLevelEnabled(quic::severity),                   \
+-                         quic::QuicLogEmitter(quic::severity).stream())
+-
+-#define QUIC_LOG_IMPL(severity) QUIC_LOG_IF_IMPL(severity, true)
+-
+-#define QUIC_VLOG_IF_IMPL(verbosity, condition)                                                    \
+-  QUIC_LOG_IMPL_INTERNAL((condition) && quic::IsVerboseLogEnabled(verbosity),                      \
+-                         quic::QuicLogEmitter(quic::INFO).stream())
+-
+-#define QUIC_VLOG_IMPL(verbosity) QUIC_VLOG_IF_IMPL(verbosity, true)
+-
+-// TODO(wub): Implement QUIC_LOG_FIRST_N_IMPL.
+-#define QUIC_LOG_FIRST_N_IMPL(severity, n) QUIC_LOG_IMPL(severity)
+-
+-// TODO(wub): Implement QUIC_LOG_EVERY_N_IMPL.
+-#define QUIC_LOG_EVERY_N_IMPL(severity, n) QUIC_LOG_IMPL(severity)
+-
+-// TODO(wub): Implement QUIC_LOG_EVERY_N_SEC_IMPL.
+-#define QUIC_LOG_EVERY_N_SEC_IMPL(severity, seconds) QUIC_LOG_IMPL(severity)
+-
+-#define QUIC_PLOG_IMPL(severity)                                                                   \
+-  QUIC_LOG_IMPL_INTERNAL(quic::IsLogLevelEnabled(quic::severity),                                  \
+-                         quic::QuicLogEmitter(quic::severity).SetPerror().stream())
+-
+-#define QUIC_LOG_INFO_IS_ON_IMPL() quic::IsLogLevelEnabled(quic::INFO)
+-#define QUIC_LOG_WARNING_IS_ON_IMPL() quic::IsLogLevelEnabled(quic::WARNING)
+-#define QUIC_LOG_ERROR_IS_ON_IMPL() quic::IsLogLevelEnabled(quic::ERROR)
+-
+-#define CHECK(condition)                                                                           \
+-  QUIC_LOG_IF_IMPL(FATAL, ABSL_PREDICT_FALSE(!(condition))) << "CHECK failed: " #condition "."
+-
+-#define CHECK_GT(a, b) CHECK((a) > (b))
+-#define CHECK_GE(a, b) CHECK((a) >= (b))
+-#define CHECK_LT(a, b) CHECK((a) < (b))
+-#define CHECK_LE(a, b) CHECK((a) <= (b))
+-#define CHECK_NE(a, b) CHECK((a) != (b))
+-#define CHECK_EQ(a, b) CHECK((a) == (b))
+-
+-#ifdef NDEBUG
+-// Release build
+-#define DCHECK(condition) QUIC_COMPILED_OUT_LOG(condition)
+-#define QUIC_COMPILED_OUT_LOG(condition)                                                           \
+-  QUIC_LOG_IMPL_INTERNAL(false && (condition), quic::NullLogStream().stream())
+-#define QUIC_DVLOG_IMPL(verbosity) QUIC_COMPILED_OUT_LOG(false)
+-#define QUIC_DVLOG_IF_IMPL(verbosity, condition) QUIC_COMPILED_OUT_LOG(condition)
+-#define QUIC_DLOG_IMPL(severity) QUIC_COMPILED_OUT_LOG(false)
+-#define QUIC_DLOG_IF_IMPL(severity, condition) QUIC_COMPILED_OUT_LOG(condition)
+-#define QUIC_DLOG_INFO_IS_ON_IMPL() 0
+-#define QUIC_DLOG_EVERY_N_IMPL(severity, n) QUIC_COMPILED_OUT_LOG(false)
+-#define QUIC_NOTREACHED_IMPL()
+-#else
+-// Debug build
+-#define DCHECK(condition) CHECK(condition)
+-#define QUIC_DVLOG_IMPL(verbosity) QUIC_VLOG_IMPL(verbosity)
+-#define QUIC_DVLOG_IF_IMPL(verbosity, condition) QUIC_VLOG_IF_IMPL(verbosity, condition)
+-#define QUIC_DLOG_IMPL(severity) QUIC_LOG_IMPL(severity)
+-#define QUIC_DLOG_IF_IMPL(severity, condition) QUIC_LOG_IF_IMPL(severity, condition)
+-#define QUIC_DLOG_INFO_IS_ON_IMPL() QUIC_LOG_INFO_IS_ON_IMPL()
+-#define QUIC_DLOG_EVERY_N_IMPL(severity, n) QUIC_LOG_EVERY_N_IMPL(severity, n)
+-#define QUIC_NOTREACHED_IMPL() NOT_REACHED_GCOVR_EXCL_LINE
+-#endif
+-
+-#define DCHECK_GE(a, b) DCHECK((a) >= (b))
+-#define DCHECK_GT(a, b) DCHECK((a) > (b))
+-#define DCHECK_LT(a, b) DCHECK((a) < (b))
+-#define DCHECK_LE(a, b) DCHECK((a) <= (b))
+-#define DCHECK_NE(a, b) DCHECK((a) != (b))
+-#define DCHECK_EQ(a, b) DCHECK((a) == (b))
+-
+-#define QUIC_PREDICT_FALSE_IMPL(x) ABSL_PREDICT_FALSE(x)
+-
+-namespace quic {
+-
+-using QuicLogLevel = spdlog::level::level_enum;
+-
+-static const QuicLogLevel INFO = spdlog::level::info;
+-static const QuicLogLevel WARNING = spdlog::level::warn;
+-static const QuicLogLevel ERROR = spdlog::level::err;
+-static const QuicLogLevel FATAL = spdlog::level::critical;
+-
+-// DFATAL is FATAL in debug mode, ERROR in release mode.
+-#ifdef NDEBUG
+-static const QuicLogLevel DFATAL = ERROR;
+-#else
+-static const QuicLogLevel DFATAL = FATAL;
+-#endif
+-
+-class QuicLogEmitter {
+-public:
+-  explicit QuicLogEmitter(QuicLogLevel level);
+-
+-  ~QuicLogEmitter();
+-
+-  QuicLogEmitter& SetPerror() {
+-    is_perror_ = true;
+-    return *this;
+-  }
+-
+-  std::ostringstream& stream() { return stream_; }
+-
+-private:
+-  const QuicLogLevel level_;
+-  const int saved_errno_;
+-  bool is_perror_ = false;
+-  std::ostringstream stream_;
+-};
+-
+-class NullLogStream : public std::ostream {
+-public:
+-  NullLogStream& stream() { return *this; }
+-};
+-
+-template <typename T> inline NullLogStream& operator<<(NullLogStream& s, const T&) { return s; }
+-
+-inline spdlog::logger& GetLogger() {
+-  return Envoy::Logger::Registry::getLog(Envoy::Logger::Id::quic);
+-}
+-
+-inline bool IsLogLevelEnabled(QuicLogLevel level) { return level >= GetLogger().level(); }
+-
+-int GetVerbosityLogThreshold();
+-void SetVerbosityLogThreshold(int new_verbosity);
+-
+-inline bool IsVerboseLogEnabled(int verbosity) {
+-  return IsLogLevelEnabled(INFO) && verbosity <= GetVerbosityLogThreshold();
+-}
+-
+-bool IsDFatalExitDisabled();
+-void SetDFatalExitDisabled(bool is_disabled);
+-
+-// QuicLogSink is used to capture logs emitted from the QUIC_LOG... macros.
+-class QuicLogSink {
+-public:
+-  virtual ~QuicLogSink() = default;
+-
+-  // Called when |message| is emitted at |level|.
+-  virtual void Log(QuicLogLevel level, const std::string& message) = 0;
+-};
+-
+-// Only one QuicLogSink can capture log at a time. SetLogSink causes future logs
+-// to be captured by the |new_sink|.
+-// Return the previous sink.
+-QuicLogSink* SetLogSink(QuicLogSink* new_sink);
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_macros_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_macros_impl.h
+deleted file mode 100644
+index eb8ce413fb..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_macros_impl.h
++++ /dev/null
+@@ -1,12 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/base/attributes.h"
+-
+-#define QUIC_MUST_USE_RESULT_IMPL ABSL_MUST_USE_RESULT
+-#define QUIC_UNUSED_IMPL ABSL_ATTRIBUTE_UNUSED
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_map_util_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_map_util_impl.h
+deleted file mode 100644
+index 2bf549d9c3..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_map_util_impl.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <algorithm>
+-
+-namespace quic {
+-
+-template <class Collection, class Key>
+-bool QuicContainsKeyImpl(const Collection& collection, const Key& key) {
+-  return collection.find(key) != collection.end();
+-}
+-
+-template <typename Collection, typename Value>
+-bool QuicContainsValueImpl(const Collection& collection, const Value& value) {
+-  return std::find(collection.begin(), collection.end(), value) != collection.end();
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.cc
+deleted file mode 100644
+index 10ba3647f5..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.cc
++++ /dev/null
+@@ -1,45 +0,0 @@
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.h"
+-
+-#include "envoy/buffer/buffer.h"
+-
+-#include "common/common/assert.h"
+-
+-namespace quic {
+-
+-QuicMemSliceImpl::QuicMemSliceImpl(QuicBufferAllocator* /*allocator*/, size_t length) {
+-  Envoy::Buffer::RawSlice iovec;
+-  uint64_t num_iov = single_slice_buffer_.reserve(length, &iovec, 1);
+-  ASSERT(num_iov == 1);
+-  // OwnedImpl may return a slice longer than needed, trim it to requested length.
+-  iovec.len_ = length;
+-  single_slice_buffer_.commit(&iovec, 1);
+-  ASSERT(this->length() == length);
+-}
+-
+-QuicMemSliceImpl::QuicMemSliceImpl(Envoy::Buffer::Instance& buffer, size_t length) {
+-  ASSERT(firstSliceLength(buffer) == length);
+-  single_slice_buffer_.move(buffer, length);
+-  ASSERT(single_slice_buffer_.getRawSlices(nullptr, 0) == 1);
+-}
+-
+-const char* QuicMemSliceImpl::data() const {
+-  Envoy::Buffer::RawSlice out;
+-  uint64_t num_slices = single_slice_buffer_.getRawSlices(&out, 1);
+-  ASSERT(num_slices <= 1);
+-  return static_cast<const char*>(out.mem_);
+-}
+-
+-size_t QuicMemSliceImpl::firstSliceLength(Envoy::Buffer::Instance& buffer) {
+-  Envoy::Buffer::RawSlice slice;
+-  uint64_t total_num = buffer.getRawSlices(&slice, 1);
+-  ASSERT(total_num != 0);
+-  return slice.len_;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.h
+deleted file mode 100644
+index e1dc857ae5..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_impl.h
++++ /dev/null
+@@ -1,68 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <cstddef>
+-#include <iostream>
+-#include <memory>
+-
+-#include "common/buffer/buffer_impl.h"
+-
+-#include "quiche/quic/core/quic_buffer_allocator.h"
+-
+-namespace quic {
+-
+-// Implements the interface required by
+-// https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/platform/api/quic_mem_slice.h
+-class QuicMemSliceImpl {
+-public:
+-  // Constructs an empty QuicMemSliceImpl.
+-  QuicMemSliceImpl() = default;
+-
+-  // Constructs a QuicMemSliceImpl by letting |single_slice_buffer_| allocate |length| memory.
+-  // TODO(danzh) Note that |allocator| is not used to allocate memory currently, instead,
+-  // Buffer::OwnedImpl allocates memory on its own. Investigate if a customized
+-  // QuicBufferAllocator can improve cache hit.
+-  QuicMemSliceImpl(QuicBufferAllocator* allocator, size_t length);
+-
+-  // Constructs a QuicMemSliceImpl from a Buffer::Instance with first |length| bytes in it.
+-  // Data will be moved from |buffer| to this mem slice.
+-  // Prerequisite: |buffer| has at least |length| bytes of data and not empty.
+-  explicit QuicMemSliceImpl(Envoy::Buffer::Instance& buffer, size_t length);
+-
+-  QuicMemSliceImpl(const QuicMemSliceImpl& other) = delete;
+-  // Move constructors. |other| will not hold a reference to the data buffer
+-  // after this call completes.
+-  QuicMemSliceImpl(QuicMemSliceImpl&& other) noexcept { *this = std::move(other); }
+-
+-  QuicMemSliceImpl& operator=(const QuicMemSliceImpl& other) = delete;
+-  QuicMemSliceImpl& operator=(QuicMemSliceImpl&& other) noexcept {
+-    if (this != &other) {
+-      single_slice_buffer_.move(other.single_slice_buffer_);
+-    }
+-    return *this;
+-  }
+-
+-  // Below methods implements interface needed by QuicMemSlice.
+-  void Reset() { single_slice_buffer_.drain(length()); }
+-
+-  // Returns a char pointer to the one and only slice in buffer.
+-  const char* data() const;
+-
+-  size_t length() const { return single_slice_buffer_.length(); }
+-  bool empty() const { return length() == 0; }
+-
+-  Envoy::Buffer::OwnedImpl& single_slice_buffer() { return single_slice_buffer_; }
+-
+-private:
+-  // Prerequisite: buffer has at least one slice.
+-  size_t firstSliceLength(Envoy::Buffer::Instance& buffer);
+-
+-  Envoy::Buffer::OwnedImpl single_slice_buffer_;
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.cc
+deleted file mode 100644
+index 15cfaad93b..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.cc
++++ /dev/null
+@@ -1,21 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h"
+-
+-#include "quiche/quic/platform/api/quic_mem_slice.h"
+-
+-namespace quic {
+-
+-QuicStringPiece QuicMemSliceSpanImpl::GetData(size_t index) {
+-  uint64_t num_slices = buffer_->getRawSlices(nullptr, 0);
+-  ASSERT(num_slices > index);
+-  Envoy::STACK_ARRAY(slices, Envoy::Buffer::RawSlice, num_slices);
+-  buffer_->getRawSlices(slices.begin(), num_slices);
+-  return {reinterpret_cast<char*>(slices[index].mem_), slices[index].len_};
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h
+deleted file mode 100644
+index d30138d97d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "envoy/buffer/buffer.h"
+-
+-#include "common/common/stack_array.h"
+-
+-#include "quiche/quic/core/quic_types.h"
+-#include "quiche/quic/platform/api/quic_mem_slice.h"
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace quic {
+-
+-// Implements the interface required by
+-// https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/platform/api/quic_mem_slice_span.h
+-// Wraps a Buffer::Instance and deliver its data with minimum number of copies.
+-class QuicMemSliceSpanImpl {
+-public:
+-  QuicMemSliceSpanImpl() : buffer_(nullptr) {}
+-  /**
+-   * @param buffer has to outlive the life time of this class.
+-   */
+-  explicit QuicMemSliceSpanImpl(Envoy::Buffer::Instance& buffer) : buffer_(&buffer) {}
+-  explicit QuicMemSliceSpanImpl(QuicMemSliceImpl* slice) : buffer_(&slice->single_slice_buffer()) {}
+-
+-  QuicMemSliceSpanImpl(const QuicMemSliceSpanImpl& other) = default;
+-  QuicMemSliceSpanImpl& operator=(const QuicMemSliceSpanImpl& other) = default;
+-
+-  QuicMemSliceSpanImpl(QuicMemSliceSpanImpl&& other) noexcept : buffer_(other.buffer_) {
+-    other.buffer_ = nullptr;
+-  }
+-
+-  QuicMemSliceSpanImpl& operator=(QuicMemSliceSpanImpl&& other) noexcept {
+-    if (this != &other) {
+-      buffer_ = other.buffer_;
+-      other.buffer_ = nullptr;
+-    }
+-    return *this;
+-  }
+-
+-  // QuicMemSliceSpan
+-  QuicStringPiece GetData(size_t index);
+-  QuicByteCount total_length() { return buffer_->length(); };
+-  size_t NumSlices() { return buffer_->getRawSlices(nullptr, 0); }
+-  template <typename ConsumeFunction> QuicByteCount ConsumeAll(ConsumeFunction consume);
+-  bool empty() const { return buffer_->length() == 0; }
+-
+-private:
+-  Envoy::Buffer::Instance* buffer_{nullptr};
+-};
+-
+-template <typename ConsumeFunction>
+-QuicByteCount QuicMemSliceSpanImpl::ConsumeAll(ConsumeFunction consume) {
+-  uint64_t num_slices = buffer_->getRawSlices(nullptr, 0);
+-  Envoy::STACK_ARRAY(slices, Envoy::Buffer::RawSlice, num_slices);
+-  buffer_->getRawSlices(slices.begin(), num_slices);
+-  size_t saved_length = 0;
+-  for (auto& slice : slices) {
+-    if (slice.len_ == 0) {
+-      continue;
+-    }
+-    // Move each slice into a stand-alone buffer.
+-    // TODO(danzh): investigate the cost of allocating one buffer per slice.
+-    // If it turns out to be expensive, add a new function to free data in the middle in buffer
+-    // interface and re-design QuicMemSliceImpl.
+-    consume(QuicMemSlice(QuicMemSliceImpl(*buffer_, slice.len_)));
+-    saved_length += slice.len_;
+-  }
+-  ASSERT(buffer_->length() == 0);
+-  return saved_length;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.cc b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.cc
+deleted file mode 100644
+index 53d8315644..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.cc
++++ /dev/null
+@@ -1,50 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.h"
+-
+-#include <cstdint>
+-
+-#include "envoy/buffer/buffer.h"
+-
+-#include "quiche/quic/core/quic_utils.h"
+-
+-namespace quic {
+-
+-// TODO(danzh)Note that |allocator| is not used to allocate memory currently, instead,
+-// Buffer::OwnedImpl allocates memory on its own. Investigate if a customized
+-// QuicBufferAllocator can improve cache hit.
+-QuicMemSliceStorageImpl::QuicMemSliceStorageImpl(const struct iovec* iov, int iov_count,
+-                                                 QuicBufferAllocator* /*allocator*/,
+-                                                 const QuicByteCount max_slice_len) {
+-  if (iov == nullptr) {
+-    return;
+-  }
+-  QuicByteCount write_len = 0;
+-  for (int i = 0; i < iov_count; ++i) {
+-    write_len += iov[i].iov_len;
+-  }
+-  size_t io_offset = 0;
+-  while (io_offset < write_len) {
+-    size_t slice_len = std::min(write_len - io_offset, max_slice_len);
+-    Envoy::Buffer::RawSlice slice;
+-    // Populate a temporary buffer instance and then move it to |buffer_|.
+-    // This is necessary for the old evbuffer implementation of OwnedImpl where
+-    // consecutive reserve/commit can return addresses in same slice which
+-    // violates the restriction of |max_slice_len| when ToSpan() is called.
+-    Envoy::Buffer::OwnedImpl buffer;
+-    uint16_t num_slice = buffer.reserve(slice_len, &slice, 1);
+-    ASSERT(num_slice == 1);
+-    QuicUtils::CopyToBuffer(iov, iov_count, io_offset, slice_len, static_cast<char*>(slice.mem_));
+-    io_offset += slice_len;
+-    // OwnedImpl may return a slice longer than needed, trim it to requested length.
+-    slice.len_ = slice_len;
+-    buffer.commit(&slice, num_slice);
+-    buffer_.move(buffer);
+-  }
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.h
+deleted file mode 100644
+index 3a43ec7316..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mem_slice_storage_impl.h
++++ /dev/null
+@@ -1,45 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "common/buffer/buffer_impl.h"
+-
+-#include "quiche/quic/core/quic_buffer_allocator.h"
+-#include "quiche/quic/platform/api/quic_iovec.h"
+-#include "quiche/quic/platform/api/quic_mem_slice_span.h"
+-
+-namespace quic {
+-
+-// QuicMemSliceStorageImpl wraps a MemSlice vector.
+-class QuicMemSliceStorageImpl {
+-public:
+-  QuicMemSliceStorageImpl(const struct iovec* iov, int iov_count, QuicBufferAllocator* allocator,
+-                          const QuicByteCount max_slice_len);
+-
+-  QuicMemSliceStorageImpl(const QuicMemSliceStorageImpl& other) { buffer_.add(other.buffer_); }
+-
+-  QuicMemSliceStorageImpl& operator=(const QuicMemSliceStorageImpl& other) {
+-    if (this != &other) {
+-      if (buffer_.length() > 0) {
+-        buffer_.drain(buffer_.length());
+-      }
+-      buffer_.add(other.buffer_);
+-    }
+-    return *this;
+-  }
+-  QuicMemSliceStorageImpl(QuicMemSliceStorageImpl&& other) = default;
+-  QuicMemSliceStorageImpl& operator=(QuicMemSliceStorageImpl&& other) = default;
+-
+-  QuicMemSliceSpan ToSpan() { return QuicMemSliceSpan(QuicMemSliceSpanImpl(buffer_)); }
+-
+-  void Append(QuicMemSliceImpl mem_slice) { buffer_.move(mem_slice.single_slice_buffer()); }
+-
+-private:
+-  Envoy::Buffer::OwnedImpl buffer_;
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_mutex_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_mutex_impl.h
+deleted file mode 100644
+index 4250eb45e2..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_mutex_impl.h
++++ /dev/null
+@@ -1,60 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/synchronization/mutex.h"
+-#include "absl/synchronization/notification.h"
+-#include "quiche/quic/platform/api/quic_export.h"
+-
+-namespace quic {
+-
+-// A class wrapping a non-reentrant mutex.
+-class LOCKABLE QUIC_EXPORT_PRIVATE QuicLockImpl {
+-public:
+-  QuicLockImpl() = default;
+-  QuicLockImpl(const QuicLockImpl&) = delete;
+-  QuicLockImpl& operator=(const QuicLockImpl&) = delete;
+-
+-  // Block until mu_ is free, then acquire it exclusively.
+-  void WriterLock() EXCLUSIVE_LOCK_FUNCTION() { mu_.WriterLock(); }
+-
+-  // Release mu_. Caller must hold it exclusively.
+-  void WriterUnlock() UNLOCK_FUNCTION() { mu_.WriterUnlock(); }
+-
+-  // Block until mu_ is free or shared, then acquire a share of it.
+-  void ReaderLock() SHARED_LOCK_FUNCTION() { mu_.ReaderLock(); }
+-
+-  // Release mu_. Caller could hold it in shared mode.
+-  void ReaderUnlock() UNLOCK_FUNCTION() { mu_.ReaderUnlock(); }
+-
+-  // Returns immediately if current thread holds mu_ in at least shared
+-  // mode. Otherwise, reports an error by crashing with a diagnostic.
+-  void AssertReaderHeld() const ASSERT_SHARED_LOCK() { mu_.AssertReaderHeld(); }
+-
+-private:
+-  absl::Mutex mu_;
+-};
+-
+-// A Notification allows threads to receive notification of a single occurrence
+-// of a single event.
+-class QUIC_EXPORT_PRIVATE QuicNotificationImpl {
+-public:
+-  QuicNotificationImpl() = default;
+-  QuicNotificationImpl(const QuicNotificationImpl&) = delete;
+-  QuicNotificationImpl& operator=(const QuicNotificationImpl&) = delete;
+-
+-  bool HasBeenNotified() { return notification_.HasBeenNotified(); }
+-
+-  void Notify() { notification_.Notify(); }
+-
+-  void WaitForNotification() { notification_.WaitForNotification(); }
+-
+-private:
+-  absl::Notification notification_;
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_optional_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_optional_impl.h
+deleted file mode 100644
+index 0c03fc3a0a..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_optional_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/types/optional.h"
+-
+-namespace quic {
+-
+-template <typename T> using QuicOptionalImpl = absl::optional<T>;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_pcc_sender_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_pcc_sender_impl.h
+deleted file mode 100644
+index 1e0f2bcbaf..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_pcc_sender_impl.h
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "common/common/assert.h"
+-
+-#include "quiche/quic/core/quic_types.h"
+-
+-namespace quic {
+-
+-class QuicClock;
+-struct QuicConnectionStats;
+-class QuicRandom;
+-class QuicUnackedPacketMap;
+-class RttStats;
+-class SendAlgorithmInterface;
+-
+-// Interface for creating a PCC SendAlgorithmInterface.
+-inline SendAlgorithmInterface*
+-CreatePccSenderImpl(const QuicClock* /*clock*/, const RttStats* /*rtt_stats*/,
+-                    const QuicUnackedPacketMap* /*unacked_packets*/, QuicRandom* /*random*/,
+-                    QuicConnectionStats* /*stats*/, QuicPacketCount /*initial_congestion_window*/,
+-                    QuicPacketCount /*max_congestion_window*/) {
+-  PANIC("PccSender is not supported.");
+-  return nullptr;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_prefetch_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_prefetch_impl.h
+deleted file mode 100644
+index 1e4499b955..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_prefetch_impl.h
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-#if defined(__GNUC__)
+-// See __builtin_prefetch in:
+-// https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html.
+-inline void QuicPrefetchT0Impl(const void* addr) { __builtin_prefetch(addr, 0, 3); }
+-#else
+-inline void QuicPrefetchT0Impl(const void*) {}
+-#endif
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_ptr_util_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_ptr_util_impl.h
+deleted file mode 100644
+index 5abbb5f7cd..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_ptr_util_impl.h
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-#include <utility>
+-
+-#include "absl/memory/memory.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-template <typename T, typename... Args> std::unique_ptr<T> QuicMakeUniqueImpl(Args&&... args) {
+-  return std::make_unique<T>(std::forward<Args>(args)...);
+-}
+-
+-template <typename T> std::unique_ptr<T> QuicWrapUniqueImpl(T* ptr) {
+-  return absl::WrapUnique<T>(ptr);
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_reference_counted_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_reference_counted_impl.h
+deleted file mode 100644
+index 95ccdcd204..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_reference_counted_impl.h
++++ /dev/null
+@@ -1,106 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <memory>
+-
+-#include "quiche/quic/platform/api/quic_export.h"
+-
+-namespace quic {
+-
+-/** The implementation of reference counted object is merely wrapping
+- * std::shared_ptr. So QuicReferenceCountedImpl class does not do anything
+- * related to reference counting as shared_ptr already takes care of that. But
+- * it customizes destruction to provide a interface for shared_ptr to destroy
+- * the object, because according to the API declared in QuicReferenceCounted,
+- * this class has to hide its destructor.
+- */
+-class QuicReferenceCountedImpl {
+-public:
+-  QuicReferenceCountedImpl() = default;
+-
+-  // Expose destructor through this method.
+-  static void destroy(QuicReferenceCountedImpl* impl) { delete impl; }
+-
+-protected:
+-  // Non-public destructor to match API declared in QuicReferenceCounted.
+-  virtual ~QuicReferenceCountedImpl() = default;
+-};
+-
+-template <typename T> class QuicReferenceCountedPointerImpl {
+-public:
+-  QuicReferenceCountedPointerImpl() : refptr_(nullptr, T::destroy) {}
+-  QuicReferenceCountedPointerImpl(T* p) : refptr_(p, T::destroy) {}
+-  QuicReferenceCountedPointerImpl(std::nullptr_t) : refptr_(nullptr, T::destroy) {}
+-  // Copy constructor.
+-  template <typename U>
+-  QuicReferenceCountedPointerImpl(const QuicReferenceCountedPointerImpl<U>& other)
+-      : refptr_(other.refptr()) {}
+-  QuicReferenceCountedPointerImpl(const QuicReferenceCountedPointerImpl& other)
+-      : refptr_(other.refptr()) {}
+-
+-  // Move constructor.
+-  template <typename U>
+-  QuicReferenceCountedPointerImpl(QuicReferenceCountedPointerImpl<U>&& other) noexcept
+-      : refptr_(std::move(other.refptr())) {}
+-  QuicReferenceCountedPointerImpl(QuicReferenceCountedPointerImpl&& other) noexcept
+-      : refptr_(std::move(other.refptr())) {}
+-
+-  ~QuicReferenceCountedPointerImpl() = default;
+-
+-  // Copy assignments.
+-  QuicReferenceCountedPointerImpl& operator=(const QuicReferenceCountedPointerImpl& other) {
+-    refptr_ = other.refptr();
+-    return *this;
+-  }
+-  template <typename U>
+-  QuicReferenceCountedPointerImpl& operator=(const QuicReferenceCountedPointerImpl<U>& other) {
+-    refptr_ = other.refptr();
+-    return *this;
+-  }
+-
+-  // Move assignments.
+-  QuicReferenceCountedPointerImpl& operator=(QuicReferenceCountedPointerImpl&& other) noexcept {
+-    refptr_ = std::move(other.refptr());
+-    return *this;
+-  }
+-  template <typename U>
+-  QuicReferenceCountedPointerImpl& operator=(QuicReferenceCountedPointerImpl<U>&& other) noexcept {
+-    refptr_ = std::move(other.refptr());
+-    return *this;
+-  }
+-
+-  QuicReferenceCountedPointerImpl<T>& operator=(T* p) {
+-    refptr_.reset(p, T::destroy);
+-    return *this;
+-  }
+-
+-  // Returns the raw pointer with no change in reference.
+-  T* get() const { return refptr_.get(); }
+-
+-  // Accessors for the referenced object.
+-  // operator* and operator-> will assert() if there is no current object.
+-  T& operator*() const {
+-    assert(refptr_ != nullptr);
+-    return *refptr_;
+-  }
+-  T* operator->() const {
+-    assert(refptr_ != nullptr);
+-    return refptr_.get();
+-  }
+-
+-  explicit operator bool() const { return static_cast<bool>(refptr_); }
+-
+-  const std::shared_ptr<T>& refptr() const { return refptr_; }
+-
+-  std::shared_ptr<T>& refptr() { return refptr_; }
+-
+-private:
+-  std::shared_ptr<T> refptr_;
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_server_stats_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_server_stats_impl.h
+deleted file mode 100644
+index 0d57ebd280..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_server_stats_impl.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define QUIC_SERVER_HISTOGRAM_ENUM_IMPL(name, sample, enum_size, docstring)                        \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_SERVER_HISTOGRAM_BOOL_IMPL(name, sample, docstring)                                   \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_SERVER_HISTOGRAM_TIMES_IMPL(name, sample, min, max, bucket_count, docstring)          \
+-  do {                                                                                             \
+-  } while (0)
+-
+-#define QUIC_SERVER_HISTOGRAM_COUNTS_IMPL(name, sample, min, max, bucket_count, docstring)         \
+-  do {                                                                                             \
+-  } while (0)
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_stack_trace_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_stack_trace_impl.h
+deleted file mode 100644
+index ec06b6299d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_stack_trace_impl.h
++++ /dev/null
+@@ -1,24 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <sstream>
+-#include <string>
+-
+-#include "server/backtrace.h"
+-
+-namespace quic {
+-
+-inline std::string QuicStackTraceImpl() {
+-  Envoy::BackwardsTrace t;
+-  t.capture();
+-  std::ostringstream os;
+-  t.printTrace(os);
+-  return os.str();
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_str_cat_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_str_cat_impl.h
+deleted file mode 100644
+index dafbee10b5..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_str_cat_impl.h
++++ /dev/null
+@@ -1,22 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/str_cat.h"
+-#include "fmt/printf.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-template <typename... Args> inline std::string QuicStrCatImpl(const Args&... args) {
+-  return absl::StrCat(args...);
+-}
+-
+-template <typename... Args> inline std::string QuicStringPrintfImpl(const Args&... args) {
+-  return fmt::sprintf(std::forward<const Args&>(args)...);
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_stream_buffer_allocator_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_stream_buffer_allocator_impl.h
+deleted file mode 100644
+index c2a40a0e74..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_stream_buffer_allocator_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/quic/core/quic_simple_buffer_allocator.h"
+-
+-namespace quic {
+-
+-// Implements the interface required by
+-// https://quiche.googlesource.com/quiche/+/refs/heads/master/quic/platform/api/quic_stream_buffer_allocator.h
+-// with the default implementation provided by QUICHE.
+-using QuicStreamBufferAllocatorImpl = SimpleBufferAllocator;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_string_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_string_impl.h
+deleted file mode 100644
+index 9370a02b1e..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_string_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-using QuicStringImpl = std::string;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_string_piece_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_string_piece_impl.h
+deleted file mode 100644
+index a9033cd90f..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_string_piece_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/string_view.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-using QuicStringPieceImpl = absl::string_view;
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_string_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_string_utils_impl.h
+deleted file mode 100644
+index 5e1f3e712d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_string_utils_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/str_cat.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-template <typename... Args>
+-inline void QuicStrAppendImpl(std::string* output, const Args&... args) {
+-  absl::StrAppend(output, args...);
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_text_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_text_utils_impl.h
+deleted file mode 100644
+index e39508adbb..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_text_utils_impl.h
++++ /dev/null
+@@ -1,81 +0,0 @@
+-#pragma once
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_string_piece_impl.h"
+-#include "extensions/quic_listeners/quiche/platform/string_utils.h"
+-
+-#include "absl/strings/ascii.h"
+-#include "absl/strings/escaping.h"
+-#include "absl/strings/match.h"
+-#include "absl/strings/numbers.h"
+-#include "absl/strings/str_cat.h"
+-#include "absl/strings/str_format.h"
+-#include "absl/strings/str_split.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-class QuicTextUtilsImpl {
+-public:
+-  static bool StartsWith(QuicStringPieceImpl data, QuicStringPieceImpl prefix) {
+-    return absl::StartsWith(data, prefix);
+-  }
+-
+-  static bool EndsWithIgnoreCase(QuicStringPieceImpl data, QuicStringPieceImpl suffix) {
+-    return absl::EndsWithIgnoreCase(data, suffix);
+-  }
+-
+-  static std::string ToLower(QuicStringPieceImpl data) { return absl::AsciiStrToLower(data); }
+-
+-  static void RemoveLeadingAndTrailingWhitespace(QuicStringPieceImpl* data) {
+-    *data = absl::StripAsciiWhitespace(*data);
+-  }
+-
+-  static bool StringToUint64(QuicStringPieceImpl in, uint64_t* out) {
+-    return absl::SimpleAtoi(in, out);
+-  }
+-
+-  static bool StringToInt(QuicStringPieceImpl in, int* out) { return absl::SimpleAtoi(in, out); }
+-
+-  static bool StringToUint32(QuicStringPieceImpl in, uint32_t* out) {
+-    return absl::SimpleAtoi(in, out);
+-  }
+-
+-  static bool StringToSizeT(QuicStringPieceImpl in, size_t* out) {
+-    return absl::SimpleAtoi(in, out);
+-  }
+-
+-  static std::string Uint64ToString(uint64_t in) { return absl::StrCat(in); }
+-
+-  static std::string HexEncode(QuicStringPieceImpl data) { return absl::BytesToHexString(data); }
+-
+-  static std::string Hex(uint32_t v) { return absl::StrCat(absl::Hex(v)); }
+-
+-  static std::string HexDecode(QuicStringPieceImpl data) { return absl::HexStringToBytes(data); }
+-
+-  static void Base64Encode(const uint8_t* data, size_t data_len, std::string* output) {
+-    return quiche::Base64Encode(data, data_len, output);
+-  }
+-
+-  static std::string HexDump(QuicStringPieceImpl binary_data) {
+-    return quiche::HexDump(binary_data);
+-  }
+-
+-  static bool ContainsUpperCase(QuicStringPieceImpl data) {
+-    return std::any_of(data.begin(), data.end(), absl::ascii_isupper);
+-  }
+-
+-  static bool IsAllDigits(QuicStringPieceImpl data) {
+-    return std::all_of(data.begin(), data.end(), absl::ascii_isdigit);
+-  }
+-
+-  static std::vector<QuicStringPieceImpl> Split(QuicStringPieceImpl data, char delim) {
+-    return absl::StrSplit(data, delim);
+-  }
+-};
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quic_uint128_impl.h b/source/extensions/quic_listeners/quiche/platform/quic_uint128_impl.h
+deleted file mode 100644
+index 80ca83bdc9..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quic_uint128_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/numeric/int128.h"
+-
+-namespace quic {
+-
+-using QuicUint128Impl = absl::uint128;
+-#define MakeQuicUint128Impl(hi, lo) absl::MakeUint128(hi, lo)
+-#define QuicUint128Low64Impl(x) absl::Uint128Low64(x)
+-#define QuicUint128High64Impl(x) absl::Uint128High64(x)
+-
+-} // namespace quic
+diff --git a/source/extensions/quic_listeners/quiche/platform/quiche_logging_impl.h b/source/extensions/quic_listeners/quiche/platform/quiche_logging_impl.h
+deleted file mode 100644
+index 26e5f76626..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quiche_logging_impl.h
++++ /dev/null
+@@ -1,9 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+diff --git a/source/extensions/quic_listeners/quiche/platform/quiche_ptr_util_impl.h b/source/extensions/quic_listeners/quiche/platform/quiche_ptr_util_impl.h
+deleted file mode 100644
+index e5ed8a2714..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quiche_ptr_util_impl.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <memory>
+-
+-namespace quiche {
+-
+-template <typename T, typename... Args> std::unique_ptr<T> QuicheMakeUniqueImpl(Args&&... args) {
+-  return std::make_unique<T>(std::forward<Args>(args)...);
+-}
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/platform/quiche_unordered_containers_impl.h b/source/extensions/quic_listeners/quiche/platform/quiche_unordered_containers_impl.h
+deleted file mode 100644
+index cefb261521..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/quiche_unordered_containers_impl.h
++++ /dev/null
+@@ -1,21 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/container/node_hash_map.h"
+-#include "absl/hash/hash.h"
+-
+-namespace quiche {
+-
+-// The default hasher used by hash tables.
+-template <typename Key> using QuicheDefaultHasherImpl = absl::Hash<Key>;
+-
+-// Similar to std::unordered_map, but with better performance and memory usage.
+-template <typename Key, typename Value, typename Hash>
+-using QuicheUnorderedMapImpl = absl::node_hash_map<Key, Value, Hash>;
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_arraysize_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_arraysize_impl.h
+deleted file mode 100644
+index 2fb131122d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_arraysize_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-#include "absl/base/macros.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define SPDY_ARRAYSIZE_IMPL(x) ABSL_ARRAYSIZE(x)
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_bug_tracker_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_bug_tracker_impl.h
+deleted file mode 100644
+index 93cb60e469..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_bug_tracker_impl.h
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h"
+-
+-#define SPDY_BUG_IMPL QUIC_BUG_IMPL
+-#define SPDY_BUG_IF_IMPL QUIC_BUG_IF_IMPL
+-#define FLAGS_spdy_always_log_bugs_for_tests_impl true
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_containers_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_containers_impl.h
+deleted file mode 100644
+index 35d08c6183..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_containers_impl.h
++++ /dev/null
+@@ -1,42 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/spdy_string_impl.h"
+-#include "extensions/quic_listeners/quiche/platform/spdy_string_piece_impl.h"
+-
+-#include "absl/container/flat_hash_map.h"
+-#include "absl/container/flat_hash_set.h"
+-#include "absl/container/inlined_vector.h"
+-#include "absl/hash/hash.h"
+-#include "quiche/common/simple_linked_hash_map.h"
+-
+-namespace spdy {
+-
+-template <typename KeyType> using SpdyHashImpl = absl::Hash<KeyType>;
+-
+-template <typename KeyType, typename ValueType, typename Hash = absl::Hash<KeyType>>
+-using SpdyHashMapImpl = absl::flat_hash_map<KeyType, ValueType, Hash>;
+-
+-template <typename ElementType, typename Hasher, typename Eq>
+-using SpdyHashSetImpl = absl::flat_hash_set<ElementType, Hasher, Eq>;
+-
+-template <typename Key, typename Value, typename Hash>
+-using SpdyLinkedHashMapImpl = quiche::SimpleLinkedHashMap<Key, Value, Hash>;
+-
+-template <typename T, size_t N, typename A = std::allocator<T>>
+-using SpdyInlinedVectorImpl = absl::InlinedVector<T, N, A>;
+-
+-using SpdyStringPieceHashImpl = absl::Hash<absl::string_view>;
+-
+-inline size_t SpdyHashStringPairImpl(SpdyStringPieceImpl a, SpdyStringPieceImpl b) {
+-  return absl::Hash<std::pair<SpdyStringPieceImpl, SpdyStringPieceImpl>>()(std::make_pair(a, b));
+-}
+-
+-template <typename Key, typename Value, int Size>
+-using SpdySmallMapImpl = absl::flat_hash_map<Key, Value>;
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_endianness_util_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_endianness_util_impl.h
+deleted file mode 100644
+index f72c476b34..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_endianness_util_impl.h
++++ /dev/null
+@@ -1,29 +0,0 @@
+-#pragma once
+-
+-#include <arpa/inet.h>
+-
+-#include <cstdint>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace spdy {
+-
+-inline uint16_t SpdyNetToHost16Impl(uint16_t x) { return ntohs(x); }
+-
+-inline uint32_t SpdyNetToHost32Impl(uint32_t x) { return ntohl(x); }
+-
+-// TODO: implement
+-inline uint64_t SpdyNetToHost64Impl(uint64_t /*x*/) { return 0; }
+-
+-inline uint16_t SpdyHostToNet16Impl(uint16_t x) { return htons(x); }
+-
+-inline uint32_t SpdyHostToNet32Impl(uint32_t x) { return htonl(x); }
+-
+-// TODO: implement
+-inline uint64_t SpdyHostToNet64Impl(uint64_t /*x*/) { return 0; }
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_estimate_memory_usage_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_estimate_memory_usage_impl.h
+deleted file mode 100644
+index e8643b35f9..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_estimate_memory_usage_impl.h
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#pragma once
+-
+-#include <cstddef>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace spdy {
+-
+-// Dummy implementation.
+-template <class T> size_t SpdyEstimateMemoryUsageImpl(const T& /*object*/) { return 0; }
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_export_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_export_impl.h
+deleted file mode 100644
+index 1b1c46a816..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_export_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define SPDY_EXPORT
+-#define SPDY_EXPORT_PRIVATE
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_flags_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_flags_impl.h
+deleted file mode 100644
+index b0d690b4bf..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_flags_impl.h
++++ /dev/null
+@@ -1,13 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#define GetSpdyReloadableFlagImpl(flag) quiche::FLAGS_spdy_reloadable_flag_##flag->value()
+-
+-#define GetSpdyRestartFlagImpl(flag) quiche::FLAGS_spdy_restart_flag_##flag->value()
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_logging_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_logging_impl.h
+deleted file mode 100644
+index 4a21b95ab3..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_logging_impl.h
++++ /dev/null
+@@ -1,21 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-#define SPDY_LOG_IMPL(severity) QUIC_LOG_IMPL(severity)
+-
+-#define SPDY_VLOG_IMPL(verbose_level) QUIC_VLOG_IMPL(verbose_level)
+-
+-#define SPDY_DLOG_IMPL(severity) QUIC_DLOG_IMPL(severity)
+-
+-#define SPDY_DLOG_IF_IMPL(severity, condition) QUIC_DLOG_IF_IMPL(severity, condition)
+-
+-#define SPDY_DVLOG_IMPL(verbose_level) QUIC_DVLOG_IMPL(verbose_level)
+-
+-#define SPDY_DVLOG_IF_IMPL(verbose_level, condition) QUIC_DVLOG_IF_IMPL(verbose_level, condition)
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_macros_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_macros_impl.h
+deleted file mode 100644
+index 9b38f29695..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_macros_impl.h
++++ /dev/null
+@@ -1,12 +0,0 @@
+-#pragma once
+-
+-#include "absl/base/attributes.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define SPDY_MUST_USE_RESULT_IMPL ABSL_MUST_USE_RESULT
+-#define SPDY_UNUSED_IMPL ABSL_ATTRIBUTE_UNUSED
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_map_util_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_map_util_impl.h
+deleted file mode 100644
+index befd8c7f8c..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_map_util_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <algorithm>
+-
+-namespace spdy {
+-
+-template <class Collection, class Key>
+-bool SpdyContainsKeyImpl(const Collection& collection, const Key& key) {
+-  return collection.find(key) != collection.end();
+-}
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_mem_slice_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_mem_slice_impl.h
+deleted file mode 100644
+index 76c5ac3550..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_mem_slice_impl.h
++++ /dev/null
+@@ -1,45 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <cstddef>
+-
+-namespace spdy {
+-
+-// TODO(danzh): Fill out SpdyMemSliceImpl.
+-//
+-// SpdyMemSliceImpl wraps a reference counted MemSlice and only provides partial
+-// interfaces of MemSlice.
+-class SpdyMemSliceImpl {
+-public:
+-  // Constructs an empty SpdyMemSliceImpl that contains an empty MemSlice.
+-  SpdyMemSliceImpl();
+-
+-  // Constructs a SpdyMemSlice with reference count 1 to a newly allocated data
+-  // buffer of |length| bytes.
+-  explicit SpdyMemSliceImpl(size_t length);
+-
+-  // Constructs a reference-counted MemSlice to |data|.
+-  SpdyMemSliceImpl(const char* data, size_t length);
+-
+-  SpdyMemSliceImpl(const SpdyMemSliceImpl& other) = delete;
+-  SpdyMemSliceImpl& operator=(const SpdyMemSliceImpl& other) = delete;
+-
+-  // Move constructors. |other| will not hold a reference to the data buffer
+-  // after this call completes.
+-  SpdyMemSliceImpl(SpdyMemSliceImpl&& other) = default;
+-  SpdyMemSliceImpl& operator=(SpdyMemSliceImpl&& other) = default;
+-
+-  ~SpdyMemSliceImpl();
+-
+-  // Returns a char pointer to underlying data buffer.
+-  const char* data() const;
+-  // Returns the length of underlying data buffer.
+-  size_t length() const;
+-};
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_ptr_util_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_ptr_util_impl.h
+deleted file mode 100644
+index 5613f12f5c..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_ptr_util_impl.h
++++ /dev/null
+@@ -1,23 +0,0 @@
+-#pragma once
+-
+-#include <memory>
+-
+-#include "absl/memory/memory.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace spdy {
+-
+-template <typename T, typename... Args> std::unique_ptr<T> SpdyMakeUniqueImpl(Args&&... args) {
+-  return std::make_unique<T>(std::forward<Args>(args)...);
+-}
+-
+-template <typename T> std::unique_ptr<T> SpdyWrapUniqueImpl(T* ptr) {
+-  return absl::WrapUnique<T>(ptr);
+-}
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_string_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_string_impl.h
+deleted file mode 100644
+index a1d5f9500d..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_string_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace spdy {
+-
+-using SpdyStringImpl = std::string;
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_string_piece_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_string_piece_impl.h
+deleted file mode 100644
+index 46e9695bb7..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_string_piece_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-#include "absl/strings/string_view.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace spdy {
+-
+-using SpdyStringPieceImpl = absl::string_view;
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_string_utils_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_string_utils_impl.h
+deleted file mode 100644
+index 20a44e88d1..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_string_utils_impl.h
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/string_utils.h"
+-
+-#include "absl/strings/escaping.h"
+-#include "absl/strings/str_cat.h"
+-#include "absl/strings/str_format.h"
+-#include "fmt/printf.h"
+-
+-namespace spdy {
+-
+-template <typename... Args> inline std::string SpdyStrCatImpl(const Args&... args) {
+-  return absl::StrCat(std::forward<const Args&>(args)...);
+-}
+-
+-template <typename... Args>
+-inline void SpdyStrAppendImpl(std::string* output, const Args&... args) {
+-  absl::StrAppend(output, std::forward<const Args&>(args)...);
+-}
+-
+-inline char SpdyHexDigitToIntImpl(char c) { return quiche::HexDigitToInt(c); }
+-
+-inline std::string SpdyHexDecodeImpl(absl::string_view data) {
+-  return absl::HexStringToBytes(data);
+-}
+-
+-inline bool SpdyHexDecodeToUInt32Impl(absl::string_view data, uint32_t* out) {
+-  return quiche::HexDecodeToUInt32(data, out);
+-}
+-
+-inline std::string SpdyHexEncodeImpl(const void* bytes, size_t size) {
+-  return absl::BytesToHexString(absl::string_view(static_cast<const char*>(bytes), size));
+-}
+-
+-inline std::string SpdyHexEncodeUInt32AndTrimImpl(uint32_t data) {
+-  return absl::StrCat(absl::Hex(data));
+-}
+-
+-inline std::string SpdyHexDumpImpl(absl::string_view data) { return quiche::HexDump(data); }
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
+deleted file mode 100644
+index fa0676be84..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-// TODO: implement
+-#define EXPECT_SPDY_BUG_IMPL 0
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_test_utils_prod_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_test_utils_prod_impl.h
+deleted file mode 100644
+index 70a00ad152..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_test_utils_prod_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-// TODO: implement
+-#define SPDY_FRIEND_TEST_IMPL 0
+diff --git a/source/extensions/quic_listeners/quiche/platform/spdy_unsafe_arena_impl.h b/source/extensions/quic_listeners/quiche/platform/spdy_unsafe_arena_impl.h
+deleted file mode 100644
+index d731d001dc..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/spdy_unsafe_arena_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/spdy/core/spdy_simple_arena.h"
+-
+-namespace spdy {
+-
+-using SpdyUnsafeArenaImpl = SpdySimpleArena;
+-
+-} // namespace spdy
+diff --git a/source/extensions/quic_listeners/quiche/platform/string_utils.cc b/source/extensions/quic_listeners/quiche/platform/string_utils.cc
+deleted file mode 100644
+index 2bcbc11c41..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/string_utils.cc
++++ /dev/null
+@@ -1,96 +0,0 @@
+-#include "extensions/quic_listeners/quiche/platform/string_utils.h"
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <arpa/inet.h>
+-#include <cstring>
+-#include <string>
+-
+-#include "absl/strings/ascii.h"
+-#include "absl/strings/escaping.h"
+-#include "absl/strings/str_format.h"
+-#include "common/common/assert.h"
+-#include "common/common/base64.h"
+-
+-namespace quiche {
+-
+-void Base64Encode(const uint8_t* data, size_t data_len, std::string* output) {
+-  *output =
+-      Envoy::Base64::encode(reinterpret_cast<const char*>(data), data_len, /*add_padding=*/false);
+-}
+-
+-std::string HexDump(absl::string_view data) {
+-  const int kBytesPerLine = 16;
+-  const char* buf = data.data();
+-  int bytes_remaining = data.size();
+-  int offset = 0;
+-  std::string out;
+-  const char* p = buf;
+-  while (bytes_remaining > 0) {
+-    const int line_bytes = std::min(bytes_remaining, kBytesPerLine);
+-    absl::StrAppendFormat(&out, "0x%04x:  ", offset); // Do the line header
+-    for (int i = 0; i < kBytesPerLine; ++i) {
+-      if (i < line_bytes) {
+-        absl::StrAppendFormat(&out, "%02x", p[i]);
+-      } else {
+-        out += "  "; // two-space filler instead of two-space hex digits
+-      }
+-      if (i % 2) {
+-        out += ' ';
+-      }
+-    }
+-    out += ' ';
+-    for (int i = 0; i < line_bytes; ++i) { // Do the ASCII dump
+-      out += absl::ascii_isgraph(p[i]) ? p[i] : '.';
+-    }
+-
+-    bytes_remaining -= line_bytes;
+-    offset += line_bytes;
+-    p += line_bytes;
+-    out += '\n';
+-  }
+-  return out;
+-}
+-
+-char HexDigitToInt(char c) {
+-  ASSERT(std::isxdigit(c));
+-
+-  if (std::isdigit(c)) {
+-    return c - '0';
+-  }
+-  if (c >= 'A' && c <= 'F') {
+-    return c - 'A' + 10;
+-  }
+-  if (c >= 'a' && c <= 'f') {
+-    return c - 'a' + 10;
+-  }
+-  return 0;
+-}
+-
+-bool HexDecodeToUInt32(absl::string_view data, uint32_t* out) {
+-  if (data.empty() || data.size() > 8u) {
+-    return false;
+-  }
+-
+-  for (char c : data) {
+-    if (!absl::ascii_isxdigit(c)) {
+-      return false;
+-    }
+-  }
+-
+-  // Pad with leading zeros.
+-  std::string data_padded(data.data(), data.size());
+-  data_padded.insert(0, 8u - data.size(), '0');
+-
+-  std::string byte_string = absl::HexStringToBytes(data_padded);
+-
+-  ASSERT(byte_string.size() == 4u);
+-  *out = ntohl(*reinterpret_cast<const uint32_t*>(byte_string.c_str()));
+-  return true;
+-}
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/platform/string_utils.h b/source/extensions/quic_listeners/quiche/platform/string_utils.h
+deleted file mode 100644
+index 43ebe1c066..0000000000
+--- a/source/extensions/quic_listeners/quiche/platform/string_utils.h
++++ /dev/null
+@@ -1,25 +0,0 @@
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <cstdint>
+-#include <string>
+-
+-#include "absl/strings/string_view.h"
+-
+-namespace quiche {
+-
+-void Base64Encode(const uint8_t* data, size_t data_len, std::string* output);
+-
+-std::string HexDump(absl::string_view data);
+-
+-// '0' => 0,  '1' => 1, 'a' or 'A' => 10, etc.
+-char HexDigitToInt(char c);
+-
+-// Turns a 8-byte hex string into a uint32 in host byte order.
+-// e.g. "12345678" => 0x12345678
+-bool HexDecodeToUInt32(absl::string_view data, uint32_t* out);
+-
+-} // namespace quiche
+diff --git a/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.cc b/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.cc
+deleted file mode 100644
+index d964414470..0000000000
+--- a/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.cc
++++ /dev/null
+@@ -1,110 +0,0 @@
+-#include "extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h"
+-
+-#include <memory>
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-QuicFilterManagerConnectionImpl::QuicFilterManagerConnectionImpl(
+-    std::unique_ptr<EnvoyQuicConnection> connection, Event::Dispatcher& dispatcher)
+-    : quic_connection_(std::move(connection)), filter_manager_(*this), dispatcher_(dispatcher),
+-      // QUIC connection id can be 18 bytes. It's easier to use hash value instead
+-      // of trying to map it into a 64-bit space.
+-      stream_info_(dispatcher.timeSource()), id_(quic_connection_->connection_id().Hash()) {
+-  // TODO(danzh): Use QUIC specific enum value.
+-  stream_info_.protocol(Http::Protocol::Http2);
+-}
+-
+-void QuicFilterManagerConnectionImpl::addWriteFilter(Network::WriteFilterSharedPtr filter) {
+-  filter_manager_.addWriteFilter(filter);
+-}
+-
+-void QuicFilterManagerConnectionImpl::addFilter(Network::FilterSharedPtr filter) {
+-  filter_manager_.addFilter(filter);
+-}
+-
+-void QuicFilterManagerConnectionImpl::addReadFilter(Network::ReadFilterSharedPtr filter) {
+-  filter_manager_.addReadFilter(filter);
+-}
+-
+-bool QuicFilterManagerConnectionImpl::initializeReadFilters() {
+-  return filter_manager_.initializeReadFilters();
+-}
+-
+-void QuicFilterManagerConnectionImpl::addConnectionCallbacks(Network::ConnectionCallbacks& cb) {
+-  network_connection_callbacks_.push_back(&cb);
+-}
+-
+-void QuicFilterManagerConnectionImpl::enableHalfClose(bool enabled) {
+-  RELEASE_ASSERT(!enabled, "Quic connection doesn't support half close.");
+-}
+-
+-void QuicFilterManagerConnectionImpl::setBufferLimits(uint32_t /*limit*/) {
+-  // TODO(danzh): add interface to quic for connection level buffer throttling.
+-  // Currently read buffer is capped by connection level flow control. And
+-  // write buffer is not capped.
+-  NOT_REACHED_GCOVR_EXCL_LINE;
+-}
+-
+-void QuicFilterManagerConnectionImpl::close(Network::ConnectionCloseType type) {
+-  if (type != Network::ConnectionCloseType::NoFlush) {
+-    // TODO(danzh): Implement FlushWrite and FlushWriteAndDelay mode.
+-  }
+-  quic_connection_->CloseConnection(quic::QUIC_NO_ERROR, "Closed by application",
+-                                    quic::ConnectionCloseBehavior::SEND_CONNECTION_CLOSE_PACKET);
+-}
+-
+-void QuicFilterManagerConnectionImpl::setDelayedCloseTimeout(std::chrono::milliseconds timeout) {
+-  if (timeout != std::chrono::milliseconds::zero()) {
+-    // TODO(danzh) support delayed close of connection.
+-    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-  }
+-}
+-
+-const Network::ConnectionSocket::OptionsSharedPtr&
+-QuicFilterManagerConnectionImpl::socketOptions() const {
+-  return quic_connection_->connectionSocket()->options();
+-}
+-
+-const Network::Address::InstanceConstSharedPtr&
+-QuicFilterManagerConnectionImpl::remoteAddress() const {
+-  ASSERT(quic_connection_->connectionSocket() != nullptr,
+-         "remoteAddress() should only be called after OnPacketHeader");
+-  return quic_connection_->connectionSocket()->remoteAddress();
+-}
+-
+-const Network::Address::InstanceConstSharedPtr&
+-QuicFilterManagerConnectionImpl::localAddress() const {
+-  ASSERT(quic_connection_->connectionSocket() != nullptr,
+-         "localAddress() should only be called after OnPacketHeader");
+-  return quic_connection_->connectionSocket()->localAddress();
+-}
+-
+-Ssl::ConnectionInfoConstSharedPtr QuicFilterManagerConnectionImpl::ssl() const {
+-  // TODO(danzh): construct Ssl::ConnectionInfo from crypto stream
+-  return nullptr;
+-}
+-
+-void QuicFilterManagerConnectionImpl::rawWrite(Buffer::Instance& /*data*/, bool /*end_stream*/) {
+-  // Network filter should stop iteration.
+-  NOT_REACHED_GCOVR_EXCL_LINE;
+-}
+-
+-void QuicFilterManagerConnectionImpl::onConnectionCloseEvent(
+-    const quic::QuicConnectionCloseFrame& frame, quic::ConnectionCloseSource source) {
+-  // Tell network callbacks about connection close.
+-  raiseEvent(source == quic::ConnectionCloseSource::FROM_PEER
+-                 ? Network::ConnectionEvent::RemoteClose
+-                 : Network::ConnectionEvent::LocalClose);
+-  transport_failure_reason_ = absl::StrCat(quic::QuicErrorCodeToString(frame.quic_error_code),
+-                                           " with details: ", frame.error_details);
+-}
+-
+-void QuicFilterManagerConnectionImpl::raiseEvent(Network::ConnectionEvent event) {
+-  for (auto callback : network_connection_callbacks_) {
+-    callback->onEvent(event);
+-  }
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h b/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h
+deleted file mode 100644
+index b7f1d2b50b..0000000000
+--- a/source/extensions/quic_listeners/quiche/quic_filter_manager_connection_impl.h
++++ /dev/null
+@@ -1,126 +0,0 @@
+-#pragma once
+-
+-#include "envoy/event/dispatcher.h"
+-#include "envoy/network/connection.h"
+-
+-#include "common/common/empty_string.h"
+-#include "common/common/logger.h"
+-#include "common/network/filter_manager_impl.h"
+-#include "common/stream_info/stream_info_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Act as a Network::Connection to HCM and a FilterManager to FilterFactoryCb.
+-class QuicFilterManagerConnectionImpl : public Network::FilterManagerConnection,
+-                                        protected Logger::Loggable<Logger::Id::connection> {
+-public:
+-  QuicFilterManagerConnectionImpl(std::unique_ptr<EnvoyQuicConnection> connection,
+-                                  Event::Dispatcher& dispatcher);
+-
+-  // Network::FilterManager
+-  // Overridden to delegate calls to filter_manager_.
+-  void addWriteFilter(Network::WriteFilterSharedPtr filter) override;
+-  void addFilter(Network::FilterSharedPtr filter) override;
+-  void addReadFilter(Network::ReadFilterSharedPtr filter) override;
+-  bool initializeReadFilters() override;
+-
+-  // Network::Connection
+-  void addConnectionCallbacks(Network::ConnectionCallbacks& cb) override;
+-  void addBytesSentCallback(Network::Connection::BytesSentCb /*cb*/) override {
+-    // TODO(danzh): implement to support proxy. This interface is only called from
+-    // TCP proxy code.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  void enableHalfClose(bool enabled) override;
+-  void close(Network::ConnectionCloseType type) override;
+-  Event::Dispatcher& dispatcher() override { return dispatcher_; }
+-  uint64_t id() const override { return id_; }
+-  std::string nextProtocol() const override { return EMPTY_STRING; }
+-  void noDelay(bool /*enable*/) override {
+-    // No-op. TCP_NODELAY doesn't apply to UDP.
+-  }
+-  void setDelayedCloseTimeout(std::chrono::milliseconds timeout) override;
+-  void readDisable(bool /*disable*/) override { NOT_REACHED_GCOVR_EXCL_LINE; }
+-  void detectEarlyCloseWhenReadDisabled(bool /*value*/) override { NOT_REACHED_GCOVR_EXCL_LINE; }
+-  bool readEnabled() const override { return true; }
+-  const Network::Address::InstanceConstSharedPtr& remoteAddress() const override;
+-  const Network::Address::InstanceConstSharedPtr& localAddress() const override;
+-  absl::optional<Network::Connection::UnixDomainSocketPeerCredentials>
+-  unixSocketPeerCredentials() const override {
+-    // Unix domain socket is not supported.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  void setConnectionStats(const Network::Connection::ConnectionStats& stats) override {
+-    stats_ = std::make_unique<Network::Connection::ConnectionStats>(stats);
+-    quic_connection_->setConnectionStats(stats);
+-  }
+-  Ssl::ConnectionInfoConstSharedPtr ssl() const override;
+-  Network::Connection::State state() const override {
+-    return quic_connection_->connected() ? Network::Connection::State::Open
+-                                         : Network::Connection::State::Closed;
+-  }
+-  void write(Buffer::Instance& /*data*/, bool /*end_stream*/) override {
+-    // All writes should be handled by Quic internally.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  void setBufferLimits(uint32_t limit) override;
+-  uint32_t bufferLimit() const override {
+-    // As quic connection is not HTTP1.1, this method shouldn't be called by HCM.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  bool localAddressRestored() const override {
+-    // SO_ORIGINAL_DST not supported by QUIC.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  bool aboveHighWatermark() const override {
+-    // TODO(danzh) Aggregate the write buffer usage cross all the streams and
+-    // add an upper limit for this connection.
+-    NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-  }
+-  const Network::ConnectionSocket::OptionsSharedPtr& socketOptions() const override;
+-  StreamInfo::StreamInfo& streamInfo() override { return stream_info_; }
+-  const StreamInfo::StreamInfo& streamInfo() const override { return stream_info_; }
+-  absl::string_view transportFailureReason() const override { return transport_failure_reason_; }
+-
+-  // Network::FilterManagerConnection
+-  void rawWrite(Buffer::Instance& data, bool end_stream) override;
+-
+-  // Network::ReadBufferSource
+-  Network::StreamBuffer getReadBuffer() override {
+-    // Network filter has to stop iteration to prevent hitting this line.
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  // Network::WriteBufferSource
+-  Network::StreamBuffer getWriteBuffer() override { NOT_REACHED_GCOVR_EXCL_LINE; }
+-
+-protected:
+-  // Propagate connection close to network_connection_callbacks_.
+-  void onConnectionCloseEvent(const quic::QuicConnectionCloseFrame& frame,
+-                              quic::ConnectionCloseSource source);
+-
+-  void raiseEvent(Network::ConnectionEvent event);
+-
+-  std::unique_ptr<EnvoyQuicConnection> quic_connection_;
+-  // TODO(danzh): populate stats.
+-  std::unique_ptr<Network::Connection::ConnectionStats> stats_;
+-
+-private:
+-  // Currently ConnectionManagerImpl is the one and only filter. If more network
+-  // filters are added, ConnectionManagerImpl should always be the last one.
+-  // Its onRead() is only called once to trigger ReadFilter::onNewConnection()
+-  // and the rest incoming data bypasses these filters.
+-  Network::FilterManagerImpl filter_manager_;
+-  Event::Dispatcher& dispatcher_;
+-  StreamInfo::StreamInfoImpl stream_info_;
+-  // These callbacks are owned by network filters and quic session should out live
+-  // them.
+-  std::list<Network::ConnectionCallbacks*> network_connection_callbacks_;
+-  std::string transport_failure_reason_;
+-  const uint64_t id_;
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/quic_io_handle_wrapper.h b/source/extensions/quic_listeners/quiche/quic_io_handle_wrapper.h
+deleted file mode 100644
+index 231f1bf08b..0000000000
+--- a/source/extensions/quic_listeners/quiche/quic_io_handle_wrapper.h
++++ /dev/null
+@@ -1,68 +0,0 @@
+-#include "envoy/network/io_handle.h"
+-
+-#include "common/network/io_socket_error_impl.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// A wrapper class around IoHandle object which doesn't close() upon destruction. It is used to
+-// create ConnectionSocket as the actual IoHandle instance should out live connection socket.
+-class QuicIoHandleWrapper : public Network::IoHandle {
+-public:
+-  QuicIoHandleWrapper(Network::IoHandle& io_handle) : io_handle_(io_handle) {}
+-
+-  // Network::IoHandle
+-  int fd() const override { return io_handle_.fd(); }
+-  Api::IoCallUint64Result close() override {
+-    closed_ = true;
+-    return Api::ioCallUint64ResultNoError();
+-  }
+-  bool isOpen() const override { return !closed_; }
+-  Api::IoCallUint64Result readv(uint64_t max_length, Buffer::RawSlice* slices,
+-                                uint64_t num_slice) override {
+-    if (closed_) {
+-      return Api::IoCallUint64Result(0, Api::IoErrorPtr(new Network::IoSocketError(EBADF),
+-                                                        Network::IoSocketError::deleteIoError));
+-    }
+-    return io_handle_.readv(max_length, slices, num_slice);
+-  }
+-  Api::IoCallUint64Result writev(const Buffer::RawSlice* slices, uint64_t num_slice) override {
+-    if (closed_) {
+-      return Api::IoCallUint64Result(0, Api::IoErrorPtr(new Network::IoSocketError(EBADF),
+-                                                        Network::IoSocketError::deleteIoError));
+-    }
+-    return io_handle_.writev(slices, num_slice);
+-  }
+-  Api::IoCallUint64Result sendto(const Buffer::RawSlice& slice, int flags,
+-                                 const Network::Address::Instance& address) override {
+-    if (closed_) {
+-      return Api::IoCallUint64Result(0, Api::IoErrorPtr(new Network::IoSocketError(EBADF),
+-                                                        Network::IoSocketError::deleteIoError));
+-    }
+-    return io_handle_.sendto(slice, flags, address);
+-  }
+-  Api::IoCallUint64Result sendmsg(const Buffer::RawSlice* slices, uint64_t num_slice, int flags,
+-                                  const Envoy::Network::Address::Ip* self_ip,
+-                                  const Network::Address::Instance& peer_address) override {
+-    if (closed_) {
+-      return Api::IoCallUint64Result(0, Api::IoErrorPtr(new Network::IoSocketError(EBADF),
+-                                                        Network::IoSocketError::deleteIoError));
+-    }
+-    return io_handle_.sendmsg(slices, num_slice, flags, self_ip, peer_address);
+-  }
+-  Api::IoCallUint64Result recvmsg(Buffer::RawSlice* slices, const uint64_t num_slice,
+-                                  uint32_t self_port, RecvMsgOutput& output) override {
+-    if (closed_) {
+-      return Api::IoCallUint64Result(0, Api::IoErrorPtr(new Network::IoSocketError(EBADF),
+-                                                        Network::IoSocketError::deleteIoError));
+-    }
+-    return io_handle_.recvmsg(slices, num_slice, self_port, output);
+-  }
+-
+-private:
+-  Network::IoHandle& io_handle_;
+-  bool closed_{false};
+-};
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.cc b/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.cc
+deleted file mode 100644
+index 606739e7ca..0000000000
+--- a/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.cc
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#include "extensions/quic_listeners/quiche/quic_transport_socket_factory.h"
+-
+-#include "envoy/api/v2/auth/cert.pb.h"
+-#include "envoy/api/v2/auth/cert.pb.validate.h"
+-
+-#include "extensions/transport_sockets/tls/context_config_impl.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-Network::TransportSocketFactoryPtr
+-QuicServerTransportSocketConfigFactory::createTransportSocketFactory(
+-    const Protobuf::Message& config, Server::Configuration::TransportSocketFactoryContext& context,
+-    const std::vector<std::string>& /*server_names*/) {
+-  auto server_config = std::make_unique<Extensions::TransportSockets::Tls::ServerContextConfigImpl>(
+-      MessageUtil::downcastAndValidate<const envoy::api::v2::auth::DownstreamTlsContext&>(
+-          config, context.messageValidationVisitor()),
+-      context);
+-  return std::make_unique<QuicServerTransportSocketFactory>(std::move(server_config));
+-}
+-
+-ProtobufTypes::MessagePtr QuicServerTransportSocketConfigFactory::createEmptyConfigProto() {
+-  return std::make_unique<envoy::api::v2::auth::DownstreamTlsContext>();
+-}
+-
+-Network::TransportSocketFactoryPtr
+-QuicClientTransportSocketConfigFactory::createTransportSocketFactory(
+-    const Protobuf::Message& config,
+-    Server::Configuration::TransportSocketFactoryContext& context) {
+-  auto client_config = std::make_unique<Extensions::TransportSockets::Tls::ClientContextConfigImpl>(
+-      MessageUtil::downcastAndValidate<const envoy::api::v2::auth::UpstreamTlsContext&>(
+-          config, context.messageValidationVisitor()),
+-      context);
+-  return std::make_unique<QuicClientTransportSocketFactory>(std::move(client_config));
+-}
+-
+-ProtobufTypes::MessagePtr QuicClientTransportSocketConfigFactory::createEmptyConfigProto() {
+-  return std::make_unique<envoy::api::v2::auth::UpstreamTlsContext>();
+-}
+-
+-REGISTER_FACTORY(QuicServerTransportSocketConfigFactory,
+-                 Server::Configuration::DownstreamTransportSocketConfigFactory);
+-
+-REGISTER_FACTORY(QuicClientTransportSocketConfigFactory,
+-                 Server::Configuration::UpstreamTransportSocketConfigFactory);
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.h b/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.h
+deleted file mode 100644
+index e254692df4..0000000000
+--- a/source/extensions/quic_listeners/quiche/quic_transport_socket_factory.h
++++ /dev/null
+@@ -1,94 +0,0 @@
+-#include "envoy/network/transport_socket.h"
+-#include "envoy/server/transport_socket_config.h"
+-#include "envoy/ssl/context_config.h"
+-
+-#include "common/common/assert.h"
+-
+-#include "extensions/transport_sockets/well_known_names.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-// Base class for QUIC transport socket factory.
+-// Because QUIC stack handles all L4 data, there is no need of a real transport
+-// socket for QUIC in current implementation. This factory doesn't provides a
+-// transport socket, instead, its derived class provides TLS context config for
+-// server and client.
+-class QuicTransportSocketFactoryBase : public Network::TransportSocketFactory {
+-public:
+-  // Network::TransportSocketFactory
+-  Network::TransportSocketPtr
+-  createTransportSocket(Network::TransportSocketOptionsSharedPtr /*options*/) const override {
+-    NOT_REACHED_GCOVR_EXCL_LINE;
+-  }
+-  bool implementsSecureTransport() const override { return true; }
+-};
+-
+-// TODO(danzh): when implement ProofSource, examine of it's necessary to
+-// differentiate server and client side context config.
+-class QuicServerTransportSocketFactory : public QuicTransportSocketFactoryBase {
+-public:
+-  QuicServerTransportSocketFactory(Ssl::ServerContextConfigPtr config)
+-      : config_(std::move(config)) {}
+-
+-  const Ssl::ServerContextConfig& serverContextConfig() const { return *config_; }
+-
+-private:
+-  std::unique_ptr<const Ssl::ServerContextConfig> config_;
+-};
+-
+-class QuicClientTransportSocketFactory : public QuicTransportSocketFactoryBase {
+-public:
+-  QuicClientTransportSocketFactory(Envoy::Ssl::ClientContextConfigPtr config)
+-      : config_(std::move(config)) {}
+-
+-  const Ssl::ClientContextConfig& clientContextConfig() const { return *config_; }
+-
+-private:
+-  std::unique_ptr<const Ssl::ClientContextConfig> config_;
+-};
+-
+-// Base class to create above QuicTransportSocketFactory for server and client
+-// side.
+-class QuicTransportSocketConfigFactory
+-    : public virtual Server::Configuration::TransportSocketConfigFactory {
+-public:
+-  // Server::Configuration::TransportSocketConfigFactory
+-  std::string name() const override {
+-    return Extensions::TransportSockets::TransportSocketNames::get().Quic;
+-  }
+-};
+-
+-class QuicServerTransportSocketConfigFactory
+-    : public QuicTransportSocketConfigFactory,
+-      public Server::Configuration::DownstreamTransportSocketConfigFactory {
+-public:
+-  // Server::Configuration::DownstreamTransportSocketConfigFactory
+-  Network::TransportSocketFactoryPtr
+-  createTransportSocketFactory(const Protobuf::Message& config,
+-                               Server::Configuration::TransportSocketFactoryContext& context,
+-                               const std::vector<std::string>& server_names) override;
+-
+-  // Server::Configuration::TransportSocketConfigFactory
+-  ProtobufTypes::MessagePtr createEmptyConfigProto() override;
+-};
+-
+-DECLARE_FACTORY(QuicServerTransportSocketConfigFactory);
+-
+-class QuicClientTransportSocketConfigFactory
+-    : public QuicTransportSocketConfigFactory,
+-      public Server::Configuration::UpstreamTransportSocketConfigFactory {
+-public:
+-  // Server::Configuration::UpstreamTransportSocketConfigFactory
+-  Network::TransportSocketFactoryPtr createTransportSocketFactory(
+-      const Protobuf::Message& config,
+-      Server::Configuration::TransportSocketFactoryContext& context) override;
+-
+-  // Server::Configuration::TransportSocketConfigFactory
+-  ProtobufTypes::MessagePtr createEmptyConfigProto() override;
+-};
+-
+-DECLARE_FACTORY(QuicClientTransportSocketConfigFactory);
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/source/extensions/quic_listeners/quiche/spdy_server_push_utils_for_envoy.cc b/source/extensions/quic_listeners/quiche/spdy_server_push_utils_for_envoy.cc
+deleted file mode 100644
+index 0ff435226e..0000000000
+--- a/source/extensions/quic_listeners/quiche/spdy_server_push_utils_for_envoy.cc
++++ /dev/null
+@@ -1,37 +0,0 @@
+-#include "quiche/quic/core/http/spdy_server_push_utils.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file has a substitute definition for
+-// quiche/quic/core/http/spdy_server_push_utils.cc which depends on GURL.
+-// Since Envoy doesn't support server push, these functions shouldn't be
+-// executed at all.
+-
+-using spdy::SpdyHeaderBlock;
+-
+-namespace quic {
+-
+-// static
+-std::string SpdyServerPushUtils::GetPromisedUrlFromHeaders(const SpdyHeaderBlock& /*headers*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-// static
+-std::string
+-SpdyServerPushUtils::GetPromisedHostNameFromHeaders(const SpdyHeaderBlock& /*headers*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-// static
+-bool SpdyServerPushUtils::PromisedUrlIsValid(const SpdyHeaderBlock& /*headers*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-// static
+-std::string SpdyServerPushUtils::GetPushPromiseUrl(QuicStringPiece /*scheme*/,
+-                                                   QuicStringPiece /*authority*/,
+-                                                   QuicStringPiece /*path*/) {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE;
+-}
+-
+-} // namespace quic
+diff --git a/source/extensions/transport_sockets/tls/BUILD b/source/extensions/transport_sockets/tls/BUILD
+index cdc81bb516..9c3ab7ac18 100644
+--- a/source/extensions/transport_sockets/tls/BUILD
++++ b/source/extensions/transport_sockets/tls/BUILD
+@@ -31,6 +31,7 @@ envoy_cc_library(
+         "abseil_optional",
+         "abseil_synchronization",
+         "ssl",
++        "bssl_wrapper_lib",
+     ],
+     deps = [
+         ":context_config_lib",
+@@ -86,8 +87,10 @@ envoy_cc_library(
+     external_deps = [
+         "abseil_synchronization",
+         "ssl",
++        "bssl_wrapper_lib",
+     ],
+     deps = [
++        ":openssl_impl_lib",
+         ":utility_lib",
+         "//include/envoy/ssl:context_config_interface",
+         "//include/envoy/ssl:context_interface",
+@@ -113,9 +116,25 @@ envoy_cc_library(
+     hdrs = ["utility.h"],
+     external_deps = [
+         "ssl",
++        "bssl_wrapper_lib",
+     ],
+     deps = [
++        ":openssl_impl_lib",
+         "//source/common/common:assert_lib",
+         "//source/common/common:utility_lib",
+     ],
+ )
++
++envoy_cc_library(
++    name = "openssl_impl_lib",
++    srcs = [
++        "openssl_impl.cc",
++    ],
++    hdrs = [
++        "openssl_impl.h",
++    ],
++    external_deps = [
++        "ssl",
++        "bssl_wrapper_lib",
++    ],
++)
+diff --git a/source/extensions/transport_sockets/tls/context_config_impl.cc b/source/extensions/transport_sockets/tls/context_config_impl.cc
+index a3f2704dee..9e74147013 100644
+--- a/source/extensions/transport_sockets/tls/context_config_impl.cc
++++ b/source/extensions/transport_sockets/tls/context_config_impl.cc
+@@ -283,13 +283,8 @@ const unsigned ClientContextConfigImpl::DEFAULT_MIN_VERSION = TLS1_VERSION;
+ const unsigned ClientContextConfigImpl::DEFAULT_MAX_VERSION = TLS1_2_VERSION;
+ 
+ const std::string ClientContextConfigImpl::DEFAULT_CIPHER_SUITES =
+-#ifndef BORINGSSL_FIPS
+     "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]:"
+     "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]:"
+-#else // BoringSSL FIPS
+-    "ECDHE-ECDSA-AES128-GCM-SHA256:"
+-    "ECDHE-RSA-AES128-GCM-SHA256:"
+-#endif
+     "ECDHE-ECDSA-AES128-SHA:"
+     "ECDHE-RSA-AES128-SHA:"
+     "AES128-GCM-SHA256:"
+@@ -301,12 +296,8 @@ const std::string ClientContextConfigImpl::DEFAULT_CIPHER_SUITES =
+     "AES256-GCM-SHA384:"
+     "AES256-SHA";
+ 
+-const std::string ClientContextConfigImpl::DEFAULT_CURVES =
+-#ifndef BORINGSSL_FIPS
+-    "X25519:"
+-#endif
+-    "P-256";
+-
++const std::string ClientContextConfigImpl::DEFAULT_CURVES = "X25519:"
++                                                            "P-256";
+ ClientContextConfigImpl::ClientContextConfigImpl(
+     const envoy::api::v2::auth::UpstreamTlsContext& config, absl::string_view sigalgs,
+     Server::Configuration::TransportSocketFactoryContext& factory_context)
+@@ -328,21 +319,11 @@ ClientContextConfigImpl::ClientContextConfigImpl(
+ }
+ 
+ const unsigned ServerContextConfigImpl::DEFAULT_MIN_VERSION = TLS1_VERSION;
+-const unsigned ServerContextConfigImpl::DEFAULT_MAX_VERSION =
+-#ifndef BORINGSSL_FIPS
+-    TLS1_3_VERSION;
+-#else // BoringSSL FIPS
+-    TLS1_2_VERSION;
+-#endif
++const unsigned ServerContextConfigImpl::DEFAULT_MAX_VERSION = TLS1_3_VERSION;
+ 
+ const std::string ServerContextConfigImpl::DEFAULT_CIPHER_SUITES =
+-#ifndef BORINGSSL_FIPS
+     "[ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]:"
+     "[ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]:"
+-#else // BoringSSL FIPS
+-    "ECDHE-ECDSA-AES128-GCM-SHA256:"
+-    "ECDHE-RSA-AES128-GCM-SHA256:"
+-#endif
+     "ECDHE-ECDSA-AES128-SHA:"
+     "ECDHE-RSA-AES128-SHA:"
+     "AES128-GCM-SHA256:"
+@@ -354,11 +335,8 @@ const std::string ServerContextConfigImpl::DEFAULT_CIPHER_SUITES =
+     "AES256-GCM-SHA384:"
+     "AES256-SHA";
+ 
+-const std::string ServerContextConfigImpl::DEFAULT_CURVES =
+-#ifndef BORINGSSL_FIPS
+-    "X25519:"
+-#endif
+-    "P-256";
++const std::string ServerContextConfigImpl::DEFAULT_CURVES = "X25519:"
++                                                            "P-256";
+ 
+ ServerContextConfigImpl::ServerContextConfigImpl(
+     const envoy::api::v2::auth::DownstreamTlsContext& config,
+diff --git a/source/extensions/transport_sockets/tls/context_config_impl.h b/source/extensions/transport_sockets/tls/context_config_impl.h
+index 89eec432ce..bf3b84328d 100644
+--- a/source/extensions/transport_sockets/tls/context_config_impl.h
++++ b/source/extensions/transport_sockets/tls/context_config_impl.h
+@@ -103,6 +103,9 @@ public:
+       const envoy::api::v2::auth::UpstreamTlsContext& config,
+       Server::Configuration::TransportSocketFactoryContext& secret_provider_context)
+       : ClientContextConfigImpl(config, "", secret_provider_context) {}
++  ClientContextConfigImpl(
++      const Json::Object& config,
++      Server::Configuration::TransportSocketFactoryContext& secret_provider_context);
+ 
+   // Ssl::ClientContextConfig
+   const std::string& serverNameIndication() const override { return server_name_indication_; }
+@@ -127,6 +130,9 @@ public:
+   ServerContextConfigImpl(
+       const envoy::api::v2::auth::DownstreamTlsContext& config,
+       Server::Configuration::TransportSocketFactoryContext& secret_provider_context);
++  ServerContextConfigImpl(
++      const Json::Object& config,
++      Server::Configuration::TransportSocketFactoryContext& secret_provider_context);
+   ~ServerContextConfigImpl() override;
+ 
+   // Ssl::ServerContextConfig
+diff --git a/source/extensions/transport_sockets/tls/context_impl.cc b/source/extensions/transport_sockets/tls/context_impl.cc
+index ed8e54c084..a50f275e11 100644
+--- a/source/extensions/transport_sockets/tls/context_impl.cc
++++ b/source/extensions/transport_sockets/tls/context_impl.cc
+@@ -18,8 +18,10 @@
+ #include "common/network/address_impl.h"
+ #include "common/protobuf/utility.h"
+ 
++#include "extensions/transport_sockets/tls/openssl_impl.h"
+ #include "extensions/transport_sockets/tls/utility.h"
+ 
++#include "openssl/err.h"
+ #include "openssl/evp.h"
+ #include "openssl/hmac.h"
+ #include "openssl/rand.h"
+@@ -30,24 +32,6 @@ namespace Extensions {
+ namespace TransportSockets {
+ namespace Tls {
+ 
+-namespace {
+-
+-bool cbsContainsU16(CBS& cbs, uint16_t n) {
+-  while (CBS_len(&cbs) > 0) {
+-    uint16_t v;
+-    if (!CBS_get_u16(&cbs, &v)) {
+-      return false;
+-    }
+-    if (v == n) {
+-      return true;
+-    }
+-  }
+-
+-  return false;
+-}
+-
+-} // namespace
+-
+ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& config,
+                          TimeSource& time_source)
+     : scope_(scope), stats_(generateStats(scope)), time_source_(time_source),
+@@ -62,38 +46,41 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+       ssl_curves_(stat_name_set_->add("ssl.curves")),
+       ssl_sigalgs_(stat_name_set_->add("ssl.sigalgs")) {
+   const auto tls_certificates = config.tlsCertificates();
+-  tls_contexts_.resize(std::max(static_cast<size_t>(1), tls_certificates.size()));
++  int rc = 0;
+ 
+-  for (auto& ctx : tls_contexts_) {
+-    ctx.ssl_ctx_.reset(SSL_CTX_new(TLS_method()));
++  tls_context_.ssl_ctx_.reset(SSL_CTX_new(TLS_method()));
+ 
+-    int rc = SSL_CTX_set_app_data(ctx.ssl_ctx_.get(), this);
+-    RELEASE_ASSERT(rc == 1, "");
++  rc = SSL_CTX_set_app_data(tls_context_.ssl_ctx_.get(), this);
++  RELEASE_ASSERT(rc == 1, "");
+ 
+-    rc = SSL_CTX_set_min_proto_version(ctx.ssl_ctx_.get(), config.minProtocolVersion());
+-    RELEASE_ASSERT(rc == 1, "");
++  rc = SSL_CTX_set_min_proto_version(tls_context_.ssl_ctx_.get(), config.minProtocolVersion());
++  RELEASE_ASSERT(rc == 1, "");
+ 
+-    rc = SSL_CTX_set_max_proto_version(ctx.ssl_ctx_.get(), config.maxProtocolVersion());
+-    RELEASE_ASSERT(rc == 1, "");
++  rc = SSL_CTX_set_max_proto_version(tls_context_.ssl_ctx_.get(), config.maxProtocolVersion());
++  RELEASE_ASSERT(rc == 1, "");
+ 
+-    if (!SSL_CTX_set_strict_cipher_list(ctx.ssl_ctx_.get(), config.cipherSuites().c_str())) {
+-      std::vector<absl::string_view> ciphers =
+-          StringUtil::splitToken(config.cipherSuites(), ":+-![|]", false);
+-      std::vector<std::string> bad_ciphers;
+-      for (const auto& cipher : ciphers) {
+-        std::string cipher_str(cipher);
+-        if (!SSL_CTX_set_strict_cipher_list(ctx.ssl_ctx_.get(), cipher_str.c_str())) {
++  if (!Envoy::Extensions::TransportSockets::Tls::set_strict_cipher_list(
++          tls_context_.ssl_ctx_.get(), config.cipherSuites().c_str())) {
++     std::vector<absl::string_view> ciphers =
++        StringUtil::splitToken(config.cipherSuites(), ":+![|]", false);
++
++    std::vector<std::string> bad_ciphers;
++    for (const auto& cipher : ciphers) {
++      std::string cipher_str(cipher);
++      if (cipher_str.compare("-ALL") && cipher_str.compare("ALL")) {
++        if (!Envoy::Extensions::TransportSockets::Tls::set_strict_cipher_list(
++                tls_context_.ssl_ctx_.get(), cipher_str.c_str())) {
+           bad_ciphers.push_back(cipher_str);
+         }
+       }
+-      throw EnvoyException(fmt::format("Failed to initialize cipher suites {}. The following "
+-                                       "ciphers were rejected when tried individually: {}",
+-                                       config.cipherSuites(), StringUtil::join(bad_ciphers, ", ")));
+     }
++    throw EnvoyException(fmt::format("Failed to initialize cipher suites {}. The following "
++                                     "ciphers were rejected when tried individually: {}",
++                                     config.cipherSuites(), StringUtil::join(bad_ciphers, ", ")));
++  }
+ 
+-    if (!SSL_CTX_set1_curves_list(ctx.ssl_ctx_.get(), config.ecdhCurves().c_str())) {
+-      throw EnvoyException(fmt::format("Failed to initialize ECDH curves {}", config.ecdhCurves()));
+-    }
++  if (!SSL_CTX_set1_curves_list(tls_context_.ssl_ctx_.get(), config.ecdhCurves().c_str())) {
++    throw EnvoyException(fmt::format("Failed to initialize ECDH curves {}", config.ecdhCurves()));
+   }
+ 
+   int verify_mode = SSL_VERIFY_NONE;
+@@ -112,39 +99,41 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+                                        config.certificateValidationContext()->caCertPath()));
+     }
+ 
+-    for (auto& ctx : tls_contexts_) {
+-      X509_STORE* store = SSL_CTX_get_cert_store(ctx.ssl_ctx_.get());
+-      bool has_crl = false;
+-      for (const X509_INFO* item : list.get()) {
+-        if (item->x509) {
+-          X509_STORE_add_cert(store, item->x509);
+-          if (ca_cert_ == nullptr) {
+-            X509_up_ref(item->x509);
+-            ca_cert_.reset(item->x509);
+-          }
+-        }
+-        if (item->crl) {
+-          X509_STORE_add_crl(store, item->crl);
+-          has_crl = true;
++    X509_STORE* store = SSL_CTX_get_cert_store(tls_context_.ssl_ctx_.get());
++    bool has_crl = false;
++    for (const X509_INFO* item : list.get()) {
++      if (item->x509) {
++        X509_STORE_add_cert(store, item->x509);
++        if (ca_cert_ == nullptr) {
++          X509_up_ref(item->x509);
++          ca_cert_.reset(item->x509);
+         }
+       }
+-      if (ca_cert_ == nullptr) {
+-        throw EnvoyException(fmt::format("Failed to load trusted CA certificates from {}",
+-                                         config.certificateValidationContext()->caCertPath()));
+-      }
+-      if (has_crl) {
+-        X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
+-      }
+-      verify_mode = SSL_VERIFY_PEER;
+-      verify_trusted_ca_ = true;
+-
+-      // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()
+-      // directly. However, our new callback is still calling X509_verify_cert() under
+-      // the hood. Therefore, to ignore cert expiration, we need to set the callback
+-      // for X509_verify_cert to ignore that error.
+-      if (config.certificateValidationContext()->allowExpiredCertificate()) {
+-        X509_STORE_set_verify_cb(store, ContextImpl::ignoreCertificateExpirationCallback);
++      if (item->crl) {
++        X509_STORE_add_crl(store, item->crl);
++        has_crl = true;
+       }
++
++      // (dmitri-d) why do we do this here? Upstream doesn't
++      Envoy::Extensions::TransportSockets::Tls::ssl_ctx_add_client_CA(tls_context_.ssl_ctx_.get(),
++                                                                        item->x509);
++    }
++    if (ca_cert_ == nullptr) {
++      throw EnvoyException(fmt::format("Failed to load trusted CA certificates from {}",
++                                       config.certificateValidationContext()->caCertPath()));
++    }
++    if (has_crl) {
++      X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
++    }
++    verify_mode = SSL_VERIFY_PEER;
++    verify_trusted_ca_ = true;
++
++    // NOTE: We're using SSL_CTX_set_cert_verify_callback() instead of X509_verify_cert()
++    // directly. However, our new callback is still calling X509_verify_cert() under
++    // the hood. Therefore, to ignore cert expiration, we need to set the callback
++    // for X509_verify_cert to ignore that error.
++    if (config.certificateValidationContext()->allowExpiredCertificate()) {
++      X509_STORE_set_verify_cb(store, ContextImpl::ignoreCertificateExpirationCallback);
+     }
+   }
+ 
+@@ -165,16 +154,14 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+                       config.certificateValidationContext()->certificateRevocationListPath()));
+     }
+ 
+-    for (auto& ctx : tls_contexts_) {
+-      X509_STORE* store = SSL_CTX_get_cert_store(ctx.ssl_ctx_.get());
+-      for (const X509_INFO* item : list.get()) {
+-        if (item->crl) {
+-          X509_STORE_add_crl(store, item->crl);
+-        }
++    X509_STORE* store = SSL_CTX_get_cert_store(tls_context_.ssl_ctx_.get());
++    for (const X509_INFO* item : list.get()) {
++      if (item->crl) {
++        X509_STORE_add_crl(store, item->crl);
+       }
+-
+-      X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
+     }
++
++    X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL);
+   }
+ 
+   if (config.certificateValidationContext() != nullptr &&
+@@ -213,43 +200,42 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+     verify_mode = SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+   }
+ 
+-  for (auto& ctx : tls_contexts_) {
+-    if (verify_mode != SSL_VERIFY_NONE) {
+-      SSL_CTX_set_verify(ctx.ssl_ctx_.get(), verify_mode, nullptr);
+-      SSL_CTX_set_cert_verify_callback(ctx.ssl_ctx_.get(), ContextImpl::verifyCallback, this);
+-    }
++  if (verify_mode != SSL_VERIFY_NONE) {
++    SSL_CTX_set_verify(tls_context_.ssl_ctx_.get(), verify_mode, nullptr);
++    SSL_CTX_set_cert_verify_callback(tls_context_.ssl_ctx_.get(), ContextImpl::verifyCallback, this);
+   }
+ 
+   std::unordered_set<int> cert_pkey_ids;
+   for (uint32_t i = 0; i < tls_certificates.size(); ++i) {
+-    auto& ctx = tls_contexts_[i];
+     // Load certificate chain.
+     const auto& tls_certificate = tls_certificates[i].get();
+-    ctx.cert_chain_file_path_ = tls_certificate.certificateChainPath();
++    tls_context_.cert_chain_file_path_ = tls_certificate.certificateChainPath();
++    std::cout << "cert chain path: " << tls_certificate.certificateChainPath() << "\n";
+     bssl::UniquePtr<BIO> bio(
+         BIO_new_mem_buf(const_cast<char*>(tls_certificate.certificateChain().data()),
+                         tls_certificate.certificateChain().size()));
+     RELEASE_ASSERT(bio != nullptr, "");
+-    ctx.cert_chain_.reset(PEM_read_bio_X509_AUX(bio.get(), nullptr, nullptr, nullptr));
+-    if (ctx.cert_chain_ == nullptr ||
+-        !SSL_CTX_use_certificate(ctx.ssl_ctx_.get(), ctx.cert_chain_.get())) {
++    tls_context_.cert_chain_.reset(PEM_read_bio_X509_AUX(bio.get(), nullptr, nullptr, nullptr));
++    if (tls_context_.cert_chain_ == nullptr ||
++        !SSL_CTX_use_certificate(tls_context_.ssl_ctx_.get(), tls_context_.cert_chain_.get())) {
+       while (uint64_t err = ERR_get_error()) {
+         ENVOY_LOG_MISC(debug, "SSL error: {}:{}:{}:{}", err, ERR_lib_error_string(err),
+                        ERR_func_error_string(err), ERR_GET_REASON(err),
+                        ERR_reason_error_string(err));
+       }
+       throw EnvoyException(
+-          fmt::format("Failed to load certificate chain from {}", ctx.cert_chain_file_path_));
++          fmt::format("Failed to load certificate chain from {}", tls_context_.cert_chain_file_path_));
+     }
+     // Read rest of the certificate chain.
+     while (true) {
++      std::cout << "certificate-chain-loading\n";
+       bssl::UniquePtr<X509> cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
+       if (cert == nullptr) {
+         break;
+       }
+-      if (!SSL_CTX_add_extra_chain_cert(ctx.ssl_ctx_.get(), cert.get())) {
++      if (!SSL_CTX_add_extra_chain_cert(tls_context_.ssl_ctx_.get(), cert.get())) {
+         throw EnvoyException(
+-            fmt::format("Failed to load certificate chain from {}", ctx.cert_chain_file_path_));
++            fmt::format("Failed to load certificate chain from {}", tls_context_.cert_chain_file_path_));
+       }
+       // SSL_CTX_add_extra_chain_cert() takes ownership.
+       cert.release();
+@@ -260,17 +246,17 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+       ERR_clear_error();
+     } else {
+       throw EnvoyException(
+-          fmt::format("Failed to load certificate chain from {}", ctx.cert_chain_file_path_));
++          fmt::format("Failed to load certificate chain from {}", tls_context_.cert_chain_file_path_));
+     }
+ 
+-    bssl::UniquePtr<EVP_PKEY> public_key(X509_get_pubkey(ctx.cert_chain_.get()));
++    bssl::UniquePtr<EVP_PKEY> public_key(X509_get_pubkey(tls_context_.cert_chain_.get()));
+     const int pkey_id = EVP_PKEY_id(public_key.get());
+     if (!cert_pkey_ids.insert(pkey_id).second) {
+       throw EnvoyException(fmt::format("Failed to load certificate chain from {}, at most one "
+                                        "certificate of a given type may be specified",
+-                                       ctx.cert_chain_file_path_));
++                                       tls_context_.cert_chain_file_path_));
+     }
+-    ctx.is_ecdsa_ = pkey_id == EVP_PKEY_EC;
++    tls_context_.is_ecdsa_ = pkey_id == EVP_PKEY_EC;
+     switch (pkey_id) {
+     case EVP_PKEY_EC: {
+       // We only support P-256 ECDSA today.
+@@ -281,9 +267,9 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+       if (ecdsa_group == nullptr || EC_GROUP_get_curve_name(ecdsa_group) != NID_X9_62_prime256v1) {
+         throw EnvoyException(fmt::format("Failed to load certificate chain from {}, only P-256 "
+                                          "ECDSA certificates are supported",
+-                                         ctx.cert_chain_file_path_));
++                                         tls_context_.cert_chain_file_path_));
+       }
+-      ctx.is_ecdsa_ = true;
++      tls_context_.is_ecdsa_ = true;
+     } break;
+     case EVP_PKEY_RSA: {
+       // We require RSA certificates with 2048-bit or larger keys.
+@@ -291,91 +277,48 @@ ContextImpl::ContextImpl(Stats::Scope& scope, const Envoy::Ssl::ContextConfig& c
+       // Since we checked the key type above, this should be valid.
+       ASSERT(rsa_public_key != nullptr);
+       const unsigned rsa_key_length = RSA_size(rsa_public_key);
+-#ifdef BORINGSSL_FIPS
+-      if (rsa_key_length != 2048 / 8 && rsa_key_length != 3072 / 8) {
+-        throw EnvoyException(
+-            fmt::format("Failed to load certificate chain from {}, only RSA certificates with "
+-                        "2048-bit or 3072-bit keys are supported in FIPS mode",
+-                        ctx.cert_chain_file_path_));
+-      }
+-#else
+       if (rsa_key_length < 2048 / 8) {
+         throw EnvoyException(fmt::format("Failed to load certificate chain from {}, only RSA "
+                                          "certificates with 2048-bit or larger keys are supported",
+-                                         ctx.cert_chain_file_path_));
++                                         tls_context_.cert_chain_file_path_));
+       }
+-#endif
+     } break;
+-#ifdef BORINGSSL_FIPS
+-    default:
+-      throw EnvoyException(fmt::format("Failed to load certificate chain from {}, only RSA and "
+-                                       "ECDSA certificates are supported in FIPS mode",
+-                                       ctx.cert_chain_file_path_));
+-#endif
+     }
+ 
+     Envoy::Ssl::PrivateKeyMethodProviderSharedPtr private_key_method_provider =
+         tls_certificate.privateKeyMethod();
+     // We either have a private key or a BoringSSL private key method provider.
+     if (private_key_method_provider) {
++      throw EnvoyException(
++          fmt::format("Private key provider configured, but not supported"));
++/*
+       ctx.private_key_method_provider_ = private_key_method_provider;
+       // The provider has a reference to the private key method for the context lifetime.
+       Ssl::BoringSslPrivateKeyMethodSharedPtr private_key_method =
+           private_key_method_provider->getBoringSslPrivateKeyMethod();
+       if (private_key_method == nullptr) {
+-        throw EnvoyException(
+-            fmt::format("Failed to get BoringSSL private key method from provider"));
+       }
+-#ifdef BORINGSSL_FIPS
+-      if (!ctx.private_key_method_provider_->checkFips()) {
+-        throw EnvoyException(
+-            fmt::format("Private key method doesn't support FIPS mode with current parameters"));
+-      }
+-#endif
+       SSL_CTX_set_private_key_method(ctx.ssl_ctx_.get(), private_key_method.get());
++*/
+     } else {
+       // Load private key.
+-      bio.reset(BIO_new_mem_buf(const_cast<char*>(tls_certificate.privateKey().data()),
++      bio.reset(BIO_new_mem_buf(const_cast<char *>(tls_certificate.privateKey().data()),
+                                 tls_certificate.privateKey().size()));
+       RELEASE_ASSERT(bio != nullptr, "");
+       bssl::UniquePtr<EVP_PKEY> pkey(
+           PEM_read_bio_PrivateKey(bio.get(), nullptr, nullptr,
+                                   !tls_certificate.password().empty()
+-                                      ? const_cast<char*>(tls_certificate.password().c_str())
+-                                      : nullptr));
+-      if (pkey == nullptr || !SSL_CTX_use_PrivateKey(ctx.ssl_ctx_.get(), pkey.get())) {
++                                  ? const_cast<char *>(tls_certificate.password().c_str())
++                                  : nullptr));
++      if (pkey == nullptr || !SSL_CTX_use_PrivateKey(tls_context_.ssl_ctx_.get(), pkey.get())) {
+         throw EnvoyException(
+             fmt::format("Failed to load private key from {}", tls_certificate.privateKeyPath()));
+       }
+-
+-#ifdef BORINGSSL_FIPS
+-      // Verify that private keys are passing FIPS pairwise consistency tests.
+-      switch (pkey_id) {
+-      case EVP_PKEY_EC: {
+-        const EC_KEY* ecdsa_private_key = EVP_PKEY_get0_EC_KEY(pkey.get());
+-        if (!EC_KEY_check_fips(ecdsa_private_key)) {
+-          throw EnvoyException(fmt::format("Failed to load private key from {}, ECDSA key failed "
+-                                           "pairwise consistency test required in FIPS mode",
+-                                           tls_certificate.privateKeyPath()));
+-        }
+-      } break;
+-      case EVP_PKEY_RSA: {
+-        RSA* rsa_private_key = EVP_PKEY_get0_RSA(pkey.get());
+-        if (!RSA_check_fips(rsa_private_key)) {
+-          throw EnvoyException(fmt::format("Failed to load private key from {}, RSA key failed "
+-                                           "pairwise consistency test required in FIPS mode",
+-                                           tls_certificate.privateKeyPath()));
+-        }
+-      } break;
+-      }
+-#endif
+     }
+   }
+ 
+   // use the server's cipher list preferences
+-  for (auto& ctx : tls_contexts_) {
+-    SSL_CTX_set_options(ctx.ssl_ctx_.get(), SSL_OP_CIPHER_SERVER_PREFERENCE);
+-  }
++  SSL_CTX_set_options(tls_context_.ssl_ctx_.get(), SSL_OP_CIPHER_SERVER_PREFERENCE);
+ 
+   parsed_alpn_protocols_ = parseAlpnProtocols(config.alpnProtocols());
+ 
+@@ -453,7 +396,7 @@ bssl::UniquePtr<SSL> ContextImpl::newSsl(const Network::TransportSocketOptions*)
+   // We use the first certificate for a new SSL object, later in the
+   // SSL_CTX_set_select_certificate_cb() callback following ClientHello, we replace with the
+   // selected certificate via SSL_set_SSL_CTX().
+-  return bssl::UniquePtr<SSL>(SSL_new(tls_contexts_[0].ssl_ctx_.get()));
++  return bssl::UniquePtr<SSL>(SSL_new(tls_context_.ssl_ctx_.get()));
+ }
+ 
+ int ContextImpl::ignoreCertificateExpirationCallback(int ok, X509_STORE_CTX* ctx) {
+@@ -478,14 +421,13 @@ int ContextImpl::verifyCallback(X509_STORE_CTX* store_ctx, void* arg) {
+     }
+   }
+ 
++  X509* cert = Envoy::Extensions::TransportSockets::Tls::getVerifyCallbackCert(store_ctx, arg);
+   SSL* ssl = reinterpret_cast<SSL*>(
+       X509_STORE_CTX_get_ex_data(store_ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));
+-  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl));
+-
+   const Network::TransportSocketOptions* transport_socket_options =
+       static_cast<const Network::TransportSocketOptions*>(SSL_get_app_data(ssl));
+   return impl->verifyCertificate(
+-      cert.get(), transport_socket_options &&
++      cert, transport_socket_options &&
+                           !transport_socket_options->verifySubjectAltNameListOverride().empty()
+                       ? transport_socket_options->verifySubjectAltNameListOverride()
+                       : impl->verify_subject_alt_name_list_);
+@@ -537,16 +479,34 @@ void ContextImpl::logHandshake(SSL* ssl) const {
+   incCounter(ssl_ciphers_, SSL_get_cipher_name(ssl), unknown_ssl_cipher_);
+   incCounter(ssl_versions_, SSL_get_version(ssl), unknown_ssl_version_);
+ 
+-  uint16_t curve_id = SSL_get_curve_id(ssl);
+-  if (curve_id) {
+-    incCounter(ssl_curves_, SSL_get_curve_name(curve_id), unknown_ssl_curve_);
++  //uint16_t curve_id = SSL_get_curve_id(ssl);
++  //if (curve_id) {
++  //  incCounter(ssl_curves_, SSL_get_curve_name(curve_id), unknown_ssl_curve_);
++  //}
++  int group = SSL_get_shared_group(ssl, NULL);
++  if (group > 0) {
++    switch (group) {
++      case NID_X25519:
++        incCounter(ssl_curves_, "X25519", unknown_ssl_curve_);
++        break;
++      case NID_X9_62_prime256v1:
++        incCounter(ssl_curves_, "P-256", unknown_ssl_curve_);
++        break;
++      default:
++        incCounter(ssl_curves_, "", unknown_ssl_curve_);
++        // case NID_secp384r1: {
++        //	scope_.counter(fmt::format("ssl.curves.{}", "P-384")).inc();
++        //} break;
++    }
+   }
+ 
+-  uint16_t sigalg_id = SSL_get_peer_signature_algorithm(ssl);
+-  if (sigalg_id) {
+-    const char* sigalg = SSL_get_signature_algorithm_name(sigalg_id, 1 /* include curve */);
+-    incCounter(ssl_sigalgs_, sigalg, unknown_ssl_algorithm_);
+-  }
++  // TODO (dmitri-d) sort out ssl_sigalgs_ stats
++  //uint16_t sigalg_id = SSL_get_peer_signature_algorithm(ssl);
++  //if (sigalg_id) {
++  //  const char *sigalg = SSL_get_signature_algorithm_name(sigalg_id, 1 /* include curve */);
++  //  incCounter(ssl_sigalgs_, sigalg, unknown_ssl_algorithm_);
++  //}
++
+ 
+   bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl));
+   if (!cert.get()) {
+@@ -557,12 +517,10 @@ void ContextImpl::logHandshake(SSL* ssl) const {
+ std::vector<Ssl::PrivateKeyMethodProviderSharedPtr> ContextImpl::getPrivateKeyMethodProviders() {
+   std::vector<Envoy::Ssl::PrivateKeyMethodProviderSharedPtr> providers;
+ 
+-  for (auto& tls_context : tls_contexts_) {
+-    Envoy::Ssl::PrivateKeyMethodProviderSharedPtr provider =
+-        tls_context.getPrivateKeyMethodProvider();
+-    if (provider) {
+-      providers.push_back(provider);
+-    }
++  Envoy::Ssl::PrivateKeyMethodProviderSharedPtr provider =
++      tls_context_.getPrivateKeyMethodProvider();
++  if (provider) {
++    providers.push_back(provider);
+   }
+   return providers;
+ }
+@@ -690,10 +648,8 @@ SslStats ContextImpl::generateStats(Stats::Scope& store) {
+ 
+ size_t ContextImpl::daysUntilFirstCertExpires() const {
+   int daysUntilExpiration = Utility::getDaysUntilExpiration(ca_cert_.get(), time_source_);
+-  for (auto& ctx : tls_contexts_) {
+-    daysUntilExpiration = std::min<int>(
+-        Utility::getDaysUntilExpiration(ctx.cert_chain_.get(), time_source_), daysUntilExpiration);
+-  }
++  daysUntilExpiration = std::min<int>(
++      Utility::getDaysUntilExpiration(tls_context_.cert_chain_.get(), time_source_), daysUntilExpiration);
+   if (daysUntilExpiration < 0) { // Ensure that the return value is unsigned
+     return 0;
+   }
+@@ -709,13 +665,10 @@ Envoy::Ssl::CertificateDetailsPtr ContextImpl::getCaCertInformation() const {
+ 
+ std::vector<Envoy::Ssl::CertificateDetailsPtr> ContextImpl::getCertChainInformation() const {
+   std::vector<Envoy::Ssl::CertificateDetailsPtr> cert_details;
+-  for (const auto& ctx : tls_contexts_) {
+-    if (ctx.cert_chain_ == nullptr) {
+-      continue;
++    if (tls_context_.cert_chain_ != nullptr) {
++        cert_details.emplace_back(
++                certificateDetails(tls_context_.cert_chain_.get(), tls_context_.getCertChainFileName()));
+     }
+-    cert_details.emplace_back(
+-        certificateDetails(ctx.cert_chain_.get(), ctx.getCertChainFileName()));
+-  }
+   return cert_details;
+ }
+ 
+@@ -753,29 +706,25 @@ ClientContextImpl::ClientContextImpl(Stats::Scope& scope,
+       allow_renegotiation_(config.allowRenegotiation()),
+       max_session_keys_(config.maxSessionKeys()) {
+   // This should be guaranteed during configuration ingestion for client contexts.
+-  ASSERT(tls_contexts_.size() == 1);
+   if (!parsed_alpn_protocols_.empty()) {
+-    for (auto& ctx : tls_contexts_) {
+-      int rc = SSL_CTX_set_alpn_protos(ctx.ssl_ctx_.get(), &parsed_alpn_protocols_[0],
++      int rc = SSL_CTX_set_alpn_protos(tls_context_.ssl_ctx_.get(), &parsed_alpn_protocols_[0],
+                                        parsed_alpn_protocols_.size());
+       RELEASE_ASSERT(rc == 0, "");
+-    }
+   }
+ 
+   if (!config.signingAlgorithmsForTest().empty()) {
+     const uint16_t sigalgs = parseSigningAlgorithmsForTest(config.signingAlgorithmsForTest());
+     RELEASE_ASSERT(sigalgs != 0, "");
+ 
+-    for (auto& ctx : tls_contexts_) {
+-      int rc = SSL_CTX_set_verify_algorithm_prefs(ctx.ssl_ctx_.get(), &sigalgs, 1);
+-      RELEASE_ASSERT(rc == 1, "");
+-    }
++    // upstream: int rc = SSL_CTX_set_verify_algorithm_prefs(ctx.ssl_ctx_.get(), &sigalgs, 1);
++    int rc = SSL_CTX_set1_sigalgs_list(tls_context_.ssl_ctx_.get(), config.signingAlgorithmsForTest().c_str());
++    RELEASE_ASSERT(rc == 1, "");
+   }
+ 
+   if (max_session_keys_ > 0) {
+-    SSL_CTX_set_session_cache_mode(tls_contexts_[0].ssl_ctx_.get(), SSL_SESS_CACHE_CLIENT);
++    SSL_CTX_set_session_cache_mode(tls_context_.ssl_ctx_.get(), SSL_SESS_CACHE_CLIENT);
+     SSL_CTX_sess_set_new_cb(
+-        tls_contexts_[0].ssl_ctx_.get(), [](SSL* ssl, SSL_SESSION* session) -> int {
++        tls_context_.ssl_ctx_.get(), [](SSL* ssl, SSL_SESSION* session) -> int {
+           ContextImpl* context_impl =
+               static_cast<ContextImpl*>(SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+           ClientContextImpl* client_context_impl = dynamic_cast<ClientContextImpl*>(context_impl);
+@@ -813,7 +762,7 @@ bssl::UniquePtr<SSL> ClientContextImpl::newSsl(const Network::TransportSocketOpt
+   }
+ 
+   if (allow_renegotiation_) {
+-    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);
++    Envoy::Extensions::TransportSockets::Tls::allowRenegotiation(ssl_con.get());
+   }
+ 
+   if (max_session_keys_ > 0) {
+@@ -826,7 +775,7 @@ bssl::UniquePtr<SSL> ClientContextImpl::newSsl(const Network::TransportSocketOpt
+         SSL_SESSION* session = session_keys_.front().get();
+         SSL_set_session(ssl_con.get(), session);
+         // Remove single-use session key (TLS 1.3) after first use.
+-        if (SSL_SESSION_should_be_single_use(session)) {
++        if (Envoy::Extensions::TransportSockets::Tls::should_be_single_use(session)) {
+           session_keys_.pop_front();
+         }
+       }
+@@ -848,7 +797,7 @@ bssl::UniquePtr<SSL> ClientContextImpl::newSsl(const Network::TransportSocketOpt
+ int ClientContextImpl::newSessionKey(SSL_SESSION* session) {
+   // In case we ever store single-use session key (TLS 1.3),
+   // we need to switch to using write/write locks.
+-  if (SSL_SESSION_should_be_single_use(session)) {
++  if (Envoy::Extensions::TransportSockets::Tls::should_be_single_use(session)) {
+     session_keys_single_use_ = true;
+   }
+   absl::WriterMutexLock l(&session_keys_mu_);
+@@ -865,13 +814,48 @@ uint16_t ClientContextImpl::parseSigningAlgorithmsForTest(const std::string& sig
+   // This is used only when testing RSA/ECDSA certificate selection, so only the signing algorithms
+   // used in tests are supported here.
+   if (sigalgs == "rsa_pss_rsae_sha256") {
+-    return SSL_SIGN_RSA_PSS_RSAE_SHA256;
++    return 0x0804; //SSL_SIGN_RSA_PSS_RSAE_SHA256
+   } else if (sigalgs == "ecdsa_secp256r1_sha256") {
+-    return SSL_SIGN_ECDSA_SECP256R1_SHA256;
++    return 0x0403; //SSL_SIGN_ECDSA_SECP256R1_SHA256
+   }
+   return 0;
+ }
+ 
++// TODO (dmitri-d): this always returns false
++// it is very different from the upstream version
++static bool isClientEcdsaCapable(SSL* ssl) {
++  X509* x509 = SSL_get_peer_certificate(ssl);
++  STACK_OF(X509_NAME)* x509_name_stack = SSL_get_client_CA_list(ssl);
++
++  for (int i = 0; i < sk_X509_NAME_num(x509_name_stack); i++) {
++    const X509_NAME* x509_name = sk_X509_NAME_value(x509_name_stack, i);
++  }
++
++  int pnid;
++  int nidresult = SSL_get_peer_signature_type_nid(ssl, &pnid);
++
++  STACK_OF(SSL_CIPHER)* cipher_stack = SSL_get_client_ciphers(ssl);
++
++  for (int i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {
++    const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(cipher_stack, i);
++    int nid = SSL_CIPHER_get_cipher_nid(cipher);
++  }
++
++  STACK_OF(X509)* x509_stack = SSL_get_peer_cert_chain(ssl);
++
++  for (int i = 0; i < sk_X509_num(x509_stack); i++) {
++    const X509* x509 = sk_X509_value(x509_stack, i);
++  }
++
++  int version_num = SSL_client_version(ssl);
++  const char* version = SSL_get_version(ssl);
++
++  SSL_SESSION* session = SSL_get_session(ssl);
++  x509 = SSL_SESSION_get0_peer(session);
++
++  return false;
++}
++
+ ServerContextImpl::ServerContextImpl(Stats::Scope& scope,
+                                      const Envoy::Ssl::ServerContextConfig& config,
+                                      const std::vector<std::string>& server_names,
+@@ -880,64 +864,57 @@ ServerContextImpl::ServerContextImpl(Stats::Scope& scope,
+   if (config.tlsCertificates().empty()) {
+     throw EnvoyException("Server TlsCertificates must have a certificate specified");
+   }
+-  // First, configure the base context for ClientHello interception.
+-  // TODO(htuch): replace with SSL_IDENTITY when we have this as a means to do multi-cert in
+-  // BoringSSL.
+-  SSL_CTX_set_select_certificate_cb(
+-      tls_contexts_[0].ssl_ctx_.get(),
+-      [](const SSL_CLIENT_HELLO* client_hello) -> ssl_select_cert_result_t {
+-        return static_cast<ServerContextImpl*>(
+-                   SSL_CTX_get_app_data(SSL_get_SSL_CTX(client_hello->ssl)))
+-            ->selectTlsContext(client_hello);
+-      });
++
++  // Envoy::Extensions::TransportSockets::Tls::set_select_certificate_cb();
++
+   // Compute the session context ID hash. We use all the certificate identities,
+   // since we should have a common ID for session resumption no matter what cert
+   // is used.
+   uint8_t session_context_buf[EVP_MAX_MD_SIZE] = {};
+   unsigned session_context_len = 0;
+   generateHashForSessionContexId(server_names, session_context_buf, session_context_len);
+-  for (auto& ctx : tls_contexts_) {
+-    if (config.certificateValidationContext() != nullptr &&
+-        !config.certificateValidationContext()->caCert().empty()) {
+-      ctx.addClientValidationContext(*config.certificateValidationContext(),
+-                                     config.requireClientCertificate());
+-    }
+ 
+-    if (!parsed_alpn_protocols_.empty()) {
+-      SSL_CTX_set_alpn_select_cb(
+-          ctx.ssl_ctx_.get(),
+-          [](SSL*, const unsigned char** out, unsigned char* outlen, const unsigned char* in,
+-             unsigned int inlen, void* arg) -> int {
+-            return static_cast<ServerContextImpl*>(arg)->alpnSelectCallback(out, outlen, in, inlen);
+-          },
+-          this);
+-    }
++  if (config.certificateValidationContext() != nullptr &&
++      !config.certificateValidationContext()->caCert().empty()) {
++    tls_context_.addClientValidationContext(*config.certificateValidationContext(),
++                                   config.requireClientCertificate());
++  }
+ 
+-    if (!session_ticket_keys_.empty()) {
+-      SSL_CTX_set_tlsext_ticket_key_cb(
+-          ctx.ssl_ctx_.get(),
+-          [](SSL* ssl, uint8_t* key_name, uint8_t* iv, EVP_CIPHER_CTX* ctx, HMAC_CTX* hmac_ctx,
+-             int encrypt) -> int {
+-            ContextImpl* context_impl =
+-                static_cast<ContextImpl*>(SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
+-            ServerContextImpl* server_context_impl = dynamic_cast<ServerContextImpl*>(context_impl);
+-            RELEASE_ASSERT(server_context_impl != nullptr, ""); // for Coverity
+-            return server_context_impl->sessionTicketProcess(ssl, key_name, iv, ctx, hmac_ctx,
+-                                                             encrypt);
+-          });
++  if (!parsed_alpn_protocols_.empty()) {
++    SSL_CTX_set_alpn_select_cb(
++        tls_context_.ssl_ctx_.get(),
++        [](SSL*, const unsigned char** out, unsigned char* outlen, const unsigned char* in,
++           unsigned int inlen, void* arg) -> int {
++          return static_cast<ServerContextImpl*>(arg)->alpnSelectCallback(out, outlen, in, inlen);
++        },
++        this);
+     }
+ 
+-    int rc = SSL_CTX_set_session_id_context(ctx.ssl_ctx_.get(), session_context_buf,
+-                                            session_context_len);
+-    RELEASE_ASSERT(rc == 1, "");
++  if (!session_ticket_keys_.empty()) {
++    SSL_CTX_set_tlsext_ticket_key_cb(
++        tls_context_.ssl_ctx_.get(),
++        +[](SSL* ssl, uint8_t* key_name, uint8_t* iv, EVP_CIPHER_CTX* ctx, HMAC_CTX* hmac_ctx,
++           int encrypt) -> int {
++          ContextImpl* context_impl =
++              static_cast<ContextImpl*>(SSL_CTX_get_app_data(SSL_get_SSL_CTX(ssl)));
++          ServerContextImpl* server_context_impl = dynamic_cast<ServerContextImpl*>(context_impl);
++          RELEASE_ASSERT(server_context_impl != nullptr, ""); // for Coverity
++          return server_context_impl->sessionTicketProcess(ssl, key_name, iv, ctx, hmac_ctx,
++                                                           encrypt);
++        });
+   }
++
++  int rc = SSL_CTX_set_session_id_context(tls_context_.ssl_ctx_.get(), session_context_buf,
++                                          session_context_len);
++  RELEASE_ASSERT(rc == 1, "");
+ }
+ 
+ void ServerContextImpl::generateHashForSessionContexId(const std::vector<std::string>& server_names,
+                                                        uint8_t* session_context_buf,
+                                                        unsigned& session_context_len) {
+-  EVP_MD_CTX md;
+-  int rc = EVP_DigestInit(&md, EVP_sha256());
++  // md is released before we return from the method
++  EVP_MD_CTX* md = Envoy::Extensions::TransportSockets::Tls::newEVP_MD_CTX();
++  int rc = EVP_DigestInit(md, EVP_sha256());
+   RELEASE_ASSERT(rc == 1, "");
+ 
+   // Hash the CommonName/SANs of all the server certificates. This makes sure that sessions can only
+@@ -945,44 +922,43 @@ void ServerContextImpl::generateHashForSessionContexId(const std::vector<std::st
+   // case that different Envoy instances each have their own certs. All certificates in a
+   // ServerContextImpl context are hashed together, since they all constitute a match on a filter
+   // chain for resumption purposes.
+-  for (const auto& ctx : tls_contexts_) {
+-    X509* cert = SSL_CTX_get0_certificate(ctx.ssl_ctx_.get());
+-    RELEASE_ASSERT(cert != nullptr, "");
+-    X509_NAME* cert_subject = X509_get_subject_name(cert);
+-    RELEASE_ASSERT(cert_subject != nullptr, "");
+-    int cn_index = X509_NAME_get_index_by_NID(cert_subject, NID_commonName, -1);
+-    // It's possible that the certificate doesn't have CommonName, but has SANs.
+-    if (cn_index >= 0) {
+-      X509_NAME_ENTRY* cn_entry = X509_NAME_get_entry(cert_subject, cn_index);
+-      RELEASE_ASSERT(cn_entry != nullptr, "");
+-      ASN1_STRING* cn_asn1 = X509_NAME_ENTRY_get_data(cn_entry);
+-      RELEASE_ASSERT(ASN1_STRING_length(cn_asn1) > 0, "");
+-      rc = EVP_DigestUpdate(&md, ASN1_STRING_data(cn_asn1), ASN1_STRING_length(cn_asn1));
+-      RELEASE_ASSERT(rc == 1, "");
+-    }
+ 
+-    bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(
+-        X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));
+-    if (san_names != nullptr) {
+-      for (const GENERAL_NAME* san : san_names.get()) {
+-        if (san->type == GEN_DNS || san->type == GEN_URI) {
+-          rc = EVP_DigestUpdate(&md, ASN1_STRING_data(san->d.ia5), ASN1_STRING_length(san->d.ia5));
+-          RELEASE_ASSERT(rc == 1, "");
+-        }
++  X509* cert = SSL_CTX_get0_certificate(tls_context_.ssl_ctx_.get());
++  RELEASE_ASSERT(cert != nullptr, "");
++  X509_NAME* cert_subject = X509_get_subject_name(cert);
++  RELEASE_ASSERT(cert_subject != nullptr, "");
++  int cn_index = X509_NAME_get_index_by_NID(cert_subject, NID_commonName, -1);
++  // It's possible that the certificate doesn't have CommonName, but has SANs.
++  if (cn_index >= 0) {
++    X509_NAME_ENTRY* cn_entry = X509_NAME_get_entry(cert_subject, cn_index);
++    RELEASE_ASSERT(cn_entry != nullptr, "");
++    ASN1_STRING* cn_asn1 = X509_NAME_ENTRY_get_data(cn_entry);
++    RELEASE_ASSERT(ASN1_STRING_length(cn_asn1) > 0, "");
++    rc = EVP_DigestUpdate(md, ASN1_STRING_data(cn_asn1), ASN1_STRING_length(cn_asn1));
++    RELEASE_ASSERT(rc == 1, "");
++  }
++
++  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(
++      X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));
++  if (san_names != nullptr) {
++    for (const GENERAL_NAME* san : san_names.get()) {
++      if (san->type == GEN_DNS || san->type == GEN_URI) {
++        rc = EVP_DigestUpdate(md, ASN1_STRING_data(san->d.ia5), ASN1_STRING_length(san->d.ia5));
++        RELEASE_ASSERT(rc == 1, "");
+       }
+-    } else {
+-      // Make sure that we have either CommonName or SANs.
+-      RELEASE_ASSERT(cn_index >= 0, "");
+     }
+-
+-    X509_NAME* cert_issuer_name = X509_get_issuer_name(cert);
+-    rc =
+-        X509_NAME_digest(cert_issuer_name, EVP_sha256(), session_context_buf, &session_context_len);
+-    RELEASE_ASSERT(rc == 1 && session_context_len == SHA256_DIGEST_LENGTH, "");
+-    rc = EVP_DigestUpdate(&md, session_context_buf, session_context_len);
+-    RELEASE_ASSERT(rc == 1, "");
++  } else {
++    // Make sure that we have either CommonName or SANs.
++    RELEASE_ASSERT(cn_index >= 0, "");
+   }
+ 
++  X509_NAME* cert_issuer_name = X509_get_issuer_name(cert);
++  rc =
++      X509_NAME_digest(cert_issuer_name, EVP_sha256(), session_context_buf, &session_context_len);
++  RELEASE_ASSERT(rc == 1 && session_context_len == SHA256_DIGEST_LENGTH, "");
++  rc = EVP_DigestUpdate(md, session_context_buf, session_context_len);
++  RELEASE_ASSERT(rc == 1, "");
++
+   // Hash all the settings that affect whether the server will allow/accept
+   // the client connection. This ensures that the client is always validated against
+   // the correct settings, even if session resumption across different listeners
+@@ -990,25 +966,25 @@ void ServerContextImpl::generateHashForSessionContexId(const std::vector<std::st
+   if (ca_cert_ != nullptr) {
+     rc = X509_digest(ca_cert_.get(), EVP_sha256(), session_context_buf, &session_context_len);
+     RELEASE_ASSERT(rc == 1 && session_context_len == SHA256_DIGEST_LENGTH, "");
+-    rc = EVP_DigestUpdate(&md, session_context_buf, session_context_len);
++    rc = EVP_DigestUpdate(md, session_context_buf, session_context_len);
+     RELEASE_ASSERT(rc == 1, "");
+ 
+     // verify_subject_alt_name_list_ can only be set with a ca_cert
+     for (const std::string& name : verify_subject_alt_name_list_) {
+-      rc = EVP_DigestUpdate(&md, name.data(), name.size());
++      rc = EVP_DigestUpdate(md, name.data(), name.size());
+       RELEASE_ASSERT(rc == 1, "");
+     }
+   }
+ 
+   for (const auto& hash : verify_certificate_hash_list_) {
+-    rc = EVP_DigestUpdate(&md, hash.data(),
++    rc = EVP_DigestUpdate(md, hash.data(),
+                           hash.size() *
+                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));
+     RELEASE_ASSERT(rc == 1, "");
+   }
+ 
+   for (const auto& hash : verify_certificate_spki_list_) {
+-    rc = EVP_DigestUpdate(&md, hash.data(),
++    rc = EVP_DigestUpdate(md, hash.data(),
+                           hash.size() *
+                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));
+     RELEASE_ASSERT(rc == 1, "");
+@@ -1017,12 +993,14 @@ void ServerContextImpl::generateHashForSessionContexId(const std::vector<std::st
+   // Hash configured SNIs for this context, so that sessions cannot be resumed across different
+   // filter chains, even when using the same server certificate.
+   for (const auto& name : server_names) {
+-    rc = EVP_DigestUpdate(&md, name.data(), name.size());
++    rc = EVP_DigestUpdate(md, name.data(), name.size());
+     RELEASE_ASSERT(rc == 1, "");
+   }
+ 
+-  rc = EVP_DigestFinal(&md, session_context_buf, &session_context_len);
++  rc = EVP_DigestFinal(md, session_context_buf, &session_context_len);
+   RELEASE_ASSERT(rc == 1, "");
++
++  EVP_MD_CTX_free(md);
+ }
+ 
+ int ServerContextImpl::sessionTicketProcess(SSL*, uint8_t* key_name, uint8_t* iv,
+@@ -1045,7 +1023,6 @@ int ServerContextImpl::sessionTicketProcess(SSL*, uint8_t* key_name, uint8_t* iv
+ 
+     int rc = RAND_bytes(iv, EVP_CIPHER_iv_length(cipher));
+     ASSERT(rc);
+-
+     // This RELEASE_ASSERT is logically a static_assert, but we can't actually get
+     // EVP_CIPHER_key_length(cipher) at compile-time
+     RELEASE_ASSERT(key.aes_key_.size() == EVP_CIPHER_key_length(cipher), "");
+@@ -1085,100 +1062,14 @@ int ServerContextImpl::sessionTicketProcess(SSL*, uint8_t* key_name, uint8_t* iv
+   }
+ }
+ 
+-bool ServerContextImpl::isClientEcdsaCapable(const SSL_CLIENT_HELLO* ssl_client_hello) {
+-  CBS client_hello;
+-  CBS_init(&client_hello, ssl_client_hello->client_hello, ssl_client_hello->client_hello_len);
+-
+-  // This is the TLSv1.3 case (TLSv1.2 on the wire and the supported_versions extensions present).
+-  // We just need to look at signature algorithms.
+-  const uint16_t client_version = ssl_client_hello->version;
+-  if (client_version == TLS1_2_VERSION && tls_max_version_ == TLS1_3_VERSION) {
+-    // If the supported_versions extension is found then we assume that the client is competent
+-    // enough that just checking the signature_algorithms is sufficient.
+-    const uint8_t* supported_versions_data;
+-    size_t supported_versions_len;
+-    if (SSL_early_callback_ctx_extension_get(ssl_client_hello, TLSEXT_TYPE_supported_versions,
+-                                             &supported_versions_data, &supported_versions_len)) {
+-      const uint8_t* signature_algorithms_data;
+-      size_t signature_algorithms_len;
+-      if (SSL_early_callback_ctx_extension_get(ssl_client_hello, TLSEXT_TYPE_signature_algorithms,
+-                                               &signature_algorithms_data,
+-                                               &signature_algorithms_len)) {
+-        CBS signature_algorithms_ext, signature_algorithms;
+-        CBS_init(&signature_algorithms_ext, signature_algorithms_data, signature_algorithms_len);
+-        if (!CBS_get_u16_length_prefixed(&signature_algorithms_ext, &signature_algorithms) ||
+-            CBS_len(&signature_algorithms_ext) != 0) {
+-          return false;
+-        }
+-        if (cbsContainsU16(signature_algorithms, SSL_SIGN_ECDSA_SECP256R1_SHA256)) {
+-          return true;
+-        }
+-      }
+-
+-      return false;
+-    }
+-  }
+-
+-  // Otherwise we are < TLSv1.3 and need to look at both the curves in the supported_groups for
+-  // ECDSA and also for a compatible cipher suite. https://tools.ietf.org/html/rfc4492#section-5.1.1
+-  const uint8_t* curvelist_data;
+-  size_t curvelist_len;
+-  if (!SSL_early_callback_ctx_extension_get(ssl_client_hello, TLSEXT_TYPE_supported_groups,
+-                                            &curvelist_data, &curvelist_len)) {
+-    return false;
+-  }
+-
+-  CBS curvelist;
+-  CBS_init(&curvelist, curvelist_data, curvelist_len);
+-
+-  // We only support P256 ECDSA curves today.
+-  if (!cbsContainsU16(curvelist, SSL_CURVE_SECP256R1)) {
+-    return false;
+-  }
+-
+-  // The client must have offered an ECDSA ciphersuite that we like.
+-  CBS cipher_suites;
+-  CBS_init(&cipher_suites, ssl_client_hello->cipher_suites, ssl_client_hello->cipher_suites_len);
+-
+-  while (CBS_len(&cipher_suites) > 0) {
+-    uint16_t cipher_id;
+-    if (!CBS_get_u16(&cipher_suites, &cipher_id)) {
+-      return false;
+-    }
+-    // All tls_context_ share the same set of enabled ciphers, so we can just look at the base
+-    // context.
+-    if (tls_contexts_[0].isCipherEnabled(cipher_id, client_version)) {
+-      return true;
+-    }
+-  }
+-
+-  return false;
+-}
+-
+-enum ssl_select_cert_result_t
+-ServerContextImpl::selectTlsContext(const SSL_CLIENT_HELLO* ssl_client_hello) {
+-  const bool client_ecdsa_capable = isClientEcdsaCapable(ssl_client_hello);
+-  // Fallback on first certificate.
+-  const TlsContext* selected_ctx = &tls_contexts_[0];
+-  for (const auto& ctx : tls_contexts_) {
+-    if (client_ecdsa_capable == ctx.is_ecdsa_) {
+-      selected_ctx = &ctx;
+-      break;
+-    }
+-  }
+-  RELEASE_ASSERT(SSL_set_SSL_CTX(ssl_client_hello->ssl, selected_ctx->ssl_ctx_.get()) != nullptr,
+-                 "");
+-  return ssl_select_cert_success;
+-}
+-
+ void ServerContextImpl::TlsContext::addClientValidationContext(
+     const Envoy::Ssl::CertificateValidationContextConfig& config, bool require_client_cert) {
+   bssl::UniquePtr<BIO> bio(
+       BIO_new_mem_buf(const_cast<char*>(config.caCert().data()), config.caCert().size()));
+   RELEASE_ASSERT(bio != nullptr, "");
+   // Based on BoringSSL's SSL_add_file_cert_subjects_to_stack().
+-  bssl::UniquePtr<STACK_OF(X509_NAME)> list(sk_X509_NAME_new(
+-      [](const X509_NAME** a, const X509_NAME** b) -> int { return X509_NAME_cmp(*a, *b); }));
++  bssl::UniquePtr<STACK_OF(X509_NAME)> list =
++      Envoy::Extensions::TransportSockets::Tls::initX509Names();
+   RELEASE_ASSERT(list != nullptr, "");
+   for (;;) {
+     bssl::UniquePtr<X509> cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
+@@ -1208,7 +1099,9 @@ void ServerContextImpl::TlsContext::addClientValidationContext(
+     throw EnvoyException(
+         fmt::format("Failed to load trusted client CA certificates from {}", config.caCertPath()));
+   }
+-  SSL_CTX_set_client_CA_list(ssl_ctx_.get(), list.release());
++
++  if (sk_X509_NAME_num(list.get()) > 0)
++    SSL_CTX_set_client_CA_list(ssl_ctx_.get(), list.release());
+ 
+   // SSL_VERIFY_PEER or stronger mode was already set in ContextImpl::ContextImpl().
+   if (require_client_cert) {
+@@ -1216,7 +1109,7 @@ void ServerContextImpl::TlsContext::addClientValidationContext(
+   }
+ }
+ 
+-bool ServerContextImpl::TlsContext::isCipherEnabled(uint16_t cipher_id, uint16_t client_version) {
++/*bool ServerContextImpl::TlsContext::isCipherEnabled(uint16_t cipher_id, uint16_t client_version) {
+   const SSL_CIPHER* c = SSL_get_cipher_by_value(cipher_id);
+   if (c == nullptr) {
+     return false;
+@@ -1234,7 +1127,7 @@ bool ServerContextImpl::TlsContext::isCipherEnabled(uint16_t cipher_id, uint16_t
+     }
+   }
+   return false;
+-}
++}*/
+ 
+ } // namespace Tls
+ } // namespace TransportSockets
+diff --git a/source/extensions/transport_sockets/tls/context_impl.h b/source/extensions/transport_sockets/tls/context_impl.h
+index f91ad1d0bc..4cef03193a 100644
+--- a/source/extensions/transport_sockets/tls/context_impl.h
++++ b/source/extensions/transport_sockets/tls/context_impl.h
+@@ -15,9 +15,11 @@
+ #include "common/stats/symbol_table_impl.h"
+ 
+ #include "extensions/transport_sockets/tls/context_manager_impl.h"
++#include "extensions/transport_sockets/tls/openssl_impl.h"
+ 
+ #include "absl/synchronization/mutex.h"
+ #include "absl/types/optional.h"
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/ssl.h"
+ 
+ namespace Envoy {
+@@ -131,6 +133,7 @@ protected:
+   void incCounter(const Stats::StatName name, absl::string_view value,
+                   const Stats::StatName fallback) const;
+ 
++
+   Envoy::Ssl::CertificateDetailsPtr certificateDetails(X509* cert, const std::string& path) const;
+ 
+   struct TlsContext {
+@@ -147,17 +150,16 @@ protected:
+     std::string getCertChainFileName() const { return cert_chain_file_path_; };
+     void addClientValidationContext(const Envoy::Ssl::CertificateValidationContextConfig& config,
+                                     bool require_client_cert);
+-    bool isCipherEnabled(uint16_t cipher_id, uint16_t client_version);
++    // bool isCipherEnabled(uint16_t cipher_id, uint16_t client_version);
+     Envoy::Ssl::PrivateKeyMethodProviderSharedPtr getPrivateKeyMethodProvider() {
+       return private_key_method_provider_;
+     }
+   };
+ 
+-  // This is always non-empty, with the first context used for all new SSL
+-  // objects. For server contexts, once we have ClientHello, we
+-  // potentially switch to a different CertificateContext based on certificate
+-  // selection.
+-  std::vector<TlsContext> tls_contexts_;
++  // Use a single context for certificates instead of one context per certificate as in the BoringSSL case.
++  // A single context is required to hold all certificates for OpenSSL.
++  // The use of certificate selection is handled by OpenSSL.
++  TlsContext tls_context_;
+   bool verify_trusted_ca_{false};
+   std::vector<std::string> verify_subject_alt_name_list_;
+   std::vector<std::vector<uint8_t>> verify_certificate_hash_list_;
+@@ -213,10 +215,10 @@ private:
+                          unsigned int inlen);
+   int sessionTicketProcess(SSL* ssl, uint8_t* key_name, uint8_t* iv, EVP_CIPHER_CTX* ctx,
+                            HMAC_CTX* hmac_ctx, int encrypt);
+-  bool isClientEcdsaCapable(const SSL_CLIENT_HELLO* ssl_client_hello);
+-  // Select the TLS certificate context in SSL_CTX_set_select_certificate_cb() callback with
+-  // ClientHello details.
+-  enum ssl_select_cert_result_t selectTlsContext(const SSL_CLIENT_HELLO* ssl_client_hello);
++
++  // bool isClientEcdsaCapable(SSL *ssl);
++  // int cert_cb(SSL* ssl, void *param);
++
+   void generateHashForSessionContexId(const std::vector<std::string>& server_names,
+                                       uint8_t* session_context_buf, unsigned& session_context_len);
+ 
+diff --git a/source/extensions/transport_sockets/tls/context_manager_impl.h b/source/extensions/transport_sockets/tls/context_manager_impl.h
+index d08e12e974..a3c0a02931 100644
+--- a/source/extensions/transport_sockets/tls/context_manager_impl.h
++++ b/source/extensions/transport_sockets/tls/context_manager_impl.h
+@@ -40,6 +40,7 @@ public:
+     return private_key_method_manager_;
+   };
+ 
++
+ private:
+   void removeEmptyContexts();
+   TimeSource& time_source_;
+diff --git a/source/extensions/transport_sockets/tls/openssl_impl.cc b/source/extensions/transport_sockets/tls/openssl_impl.cc
+new file mode 100644
+index 0000000000..162155f55c
+--- /dev/null
++++ b/source/extensions/transport_sockets/tls/openssl_impl.cc
+@@ -0,0 +1,170 @@
++#include "extensions/transport_sockets/tls/openssl_impl.h"
++
++#include <algorithm>
++#include <cstring>
++#include <iostream>
++#include <memory>
++#include <string>
++#include <vector>
++
++#include "openssl/crypto.h"
++#include "openssl/hmac.h"
++#include "openssl/rand.h"
++#include "openssl/ssl.h"
++#include "openssl/x509v3.h"
++
++namespace Envoy {
++namespace Extensions {
++namespace TransportSockets {
++namespace Tls {
++
++int alpnSelectCallback(std::vector<uint8_t> parsed_alpn_protocols, const unsigned char** out,
++                       unsigned char* outlen, const unsigned char* in, unsigned int inlen) {
++  // Currently this uses the standard selection algorithm in priority order.
++  const uint8_t* alpn_data = &parsed_alpn_protocols[0];
++  size_t alpn_data_size = parsed_alpn_protocols.size();
++
++  if (SSL_select_next_proto(const_cast<unsigned char**>(out), outlen, alpn_data, alpn_data_size, in,
++                            inlen) != OPENSSL_NPN_NEGOTIATED) {
++    return SSL_TLSEXT_ERR_NOACK;
++  } else {
++    return SSL_TLSEXT_ERR_OK;
++  }
++}
++
++auto select_client_cert_cb = +[](SSL* ssl, X509** x509, EVP_PKEY** pkey) -> int {
++  std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!! select_client_cert_cb \n";
++  return 0;
++};
++
++void set_select_certificate_cb(SSL_CTX* ctx) {
++  SSL_CTX_set_client_cert_cb(ctx, select_client_cert_cb);
++}
++
++bssl::UniquePtr<SSL> newSsl(SSL_CTX* ctx) { return bssl::UniquePtr<SSL>(SSL_new(ctx)); }
++
++int set_strict_cipher_list(SSL_CTX* ctx, const char* str) {
++  SSL_CTX_set_cipher_list(ctx, str);
++
++  STACK_OF(SSL_CIPHER)* ciphers = SSL_CTX_get_ciphers(ctx);
++  char* dup = strdup(str);
++  char* token = std::strtok(dup, ":+![|]");
++  while (token != NULL) {
++    std::string str1(token);
++    bool found = false;
++    for (int i = 0; i < sk_SSL_CIPHER_num(ciphers); i++) {
++      const SSL_CIPHER* cipher = sk_SSL_CIPHER_value(ciphers, i);
++      std::string str2(SSL_CIPHER_get_name(cipher));
++      if (str1.compare(str2) == 0) {
++        found = true;
++      }
++    }
++
++    if (!found && str1.compare("-ALL") && str1.compare("ALL")) {
++      delete dup;
++      return 0;
++    }
++
++    token = std::strtok(NULL, ":[]|");
++  }
++
++  delete dup;
++  return 1;
++}
++
++std::string getSerialNumberFromCertificate(X509* cert) {
++  ASN1_INTEGER* serial_number = X509_get_serialNumber(cert);
++  BIGNUM* num_bn(BN_new());
++  ASN1_INTEGER_to_BN(serial_number, num_bn);
++  char* char_serial_number = BN_bn2hex(num_bn);
++  BN_free(num_bn);
++  if (char_serial_number != nullptr) {
++    std::string serial_number(char_serial_number);
++
++    // openssl is uppercase, boringssl is lowercase. So convert
++    std::transform(serial_number.begin(), serial_number.end(), serial_number.begin(), ::tolower);
++
++    OPENSSL_free(char_serial_number);
++    return serial_number;
++  }
++  return "";
++}
++
++STACK_OF(X509)* SSL_get_peer_full_cert_chain(const SSL *ssl) {
++  STACK_OF(X509)* to_copy = SSL_get_peer_cert_chain(ssl);
++  if (!to_copy) {
++    return nullptr;
++  }
++  STACK_OF(X509)* ret = sk_X509_dup(SSL_get_peer_cert_chain(ssl));
++
++  if (SSL_is_server(ssl)) {
++    X509* peer_cert = SSL_get_peer_certificate(ssl);
++    if (!sk_X509_insert(ret, peer_cert, 0)) {
++      sk_X509_pop_free(ret, X509_free);
++      return nullptr;
++    }
++  }
++
++  return ret;
++}
++
++void allowRenegotiation(SSL* ssl) {
++  // SSL_set_renegotiate_mode(ssl, mode);
++}
++
++bssl::UniquePtr<STACK_OF(X509_NAME)> initX509Names() {
++  bssl::UniquePtr<STACK_OF(X509_NAME)> list(
++      sk_X509_NAME_new([](const X509_NAME* const* a, const X509_NAME* const* b) -> int {
++        return X509_NAME_cmp(*a, *b);
++      }));
++
++  return list;
++}
++
++EVP_MD_CTX* newEVP_MD_CTX() {
++  EVP_MD_CTX* md(EVP_MD_CTX_new());
++  return md;
++}
++
++SSL_SESSION* ssl_session_from_bytes(SSL* client_ssl_socket, const SSL_CTX* client_ssl_context,
++                                    const std::string& client_session) {
++  SSL_SESSION* client_ssl_session = SSL_get_session(client_ssl_socket);
++  SSL_SESSION_set_app_data(client_ssl_session, client_session.data());
++  return client_ssl_session;
++}
++
++int ssl_session_to_bytes(const SSL_SESSION* in, uint8_t** out_data, size_t* out_len) {
++  //   void *data = SSL_SESSION_get_app_data(in);
++  //   *out_data = data;
++  *out_data = static_cast<uint8_t*>(OPENSSL_malloc(1));
++  *out_len = 1;
++
++  return 1;
++}
++
++X509* getVerifyCallbackCert(X509_STORE_CTX* store_ctx, void* arg) {
++
++  X509* x509 = X509_STORE_CTX_get_current_cert(store_ctx);
++
++  if (x509 == nullptr) {
++    x509 = X509_STORE_CTX_get0_cert(store_ctx);
++  }
++
++  return x509;
++}
++
++int ssl_session_is_resumable(const SSL_SESSION* session) { return 1; }
++
++void ssl_ctx_add_client_CA(SSL_CTX* ctx, X509* x) { SSL_CTX_add_client_CA(ctx, x); }
++
++int should_be_single_use(const SSL_SESSION* session) { return 1; }
++
++// void ssl_ctx_set_client_CA_list(SSL_CTX *ctx, bssl::UniquePtr<STACK_OF(X509_NAME)> list) {
++//	if (sk_X509_NAME_num(list.get()) > 0)
++//	  SSL_CTX_set_client_CA_list(ctx, list.release());
++//}
++
++} // namespace Tls
++} // namespace TransportSockets
++} // namespace Extensions
++} // namespace Envoy
+diff --git a/source/extensions/transport_sockets/tls/openssl_impl.h b/source/extensions/transport_sockets/tls/openssl_impl.h
+new file mode 100644
+index 0000000000..bcffefe7f3
+--- /dev/null
++++ b/source/extensions/transport_sockets/tls/openssl_impl.h
+@@ -0,0 +1,57 @@
++#pragma once
++
++#include <functional>
++#include <string>
++#include <vector>
++
++#include "bssl_wrapper/bssl_wrapper.h"
++#include "openssl/ssl.h"
++
++/*
++ * MAISTRA
++ * Contains the functions where BoringSSL and OpenSSL diverge. In most cases this means that there are functions in BoringSSL that do not exist
++ * in OpenSSL
++ */
++namespace Envoy {
++namespace Extensions {
++namespace TransportSockets {
++namespace Tls {
++
++int alpnSelectCallback(std::vector<uint8_t> parsed_alpn_protocols, const unsigned char** out,
++                       unsigned char* outlen, const unsigned char* in, unsigned int inlen);
++
++void set_select_certificate_cb(SSL_CTX* ctx);
++
++// bssl::UniquePtr<SSL> newSsl(SSL_CTX *ctx);
++
++int set_strict_cipher_list(SSL_CTX* ctx, const char* str);
++
++std::string getSerialNumberFromCertificate(X509* cert);
++
++STACK_OF(X509)* SSL_get_peer_full_cert_chain(const SSL *ssl);
++
++void allowRenegotiation(SSL* ssl);
++
++bssl::UniquePtr<STACK_OF(X509_NAME)> initX509Names();
++
++EVP_MD_CTX* newEVP_MD_CTX();
++
++SSL_SESSION* ssl_session_from_bytes(SSL* client_ssl_socket, const SSL_CTX* client_ssl_context,
++                                    const std::string& client_session);
++
++int ssl_session_to_bytes(const SSL_SESSION* in, uint8_t** out_data, size_t* out_len);
++
++X509* getVerifyCallbackCert(X509_STORE_CTX* store_ctx, void* arg);
++
++int ssl_session_is_resumable(const SSL_SESSION* session);
++
++void ssl_ctx_add_client_CA(SSL_CTX* ctx, X509* x);
++
++int should_be_single_use(const SSL_SESSION* session);
++
++// void ssl_ctx_set_client_CA_list(SSL_CTX *ctx, bssl::UniquePtr<STACK_OF(X509_NAME)> list);
++
++} // namespace Tls
++} // namespace TransportSockets
++} // namespace Extensions
++} // namespace Envoy
+diff --git a/source/extensions/transport_sockets/tls/ssl_socket.cc b/source/extensions/transport_sockets/tls/ssl_socket.cc
+index 00c341a5d7..310fec261c 100644
+--- a/source/extensions/transport_sockets/tls/ssl_socket.cc
++++ b/source/extensions/transport_sockets/tls/ssl_socket.cc
+@@ -190,10 +190,11 @@ PostIoAction SslSocket::doHandshake() {
+       ENVOY_CONN_LOG(debug, "handshake expecting {}", callbacks_->connection(),
+                      err == SSL_ERROR_WANT_READ ? "read" : "write");
+       return PostIoAction::KeepOpen;
+-    case SSL_ERROR_WANT_PRIVATE_KEY_OPERATION:
+-      ENVOY_CONN_LOG(debug, "handshake continued asynchronously", callbacks_->connection());
+-      state_ = SocketState::HandshakeInProgress;
+-      return PostIoAction::KeepOpen;
++// BoringSSL-specific error code
++//    case SSL_ERROR_WANT_PRIVATE_KEY_OPERATION:
++//      ENVOY_CONN_LOG(debug, "handshake continued asynchronously", callbacks_->connection());
++//      state_ = SocketState::HandshakeInProgress;
++//      return PostIoAction::KeepOpen;
+     default:
+       ENVOY_CONN_LOG(debug, "handshake error: {}", callbacks_->connection(), err);
+       drainErrorQueue();
+diff --git a/source/extensions/transport_sockets/tls/ssl_socket.h b/source/extensions/transport_sockets/tls/ssl_socket.h
+index fd6cc57c15..4bcbfdf1ce 100644
+--- a/source/extensions/transport_sockets/tls/ssl_socket.h
++++ b/source/extensions/transport_sockets/tls/ssl_socket.h
+@@ -17,6 +17,7 @@
+ 
+ #include "absl/synchronization/mutex.h"
+ #include "absl/types/optional.h"
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/ssl.h"
+ 
+ namespace Envoy {
+diff --git a/source/extensions/transport_sockets/tls/utility.cc b/source/extensions/transport_sockets/tls/utility.cc
+index 11158a9963..38e1bd19c6 100644
+--- a/source/extensions/transport_sockets/tls/utility.cc
++++ b/source/extensions/transport_sockets/tls/utility.cc
+@@ -9,7 +9,6 @@ namespace Envoy {
+ namespace Extensions {
+ namespace TransportSockets {
+ namespace Tls {
+-
+ namespace {
+ 
+ enum class CertName { Issuer, Subject };
+@@ -68,18 +67,7 @@ inline bssl::UniquePtr<ASN1_TIME> currentASN1_Time(TimeSource& time_source) {
+ }
+ 
+ std::string Utility::getSerialNumberFromCertificate(X509& cert) {
+-  ASN1_INTEGER* serial_number = X509_get_serialNumber(&cert);
+-  BIGNUM num_bn;
+-  BN_init(&num_bn);
+-  ASN1_INTEGER_to_BN(serial_number, &num_bn);
+-  char* char_serial_number = BN_bn2hex(&num_bn);
+-  BN_free(&num_bn);
+-  if (char_serial_number != nullptr) {
+-    std::string serial_number(char_serial_number);
+-    OPENSSL_free(char_serial_number);
+-    return serial_number;
+-  }
+-  return "";
++  return Envoy::Extensions::TransportSockets::Tls::getSerialNumberFromCertificate(&cert);
+ }
+ 
+ std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {
+@@ -104,7 +92,21 @@ std::string Utility::getIssuerFromCertificate(X509& cert) {
+ }
+ 
+ std::string Utility::getSubjectFromCertificate(X509& cert) {
+-  return getRFC2253NameFromCertificate(cert, CertName::Subject);
++  bssl::UniquePtr<BIO> buf(BIO_new(BIO_s_mem()));
++  RELEASE_ASSERT(buf != nullptr, "");
++
++  // flags=XN_FLAG_RFC2253 is the documented parameter for single-line output in RFC 2253 format.
++  // Example from the RFC:
++  //   * Single value per Relative Distinguished Name (RDN): CN=Steve Kille,O=Isode Limited,C=GB
++  //   * Multivalue output in first RDN: OU=Sales+CN=J. Smith,O=Widget Inc.,C=US
++  //   * Quoted comma in Organization: CN=L. Eagle,O=Sue\, Grabbit and Runn,C=GB
++  X509_NAME_print_ex(buf.get(), X509_get_subject_name(&cert), 0 /* indent */, XN_FLAG_RFC2253);
++
++  const uint8_t* data;
++  size_t data_len;
++  int rc = BIO_mem_contents(buf.get(), &data, &data_len);
++  ASSERT(rc == 1);
++  return std::string(reinterpret_cast<const char*>(data), data_len);
+ }
+ 
+ int32_t Utility::getDaysUntilExpiration(const X509* cert, TimeSource& time_source) {
+diff --git a/source/extensions/transport_sockets/tls/utility.h b/source/extensions/transport_sockets/tls/utility.h
+index 9aa17bb55f..bbf70d98e1 100644
+--- a/source/extensions/transport_sockets/tls/utility.h
++++ b/source/extensions/transport_sockets/tls/utility.h
+@@ -5,6 +5,9 @@
+ 
+ #include "common/common/utility.h"
+ 
++#include "extensions/transport_sockets/tls/openssl_impl.h"
++
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/ssl.h"
+ 
+ namespace Envoy {
+diff --git a/test/common/config/BUILD b/test/common/config/BUILD
+index 2e492f539d..6d276075eb 100644
+--- a/test/common/config/BUILD
++++ b/test/common/config/BUILD
+@@ -7,12 +7,16 @@ load(
+     "envoy_package",
+     "envoy_proto_library",
+ )
++load(
++    "//test/extensions:extensions_build_system.bzl",
++    "envoy_extension_cc_test",
++)
+ load(
+     "//source/extensions:all_extensions.bzl",
+     "envoy_all_extensions",
+     "envoy_windows_extensions",
+ )
+-load("//bazel:repositories.bzl", "NOBORINGSSL_SKIP_TARGETS", "PPC_SKIP_TARGETS")
++load("//bazel:repositories.bzl", "PPC_SKIP_TARGETS")
+ 
+ envoy_package()
+ 
+@@ -340,13 +344,15 @@ envoy_cc_test(
+     ],
+ )
+ 
+-envoy_cc_test(
++envoy_extension_cc_test(
+     name = "datasource_test",
+     srcs = ["datasource_test.cc"],
++    extension_name = "envoy.extensions.common.crypto.utility_lib",
+     deps = [
+         "//source/common/common:empty_string",
+         "//source/common/config:datasource_lib",
+         "//source/common/protobuf:utility_lib",
++        "//source/extensions/common/crypto:utility_lib",
+         "//test/mocks/server:server_mocks",
+         "//test/mocks/upstream:upstream_mocks",
+         "//test/test_common:utility_lib",
+diff --git a/test/common/crypto/BUILD b/test/common/crypto/BUILD
+index dd89ae48ee..54d113b708 100644
+--- a/test/common/crypto/BUILD
++++ b/test/common/crypto/BUILD
+@@ -2,24 +2,28 @@ licenses(["notice"])  # Apache 2
+ 
+ load(
+     "//bazel:envoy_build_system.bzl",
+-    "envoy_cc_test",
+     "envoy_package",
+ )
++load(
++    "//test/extensions:extensions_build_system.bzl",
++    "envoy_extension_cc_test",
++)
+ 
+ envoy_package()
+ 
+-envoy_cc_test(
++envoy_extension_cc_test(
+     name = "utility_test",
+     srcs = [
+         "utility_test.cc",
+     ],
++    extension_name = "envoy.extensions.common.crypto.utility_lib",
+     external_deps = [
+         "ssl",
+     ],
+     deps = [
+-        "//bazel:crypto_utility_lib",
+         "//source/common/buffer:buffer_lib",
+         "//source/common/common:hex_lib",
+         "//source/common/crypto:utility_lib",
++        "//source/extensions/common/crypto:utility_lib",
+     ],
+ )
+diff --git a/test/common/crypto/utility_test.cc b/test/common/crypto/utility_test.cc
+index 47febbdf7c..60737db4ab 100644
+--- a/test/common/crypto/utility_test.cc
++++ b/test/common/crypto/utility_test.cc
+@@ -13,14 +13,14 @@ namespace {
+ 
+ TEST(UtilityTest, TestSha256Digest) {
+   const Buffer::OwnedImpl buffer("test data");
+-  const auto digest = Utility::getSha256Digest(buffer);
++  const auto digest = UtilitySingleton::get().getSha256Digest(buffer);
+   EXPECT_EQ("916f0027a575074ce72a331777c3478d6513f786a591bd892da1a577bf2335f9",
+             Hex::encode(digest));
+ }
+ 
+ TEST(UtilityTest, TestSha256DigestWithEmptyBuffer) {
+   const Buffer::OwnedImpl buffer;
+-  const auto digest = Utility::getSha256Digest(buffer);
++  const auto digest = UtilitySingleton::get().getSha256Digest(buffer);
+   EXPECT_EQ("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
+             Hex::encode(digest));
+ }
+@@ -28,30 +28,32 @@ TEST(UtilityTest, TestSha256DigestWithEmptyBuffer) {
+ TEST(UtilityTest, TestSha256DigestGrowingBuffer) {
+   // Adding multiple slices to the buffer
+   Buffer::OwnedImpl buffer("slice 1");
+-  auto digest = Utility::getSha256Digest(buffer);
++  auto digest = UtilitySingleton::get().getSha256Digest(buffer);
+   EXPECT_EQ("76571770bb46bdf51e1aba95b23c681fda27f6ae56a8a90898a4cb7556e19dcb",
+             Hex::encode(digest));
+   buffer.add("slice 2");
+-  digest = Utility::getSha256Digest(buffer);
++  digest = UtilitySingleton::get().getSha256Digest(buffer);
+   EXPECT_EQ("290b462b0fe5edcf6b8532de3ca70da8ab77937212042bb959192ec6c9f95b9a",
+             Hex::encode(digest));
+   buffer.add("slice 3");
+-  digest = Utility::getSha256Digest(buffer);
++  digest = UtilitySingleton::get().getSha256Digest(buffer);
+   EXPECT_EQ("29606bbf02fdc40007cdf799de36d931e3587dafc086937efd6599a4ea9397aa",
+             Hex::encode(digest));
+ }
+ 
+ TEST(UtilityTest, TestSha256Hmac) {
+   const std::string key = "key";
+-  auto hmac = Utility::getSha256Hmac(std::vector<uint8_t>(key.begin(), key.end()), "test data");
++  auto hmac = UtilitySingleton::get().getSha256Hmac(std::vector<uint8_t>(key.begin(), key.end()),
++                                                    "test data");
+   EXPECT_EQ("087d9eb992628854842ca4dbf790f8164c80355c1e78b72789d830334927a84c", Hex::encode(hmac));
+ }
+ 
+ TEST(UtilityTest, TestSha256HmacWithEmptyArguments) {
+-  auto hmac = Utility::getSha256Hmac(std::vector<uint8_t>(), "");
++  auto hmac = UtilitySingleton::get().getSha256Hmac(std::vector<uint8_t>(), "");
+   EXPECT_EQ("b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad", Hex::encode(hmac));
+ }
+ 
++// TODO (dmitri-d) re-enabled when importPublicKey OpenSSL-compatible implementation has been added
+ TEST(UtilityTest, TestImportPublicKey) {
+   auto key = "30820122300d06092a864886f70d01010105000382010f003082010a0282010100a7471266d01d160308d"
+              "73409c06f2e8d35c531c458d3e480e9f3191847d062ec5ccff7bc51e949d5f2c3540c189a4eca1e8633a6"
+@@ -62,18 +64,19 @@ TEST(UtilityTest, TestImportPublicKey) {
+              "183f550dac19abcf1145a7f9ced987db680e4a229cac75dee347ec9ebce1fc3dbbbb0203010001";
+ 
+   Common::Crypto::CryptoObjectPtr crypto_ptr(
+-      Common::Crypto::Utility::importPublicKey(Hex::decode(key)));
++      Common::Crypto::UtilitySingleton::get().importPublicKey(Hex::decode(key)));
+   auto wrapper = Common::Crypto::Access::getTyped<Common::Crypto::PublicKeyObject>(*crypto_ptr);
+   EVP_PKEY* pkey = wrapper->getEVP_PKEY();
+   EXPECT_NE(nullptr, pkey);
+ 
+   key = "badkey";
+-  crypto_ptr = Common::Crypto::Utility::importPublicKey(Hex::decode(key));
++  crypto_ptr = Common::Crypto::UtilitySingleton::get().importPublicKey(Hex::decode(key));
+   wrapper = Common::Crypto::Access::getTyped<Common::Crypto::PublicKeyObject>(*crypto_ptr);
+   pkey = wrapper->getEVP_PKEY();
+   EXPECT_EQ(nullptr, pkey);
+ }
+ 
++// TODO (dmitri-d) re-enabled when importPublicKey OpenSSL-compatible implementation has been added
+ TEST(UtilityTest, TestVerifySignature) {
+   auto key = "30820122300d06092a864886f70d01010105000382010f003082010a0282010100a7471266d01d160308d"
+              "73409c06f2e8d35c531c458d3e480e9f3191847d062ec5ccff7bc51e949d5f2c3540c189a4eca1e8633a6"
+@@ -93,35 +96,35 @@ TEST(UtilityTest, TestVerifySignature) {
+   auto data = "hello";
+ 
+   Common::Crypto::CryptoObjectPtr crypto_ptr(
+-      Common::Crypto::Utility::importPublicKey(Hex::decode(key)));
++      Common::Crypto::UtilitySingleton::get().importPublicKey(Hex::decode(key)));
+   Common::Crypto::CryptoObject* crypto(crypto_ptr.get());
+ 
+   std::vector<uint8_t> text(data, data + strlen(data));
+ 
+   auto sig = Hex::decode(signature);
+-  auto result = Utility::verifySignature(hash_func, *crypto, sig, text);
++  auto result = UtilitySingleton::get().verifySignature(hash_func, *crypto, sig, text);
+ 
+   EXPECT_EQ(true, result.result_);
+   EXPECT_EQ("", result.error_message_);
+ 
+-  result = Utility::verifySignature("unknown", *crypto, sig, text);
++  result = UtilitySingleton::get().verifySignature("unknown", *crypto, sig, text);
+   EXPECT_EQ(false, result.result_);
+   EXPECT_EQ("unknown is not supported.", result.error_message_);
+ 
+   PublicKeyObject* empty_crypto = new PublicKeyObject();
+-  result = Utility::verifySignature(hash_func, *empty_crypto, sig, text);
++  result = UtilitySingleton::get().verifySignature(hash_func, *empty_crypto, sig, text);
+   EXPECT_EQ(false, result.result_);
+   EXPECT_EQ("Failed to initialize digest verify.", result.error_message_);
+ 
+   data = "baddata";
+   text = std::vector<uint8_t>(data, data + strlen(data));
+-  result = Utility::verifySignature(hash_func, *crypto, sig, text);
++  result = UtilitySingleton::get().verifySignature(hash_func, *crypto, sig, text);
+   EXPECT_EQ(false, result.result_);
+   EXPECT_EQ("Failed to verify digest. Error code: 0", result.error_message_);
+ 
+   data = "hello";
+   text = std::vector<uint8_t>(data, data + strlen(data));
+-  result = Utility::verifySignature(hash_func, *crypto, Hex::decode("000000"), text);
++  result = UtilitySingleton::get().verifySignature(hash_func, *crypto, Hex::decode("000000"), text);
+   EXPECT_EQ(false, result.result_);
+   EXPECT_EQ("Failed to verify digest. Error code: 0", result.error_message_);
+ }
+diff --git a/test/common/network/connection_impl_test.cc b/test/common/network/connection_impl_test.cc
+index 272884e3f5..5f9a6dadcc 100644
+--- a/test/common/network/connection_impl_test.cc
++++ b/test/common/network/connection_impl_test.cc
+@@ -570,15 +570,38 @@ TEST_P(ConnectionImplTest, KickUndone) {
+   disconnect(true);
+ }
+ 
+-// Regression test for (at least one failure mode of)
+-// https://github.com/envoyproxy/envoy/issues/3639 where readDisable on a close
+-// connection caused a crash.
+-TEST_P(ConnectionImplTest, ReadDisableAfterClose) {
++// Ensure that calls to readDisable on a closed connection are handled gracefully. Known past issues
++// include a crash on https://github.com/envoyproxy/envoy/issues/3639, and ASSERT failure followed
++// by infinite loop in https://github.com/envoyproxy/envoy/issues/9508
++TEST_P(ConnectionImplTest, ReadDisableAfterCloseHandledGracefully) {
+   setUpBasicConnection();
+-  disconnect(false);
+ 
++  client_connection_->readDisable(true);
++  client_connection_->readDisable(false);
++
++  client_connection_->readDisable(true);
++  client_connection_->readDisable(true);
++  client_connection_->readDisable(false);
++  client_connection_->readDisable(false);
++
++  client_connection_->readDisable(true);
++  client_connection_->readDisable(true);
++  disconnect(false);
++#ifndef NDEBUG
++  // When running in debug mode, verify that calls to readDisable and readEnabled on a closed socket
++  // trigger ASSERT failures.
++  EXPECT_DEBUG_DEATH(client_connection_->readEnabled(), "");
+   EXPECT_DEBUG_DEATH(client_connection_->readDisable(true), "");
+   EXPECT_DEBUG_DEATH(client_connection_->readDisable(false), "");
++#else
++  // When running in release mode, verify that calls to readDisable change the readEnabled state.
++  client_connection_->readDisable(false);
++  client_connection_->readDisable(true);
++  client_connection_->readDisable(false);
++  EXPECT_FALSE(client_connection_->readEnabled());
++  client_connection_->readDisable(false);
++  EXPECT_TRUE(client_connection_->readEnabled());
++#endif
+ }
+ 
+ TEST_P(ConnectionImplTest, EarlyCloseOnReadDisabledConnection) {
+diff --git a/test/extensions/filters/http/lua/lua_filter_test.cc b/test/extensions/filters/http/lua/lua_filter_test.cc
+index 5d96c613a8..18c3ee8192 100644
+--- a/test/extensions/filters/http/lua/lua_filter_test.cc
++++ b/test/extensions/filters/http/lua/lua_filter_test.cc
+@@ -1607,6 +1607,7 @@ TEST_F(LuaHttpFilterTest, CheckConnection) {
+   EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
+ }
+ 
++// TODO (dmitri-d) re-enable after importPublicKey method has been fixed
+ TEST_F(LuaHttpFilterTest, ImportPublicKey) {
+   const std::string SCRIPT{R"EOF(
+     function string.fromhex(str)
+@@ -1636,6 +1637,7 @@ TEST_F(LuaHttpFilterTest, ImportPublicKey) {
+   EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
+ }
+ 
++// TODO (dmitri-d) re-enable when importPublicKey has been fixed
+ TEST_F(LuaHttpFilterTest, InvalidPublicKey) {
+   const std::string SCRIPT{R"EOF(
+     function string.fromhex(str)
+@@ -1665,6 +1667,7 @@ TEST_F(LuaHttpFilterTest, InvalidPublicKey) {
+   EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->decodeHeaders(request_headers, true));
+ }
+ 
++// TODO (dmitri-d) re-enable when importPublicKey has been fixed
+ TEST_F(LuaHttpFilterTest, SignatureVerify) {
+   const std::string SCRIPT{R"EOF(
+     function string.fromhex(str)
+diff --git a/test/extensions/filters/http/lua/lua_integration_test.cc b/test/extensions/filters/http/lua/lua_integration_test.cc
+index 043d2d33dd..cb27dff648 100644
+--- a/test/extensions/filters/http/lua/lua_integration_test.cc
++++ b/test/extensions/filters/http/lua/lua_integration_test.cc
+@@ -421,6 +421,7 @@ typed_config:
+   cleanup();
+ }
+ 
++// TODO (dmitri-d) re-enable when importPublicKey method is added
+ // Basic test for verifying signature.
+ TEST_P(LuaIntegrationTest, SignatureVerification) {
+   const std::string FILTER_AND_CODE =
+@@ -469,7 +470,7 @@ typed_config:
+       local sig = request_handle:headers():get("signature")
+       local rawsig = sig:fromhex()
+       local data = request_handle:headers():get("message")
+-      local ok, error = request_handle:verifySignature(hash, pubkey, rawsig, string.len(rawsig), data, string.len(data)) 
++      local ok, error = request_handle:verifySignature(hash, pubkey, rawsig, string.len(rawsig), data, string.len(data))
+ 
+       if ok then
+         request_handle:headers():add("signature_verification", "approved")
+diff --git a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
+index 9184220073..b9642677e8 100644
+--- a/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
++++ b/test/extensions/filters/listener/proxy_protocol/proxy_protocol_test.cc
+@@ -158,6 +158,7 @@ public:
+   Api::ApiPtr api_;
+   Event::DispatcherPtr dispatcher_;
+   Network::TcpListenSocket socket_;
++  Network::NopConnectionBalancerImpl connection_balancer_;
+   Network::ConnectionHandlerPtr connection_handler_;
+   Network::MockFilterChainFactory factory_;
+   Network::ClientConnectionPtr conn_;
+@@ -167,7 +168,6 @@ public:
+   std::shared_ptr<Network::MockReadFilter> read_filter_;
+   std::string name_;
+   const Network::FilterChainSharedPtr filter_chain_;
+-  Network::NopConnectionBalancerImpl connection_balancer_;
+ };
+ 
+ // Parameterize the listener socket address version.
+@@ -175,6 +175,8 @@ INSTANTIATE_TEST_SUITE_P(IpVersions, ProxyProtocolTest,
+                          testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
+                          TestUtility::ipTestParamsToString);
+ 
++// TODO (dmitri-d) Fix "pure virtual method called" thrown in the ~ActiveTcpListener()
++// looks like connection_balancer_ is being deallocated before the listener, or something similar
+ TEST_P(ProxyProtocolTest, v1Basic) {
+   connect();
+   write("PROXY TCP4 1.2.3.4 253.253.253.253 65535 1234\r\nmore data");
+@@ -986,6 +988,7 @@ public:
+   Event::DispatcherPtr dispatcher_;
+   Network::TcpListenSocket socket_;
+   Network::Address::InstanceConstSharedPtr local_dst_address_;
++  Network::NopConnectionBalancerImpl connection_balancer_;
+   Network::ConnectionHandlerPtr connection_handler_;
+   Network::MockFilterChainFactory factory_;
+   Network::ClientConnectionPtr conn_;
+@@ -995,7 +998,6 @@ public:
+   std::shared_ptr<Network::MockReadFilter> read_filter_;
+   std::string name_;
+   const Network::FilterChainSharedPtr filter_chain_;
+-  Network::NopConnectionBalancerImpl connection_balancer_;
+ };
+ 
+ // Parameterize the listener socket address version.
+@@ -1029,6 +1031,7 @@ TEST_P(WildcardProxyProtocolTest, BasicV6) {
+   disconnect();
+ }
+ 
++
+ } // namespace
+ } // namespace ProxyProtocol
+ } // namespace ListenerFilters
+diff --git a/test/extensions/filters/listener/tls_inspector/BUILD b/test/extensions/filters/listener/tls_inspector/BUILD
+index 2e467fe6ba..d936cd25c8 100644
+--- a/test/extensions/filters/listener/tls_inspector/BUILD
++++ b/test/extensions/filters/listener/tls_inspector/BUILD
+@@ -45,7 +45,10 @@ envoy_cc_library(
+     name = "tls_utility_lib",
+     srcs = ["tls_utility.cc"],
+     hdrs = ["tls_utility.h"],
+-    external_deps = ["ssl"],
++    external_deps = [
++        "ssl",
++        "bssl_wrapper_lib",
++    ],
+     deps = [
+         "//source/common/common:assert_lib",
+     ],
+diff --git a/test/extensions/filters/listener/tls_inspector/tls_utility.cc b/test/extensions/filters/listener/tls_inspector/tls_utility.cc
+index 70ed11b1f4..a4d5b3f96d 100644
+--- a/test/extensions/filters/listener/tls_inspector/tls_utility.cc
++++ b/test/extensions/filters/listener/tls_inspector/tls_utility.cc
+@@ -2,6 +2,7 @@
+ 
+ #include "common/common/assert.h"
+ 
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "openssl/ssl.h"
+ 
+ namespace Envoy {
+@@ -9,8 +10,9 @@ namespace Tls {
+ namespace Test {
+ 
+ std::vector<uint8_t> generateClientHello(uint16_t tls_min_version, uint16_t tls_max_version,
+-                                         const std::string& sni_name, const std::string& alpn) {
+-  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_with_buffers_method()));
++		                         const std::string& sni_name, const std::string& alpn) {
++  // TODO (dmitri-d) add an implementation of TLS_with_buffers_method to bssl_wrapper
++  bssl::UniquePtr<SSL_CTX> ctx(SSL_CTX_new(TLS_method()));
+ 
+   SSL_CTX_set_min_proto_version(ctx.get(), tls_min_version);
+   SSL_CTX_set_max_proto_version(ctx.get(), tls_max_version);
+diff --git a/test/extensions/quic_listeners/quiche/BUILD b/test/extensions/quic_listeners/quiche/BUILD
+deleted file mode 100644
+index 418fb2676f..0000000000
+--- a/test/extensions/quic_listeners/quiche/BUILD
++++ /dev/null
+@@ -1,182 +0,0 @@
+-licenses(["notice"])  # Apache 2
+-
+-load(
+-    "//bazel:envoy_build_system.bzl",
+-    "envoy_cc_fuzz_test",
+-    "envoy_cc_test",
+-    "envoy_cc_test_binary",
+-    "envoy_cc_test_library",
+-    "envoy_package",
+-    "envoy_proto_library",
+-)
+-
+-envoy_package()
+-
+-envoy_cc_test(
+-    name = "envoy_quic_alarm_test",
+-    srcs = ["envoy_quic_alarm_test.cc"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_alarm_factory_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_alarm_lib",
+-        "//source/extensions/quic_listeners/quiche/platform:envoy_quic_clock_lib",
+-        "//test/test_common:simulated_time_system_lib",
+-        "//test/test_common:utility_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_writer_test",
+-    srcs = ["envoy_quic_writer_test.cc"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/common/network:io_socket_error_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_packet_writer_lib",
+-        "//test/mocks/api:api_mocks",
+-        "//test/mocks/network:network_mocks",
+-        "//test/test_common:threadsafe_singleton_injector_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_proof_source_test",
+-    srcs = ["envoy_quic_proof_source_test.cc"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_source_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_verifier_lib",
+-        "@com_googlesource_quiche//:quic_core_versions_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_server_stream_test",
+-    srcs = ["envoy_quic_server_stream_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_test_utils_for_envoy_lib",
+-        "//source/common/http:headers_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_alarm_factory_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_connection_helper_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_server_connection_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_server_stream_lib",
+-        "//test/mocks/http:stream_decoder_mock",
+-        "//test/mocks/network:network_mocks",
+-        "//test/test_common:utility_lib",
+-        "@com_googlesource_quiche//:quic_core_http_spdy_session_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_server_session_test",
+-    srcs = ["envoy_quic_server_session_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_test_utils_for_envoy_lib",
+-        "//include/envoy/stats:stats_macros",
+-        "//source/extensions/quic_listeners/quiche:codec_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_alarm_factory_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_connection_helper_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_source_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_server_connection_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_server_session_lib",
+-        "//source/server:configuration_lib",
+-        "//test/mocks/event:event_mocks",
+-        "//test/mocks/http:http_mocks",
+-        "//test/mocks/http:stream_decoder_mock",
+-        "//test/mocks/network:network_mocks",
+-        "//test/mocks/stats:stats_mocks",
+-        "//test/test_common:global_lib",
+-        "//test/test_common:logging_lib",
+-        "//test/test_common:simulated_time_system_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "active_quic_listener_test",
+-    srcs = ["active_quic_listener_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_test_utils_for_envoy_lib",
+-        "//source/extensions/quic_listeners/quiche:active_quic_listener_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_utils_lib",
+-        "//source/server:configuration_lib",
+-        "//test/mocks/network:network_mocks",
+-        "//test/test_common:environment_lib",
+-        "//test/test_common:network_utility_lib",
+-        "//test/test_common:simulated_time_system_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_dispatcher_test",
+-    srcs = ["envoy_quic_dispatcher_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_test_utils_for_envoy_lib",
+-        "//include/envoy/stats:stats_macros",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_alarm_factory_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_connection_helper_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_dispatcher_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_source_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_server_session_lib",
+-        "//source/server:configuration_lib",
+-        "//test/mocks/event:event_mocks",
+-        "//test/mocks/http:http_mocks",
+-        "//test/mocks/network:network_mocks",
+-        "//test/mocks/stats:stats_mocks",
+-        "//test/test_common:environment_lib",
+-        "//test/test_common:global_lib",
+-        "//test/test_common:simulated_time_system_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_test_utils_for_envoy_lib",
+-    srcs = ["crypto_test_utils_for_envoy.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_source_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_proof_verifier_lib",
+-        "@com_googlesource_quiche//:quic_test_tools_test_utils_interface_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "quic_io_handle_wrapper_test",
+-    srcs = ["quic_io_handle_wrapper_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche:quic_io_handle_wrapper_lib",
+-        "//test/mocks/api:api_mocks",
+-        "//test/mocks/network:network_mocks",
+-        "//test/test_common:threadsafe_singleton_injector_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_utils_test",
+-    srcs = ["envoy_quic_utils_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_test_utils_for_envoy_lib",
+-        "//source/extensions/quic_listeners/quiche:envoy_quic_utils_lib",
+-        "//test/mocks/api:api_mocks",
+-        "//test/test_common:threadsafe_singleton_injector_lib",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "active_quic_listener_config_test",
+-    srcs = ["active_quic_listener_config_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/common/config:utility_lib",
+-        "//source/extensions/quic_listeners/quiche:active_quic_listener_config_lib",
+-        "//test/test_common:utility_lib",
+-        "@envoy_api//envoy/api/v2/listener:pkg_cc_proto",
+-    ],
+-)
+diff --git a/test/extensions/quic_listeners/quiche/active_quic_listener_config_test.cc b/test/extensions/quic_listeners/quiche/active_quic_listener_config_test.cc
+deleted file mode 100644
+index 6f0c0e4696..0000000000
+--- a/test/extensions/quic_listeners/quiche/active_quic_listener_config_test.cc
++++ /dev/null
+@@ -1,48 +0,0 @@
+-#include "envoy/api/v2/listener/quic_config.pb.h"
+-
+-#include "common/config/utility.h"
+-
+-#include "extensions/quic_listeners/quiche/active_quic_listener.h"
+-#include "extensions/quic_listeners/quiche/active_quic_listener_config.h"
+-
+-#include "test/test_common/utility.h"
+-
+-#include "gtest/gtest.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class ActiveQuicListenerFactoryPeer {
+-public:
+-  static quic::QuicConfig& quicConfig(ActiveQuicListenerFactory& factory) {
+-    return factory.quic_config_;
+-  }
+-};
+-
+-TEST(ActiveQuicListenerConfigTest, CreateActiveQuicListenerFactory) {
+-  std::string listener_name = QuicListenerName;
+-  auto& config_factory =
+-      Config::Utility::getAndCheckFactory<Server::ActiveUdpListenerConfigFactory>(listener_name);
+-  ProtobufTypes::MessagePtr config = config_factory.createEmptyConfigProto();
+-
+-  std::string yaml = R"EOF(
+-    max_concurrent_streams: 10
+-    idle_timeout: {
+-      seconds: 2
+-    }
+-  )EOF";
+-  TestUtility::loadFromYaml(yaml, *config);
+-  Network::ActiveUdpListenerFactoryPtr listener_factory =
+-      config_factory.createActiveUdpListenerFactory(*config);
+-  EXPECT_NE(nullptr, listener_factory);
+-  quic::QuicConfig& quic_config = ActiveQuicListenerFactoryPeer::quicConfig(
+-      dynamic_cast<ActiveQuicListenerFactory&>(*listener_factory));
+-  EXPECT_EQ(10u, quic_config.GetMaxIncomingBidirectionalStreamsToSend());
+-  EXPECT_EQ(10u, quic_config.GetMaxIncomingUnidirectionalStreamsToSend());
+-  EXPECT_EQ(2000u, quic_config.IdleNetworkTimeout().ToMilliseconds());
+-  // Default value if not present in config.
+-  EXPECT_EQ(20000u, quic_config.max_time_before_crypto_handshake().ToMilliseconds());
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/active_quic_listener_test.cc b/test/extensions/quic_listeners/quiche/active_quic_listener_test.cc
+deleted file mode 100644
+index 588eb080f6..0000000000
+--- a/test/extensions/quic_listeners/quiche/active_quic_listener_test.cc
++++ /dev/null
+@@ -1,188 +0,0 @@
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/crypto/crypto_protocol.h"
+-#include "quiche/quic/test_tools/crypto_test_utils.h"
+-#include "quiche/quic/test_tools/quic_test_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "server/configuration_impl.h"
+-#include "common/common/logger.h"
+-#include "common/network/listen_socket_impl.h"
+-#include "common/network/socket_option_factory.h"
+-#include "extensions/quic_listeners/quiche/active_quic_listener.h"
+-#include "test/test_common/simulated_time_system.h"
+-#include "test/test_common/environment.h"
+-#include "test/mocks/network/mocks.h"
+-#include "test/test_common/utility.h"
+-#include "test/test_common/network_utility.h"
+-#include "gtest/gtest.h"
+-#include "gmock/gmock.h"
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-
+-using testing::Return;
+-using testing::ReturnRef;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class ActiveQuicListenerPeer {
+-public:
+-  static EnvoyQuicDispatcher* quic_dispatcher(ActiveQuicListener& listener) {
+-    return listener.quic_dispatcher_.get();
+-  }
+-
+-  static quic::QuicCryptoServerConfig& crypto_config(ActiveQuicListener& listener) {
+-    return *listener.crypto_config_;
+-  }
+-};
+-
+-class ActiveQuicListenerTest : public testing::TestWithParam<Network::Address::IpVersion> {
+-public:
+-  ActiveQuicListenerTest()
+-      : version_(GetParam()), api_(Api::createApiForTest(simulated_time_system_)),
+-        dispatcher_(api_->allocateDispatcher()), read_filter_(new Network::MockReadFilter()),
+-        filter_factory_({[this](Network::FilterManager& filter_manager) {
+-          filter_manager.addReadFilter(read_filter_);
+-          read_filter_->callbacks_->connection().addConnectionCallbacks(
+-              network_connection_callbacks_);
+-        }}),
+-        connection_handler_(*dispatcher_, "test_thread") {}
+-
+-  void SetUp() override {
+-    listen_socket_ = std::make_unique<Network::NetworkListenSocket<
+-        Network::NetworkSocketTrait<Network::Address::SocketType::Datagram>>>(
+-        Network::Test::getCanonicalLoopbackAddress(version_), nullptr, /*bind*/ true);
+-    listen_socket_->addOptions(Network::SocketOptionFactory::buildIpPacketInfoOptions());
+-    listen_socket_->addOptions(Network::SocketOptionFactory::buildRxQueueOverFlowOptions());
+-    client_socket_ = std::make_unique<Network::NetworkListenSocket<
+-        Network::NetworkSocketTrait<Network::Address::SocketType::Datagram>>>(
+-        Network::Test::getCanonicalLoopbackAddress(version_), nullptr, /*bind*/ false);
+-    EXPECT_CALL(listener_config_, socket()).WillRepeatedly(ReturnRef(*listen_socket_));
+-    ON_CALL(listener_config_, filterChainManager()).WillByDefault(ReturnRef(filter_chain_manager_));
+-    ON_CALL(filter_chain_manager_, findFilterChain(_)).WillByDefault(Return(&filter_chain_));
+-    ON_CALL(filter_chain_, networkFilterFactories()).WillByDefault(ReturnRef(filter_factory_));
+-    ON_CALL(listener_config_.filter_chain_factory_, createNetworkFilterChain(_, _))
+-        .WillByDefault(Invoke([](Network::Connection& connection,
+-                                 const std::vector<Network::FilterFactoryCb>& filter_factories) {
+-          EXPECT_EQ(1u, filter_factories.size());
+-          Server::Configuration::FilterChainUtility::buildFilterChain(connection, filter_factories);
+-          return true;
+-        }));
+-
+-    quic_listener_ = std::make_unique<ActiveQuicListener>(*dispatcher_, connection_handler_,
+-                                                          listener_config_, quic_config_);
+-    simulated_time_system_.sleep(std::chrono::milliseconds(100));
+-  }
+-
+-  void TearDown() override {
+-    quic_listener_->onListenerShutdown();
+-    // Trigger alarm to fire before listener destruction.
+-    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
+-  }
+-
+-protected:
+-  Network::Address::IpVersion version_;
+-  Event::SimulatedTimeSystemHelper simulated_time_system_;
+-  Api::ApiPtr api_;
+-  Event::DispatcherPtr dispatcher_;
+-  Network::SocketPtr listen_socket_;
+-  Network::SocketPtr client_socket_;
+-  std::shared_ptr<Network::MockReadFilter> read_filter_;
+-  Network::MockConnectionCallbacks network_connection_callbacks_;
+-  std::vector<Network::FilterFactoryCb> filter_factory_;
+-  Network::MockFilterChain filter_chain_;
+-  Network::MockFilterChainManager filter_chain_manager_;
+-  NiceMock<Network::MockListenerConfig> listener_config_;
+-  quic::QuicConfig quic_config_;
+-  Server::ConnectionHandlerImpl connection_handler_;
+-  std::unique_ptr<ActiveQuicListener> quic_listener_;
+-};
+-
+-INSTANTIATE_TEST_SUITE_P(IpVersions, ActiveQuicListenerTest,
+-                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
+-                         TestUtility::ipTestParamsToString);
+-
+-TEST_P(ActiveQuicListenerTest, ReceiveFullQuicCHLO) {
+-  quic::QuicConnectionId connection_id = quic::test::TestConnectionId(1);
+-  EnvoyQuicClock clock(*dispatcher_);
+-  quic::CryptoHandshakeMessage chlo = quic::test::crypto_test_utils::GenerateDefaultInchoateCHLO(
+-      &clock, quic::AllSupportedVersions()[0].transport_version,
+-      &ActiveQuicListenerPeer::crypto_config(*quic_listener_));
+-  chlo.SetVector(quic::kCOPT, quic::QuicTagVector{quic::kREJ});
+-  quic::CryptoHandshakeMessage full_chlo;
+-  quic::QuicReferenceCountedPointer<quic::QuicSignedServerConfig> signed_config(
+-      new quic::QuicSignedServerConfig);
+-  quic::QuicCompressedCertsCache cache(
+-      quic::QuicCompressedCertsCache::kQuicCompressedCertsCacheSize);
+-  quic::test::crypto_test_utils::GenerateFullCHLO(
+-      chlo, &ActiveQuicListenerPeer::crypto_config(*quic_listener_),
+-      envoyAddressInstanceToQuicSocketAddress(listen_socket_->localAddress()),
+-      envoyAddressInstanceToQuicSocketAddress(client_socket_->localAddress()),
+-      quic::AllSupportedVersions()[0].transport_version, &clock, signed_config, &cache, &full_chlo);
+-  // Overwrite version label to highest current supported version.
+-  full_chlo.SetVersion(quic::kVER, quic::CurrentSupportedVersions()[0]);
+-  quic::QuicConfig quic_config;
+-  quic_config.ToHandshakeMessage(&full_chlo, quic::CurrentSupportedVersions()[0].transport_version);
+-
+-  std::string packet_content(full_chlo.GetSerialized().AsStringPiece());
+-  auto encrypted_packet =
+-      std::unique_ptr<quic::QuicEncryptedPacket>(quic::test::ConstructEncryptedPacket(
+-          connection_id, quic::EmptyQuicConnectionId(), /*version_flag=*/true, /*reset_flag*/ false,
+-          /*packet_number=*/1, packet_content));
+-
+-  Buffer::RawSlice first_slice{reinterpret_cast<void*>(const_cast<char*>(encrypted_packet->data())),
+-                               encrypted_packet->length()};
+-  // Send a full CHLO to finish 0-RTT handshake.
+-  auto send_rc =
+-      client_socket_->ioHandle().sendto(first_slice, /*flags=*/0, *listen_socket_->localAddress());
+-  ASSERT_EQ(encrypted_packet->length(), send_rc.rc_);
+-
+-  EXPECT_CALL(listener_config_, filterChainManager());
+-  EXPECT_CALL(filter_chain_manager_, findFilterChain(_));
+-  EXPECT_CALL(filter_chain_, networkFilterFactories());
+-  EXPECT_CALL(listener_config_, filterChainFactory());
+-  EXPECT_CALL(listener_config_.filter_chain_factory_, createNetworkFilterChain(_, _));
+-  EXPECT_CALL(*read_filter_, onNewConnection())
+-      // Stop iteration to avoid calling getRead/WriteBuffer().
+-      .WillOnce(Invoke([this]() {
+-        dispatcher_->exit();
+-        return Network::FilterStatus::StopIteration;
+-      }));
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::Connected));
+-
+-  dispatcher_->run(Event::Dispatcher::RunType::Block);
+-
+-  Buffer::InstancePtr result_buffer(new Buffer::OwnedImpl());
+-  const uint64_t bytes_to_read = 11;
+-  uint64_t bytes_read = 0;
+-  int retry = 0;
+-
+-  do {
+-    Api::IoCallUint64Result result =
+-        result_buffer->read(client_socket_->ioHandle(), bytes_to_read - bytes_read);
+-
+-    if (result.ok()) {
+-      bytes_read += result.rc_;
+-    } else if (retry == 10 || result.err_->getErrorCode() != Api::IoError::IoErrorCode::Again) {
+-      break;
+-    }
+-
+-    if (bytes_read == bytes_to_read) {
+-      break;
+-    }
+-
+-    retry++;
+-    ::usleep(10000);
+-  } while (true);
+-  // TearDown() will close the connection.
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/crypto_test_utils_for_envoy.cc b/test/extensions/quic_listeners/quiche/crypto_test_utils_for_envoy.cc
+deleted file mode 100644
+index b3a94737a5..0000000000
+--- a/test/extensions/quic_listeners/quiche/crypto_test_utils_for_envoy.cc
++++ /dev/null
+@@ -1,39 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file defines platform dependent test utility functions which is declared
+-// in quiche/quic/test_tools/crypto_test_utils.h.
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-#pragma GCC diagnostic ignored "-Wtype-limits"
+-
+-#include "quiche/quic/test_tools/crypto_test_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <memory>
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h"
+-
+-namespace quic {
+-namespace test {
+-namespace crypto_test_utils {
+-std::unique_ptr<ProofSource> ProofSourceForTesting() {
+-  return std::make_unique<Envoy::Quic::EnvoyQuicFakeProofSource>();
+-}
+-
+-std::unique_ptr<ProofVerifier> ProofVerifierForTesting() {
+-  return std::make_unique<Envoy::Quic::EnvoyQuicFakeProofVerifier>();
+-}
+-
+-std::unique_ptr<ProofVerifyContext> ProofVerifyContextForTesting() {
+-  // No context needed for fake verifier.
+-  return nullptr;
+-}
+-
+-} // namespace crypto_test_utils
+-} // namespace test
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_alarm_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_alarm_test.cc
+deleted file mode 100644
+index 9ab3753ec8..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_alarm_test.cc
++++ /dev/null
+@@ -1,193 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-
+-#include "test/test_common/simulated_time_system.h"
+-#include "test/test_common/utility.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using Envoy::Event::Dispatcher;
+-using quic::QuicTime;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class TestDelegate : public quic::QuicAlarm::Delegate {
+-public:
+-  TestDelegate() = default;
+-
+-  // quic::QuicAlarm::Delegate
+-  void OnAlarm() override { fired_ = true; }
+-
+-  bool fired() const { return fired_; }
+-  void set_fired(bool fired) { fired_ = fired; }
+-
+-private:
+-  bool fired_{false};
+-};
+-
+-class EnvoyQuicAlarmTest : public ::testing::Test {
+-public:
+-  EnvoyQuicAlarmTest()
+-      : api_(Api::createApiForTest(time_system_)), dispatcher_(api_->allocateDispatcher()),
+-        clock_(*dispatcher_), alarm_factory_(*dispatcher_, clock_) {}
+-
+-  void advanceMsAndLoop(int64_t delay_ms) {
+-    time_system_.sleep(std::chrono::milliseconds(delay_ms));
+-    dispatcher_->run(Dispatcher::RunType::NonBlock);
+-  }
+-
+-protected:
+-  Event::SimulatedTimeSystemHelper time_system_;
+-  Api::ApiPtr api_;
+-  Event::DispatcherPtr dispatcher_;
+-  EnvoyQuicClock clock_;
+-  EnvoyQuicAlarmFactory alarm_factory_;
+-  quic::QuicConnectionArena arena_;
+-};
+-
+-TEST_F(EnvoyQuicAlarmTest, CreateAlarmByFactory) {
+-  auto unowned_delegate = new TestDelegate();
+-  quic::QuicAlarm* alarm = alarm_factory_.CreateAlarm(unowned_delegate);
+-  alarm->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  // Advance 9us, alarm shouldn't fire.
+-  advanceMsAndLoop(9);
+-  EXPECT_FALSE(unowned_delegate->fired());
+-  // Advance 1us, alarm should have fired.
+-  advanceMsAndLoop(1);
+-  EXPECT_TRUE(unowned_delegate->fired());
+-  delete alarm;
+-
+-  unowned_delegate = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm_ptr = alarm_factory_.CreateAlarm(
+-      quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate>(unowned_delegate), &arena_);
+-  EXPECT_FALSE(alarm_ptr->IsSet());
+-  unowned_delegate = new TestDelegate();
+-  alarm_ptr = alarm_factory_.CreateAlarm(
+-      quic::QuicArenaScopedPtr<quic::QuicAlarm::Delegate>(unowned_delegate), nullptr);
+-  EXPECT_FALSE(alarm_ptr->IsSet());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, CreateAlarmAndCancel) {
+-  auto unowned_delegate1 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm1(alarm_factory_.CreateAlarm(unowned_delegate1));
+-  alarm1->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  EXPECT_TRUE(alarm1->IsSet());
+-  auto unowned_delegate2 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm2(alarm_factory_.CreateAlarm(unowned_delegate2));
+-  alarm2->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  EXPECT_TRUE(alarm2->IsSet());
+-
+-  alarm1->Cancel();
+-  EXPECT_FALSE(alarm1->IsSet());
+-  // Advance 10us, alarm1 shouldn't fire, but alarm2 should.
+-  advanceMsAndLoop(10);
+-  EXPECT_TRUE(unowned_delegate2->fired());
+-  EXPECT_FALSE(unowned_delegate1->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, CreateAlarmAndReset) {
+-  auto unowned_delegate1 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm1(alarm_factory_.CreateAlarm(unowned_delegate1));
+-  alarm1->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  auto unowned_delegate2 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm2(alarm_factory_.CreateAlarm(unowned_delegate2));
+-  alarm2->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  EXPECT_TRUE(alarm2->IsSet());
+-
+-  // Reset alarm1 to a different deadline.
+-  alarm1->Cancel();
+-  alarm1->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(5));
+-  // Advance 9us, alarm1 should have fired but alarm2 shouldn't.
+-  advanceMsAndLoop(9);
+-  EXPECT_TRUE(unowned_delegate1->fired());
+-  EXPECT_FALSE(unowned_delegate2->fired());
+-
+-  advanceMsAndLoop(1);
+-  EXPECT_TRUE(unowned_delegate2->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, CreateAlarmAndUpdate) {
+-  auto unowned_delegate1 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm1(alarm_factory_.CreateAlarm(unowned_delegate1));
+-  alarm1->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  auto unowned_delegate2 = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm2(alarm_factory_.CreateAlarm(unowned_delegate2));
+-  alarm2->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  EXPECT_TRUE(alarm2->IsSet());
+-
+-  // Update alarm1 to an earlier deadline.
+-  alarm1->Update(clock_.Now() + QuicTime::Delta::FromMilliseconds(5),
+-                 quic::QuicTime::Delta::Zero());
+-  // Advance 9us, alarm1 should have fired but alarm2 shouldn't.
+-  advanceMsAndLoop(9);
+-  EXPECT_TRUE(unowned_delegate1->fired());
+-  EXPECT_FALSE(unowned_delegate2->fired());
+-
+-  advanceMsAndLoop(1);
+-  EXPECT_TRUE(unowned_delegate2->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, PostponeDeadline) {
+-  auto unowned_delegate = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm(alarm_factory_.CreateAlarm(unowned_delegate));
+-  alarm->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  advanceMsAndLoop(9);
+-  EXPECT_FALSE(unowned_delegate->fired());
+-  // Postpone deadline to a later time.
+-  alarm->Update(clock_.Now() + QuicTime::Delta::FromMilliseconds(5), quic::QuicTime::Delta::Zero());
+-  advanceMsAndLoop(1);
+-  EXPECT_EQ(10, (clock_.Now() - quic::QuicTime::Zero()).ToMilliseconds());
+-  // alarm shouldn't fire at old deadline.
+-  EXPECT_FALSE(unowned_delegate->fired());
+-
+-  advanceMsAndLoop(4);
+-  // alarm should fire at new deadline.
+-  EXPECT_TRUE(unowned_delegate->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, SetAlarmToPastTime) {
+-  advanceMsAndLoop(100);
+-  EXPECT_EQ(100, (clock_.Now() - quic::QuicTime::Zero()).ToMilliseconds());
+-  auto unowned_delegate = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm(alarm_factory_.CreateAlarm(unowned_delegate));
+-  // alarm becomes active upon Set().
+-  alarm->Set(clock_.Now() - QuicTime::Delta::FromMilliseconds(10));
+-  EXPECT_FALSE(unowned_delegate->fired());
+-  dispatcher_->run(Dispatcher::RunType::NonBlock);
+-  EXPECT_TRUE(unowned_delegate->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, UpdateAlarmWithPastDeadline) {
+-  auto unowned_delegate = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm(alarm_factory_.CreateAlarm(unowned_delegate));
+-  alarm->Set(clock_.Now() + QuicTime::Delta::FromMilliseconds(10));
+-  advanceMsAndLoop(9);
+-  EXPECT_EQ(9, (clock_.Now() - quic::QuicTime::Zero()).ToMilliseconds());
+-  EXPECT_FALSE(unowned_delegate->fired());
+-  // alarm becomes active upon Update().
+-  alarm->Update(clock_.Now() - QuicTime::Delta::FromMilliseconds(1), quic::QuicTime::Delta::Zero());
+-  dispatcher_->run(Dispatcher::RunType::NonBlock);
+-  EXPECT_TRUE(unowned_delegate->fired());
+-  unowned_delegate->set_fired(false);
+-  advanceMsAndLoop(1);
+-  // alarm shouldn't fire at the original deadline.
+-  EXPECT_FALSE(unowned_delegate->fired());
+-}
+-
+-TEST_F(EnvoyQuicAlarmTest, CancelActiveAlarm) {
+-  advanceMsAndLoop(100);
+-  EXPECT_EQ(100, (clock_.Now() - quic::QuicTime::Zero()).ToMilliseconds());
+-  auto unowned_delegate = new TestDelegate();
+-  quic::QuicArenaScopedPtr<quic::QuicAlarm> alarm(alarm_factory_.CreateAlarm(unowned_delegate));
+-  // alarm becomes active upon Set().
+-  alarm->Set(clock_.Now() - QuicTime::Delta::FromMilliseconds(10));
+-  alarm->Cancel();
+-  dispatcher_->run(Dispatcher::RunType::NonBlock);
+-  EXPECT_FALSE(unowned_delegate->fired());
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_dispatcher_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_dispatcher_test.cc
+deleted file mode 100644
+index 29ab8847b3..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_dispatcher_test.cc
++++ /dev/null
+@@ -1,264 +0,0 @@
+-#include <openssl/evp.h>
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_dispatcher.h"
+-#include "quiche/quic/test_tools/crypto_test_utils.h"
+-#include "quiche/quic/test_tools/quic_test_utils.h"
+-#include "quiche/quic/platform/api/quic_text_utils.h"
+-#pragma GCC diagnostic pop
+-
+-#include <memory>
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection_helper.h"
+-#include "common/network/listen_socket_impl.h"
+-#include "test/test_common/simulated_time_system.h"
+-#include "test/test_common/environment.h"
+-#include "test/mocks/network/mocks.h"
+-#include "test/test_common/utility.h"
+-#include "test/test_common/network_utility.h"
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_dispatcher.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "extensions/transport_sockets/well_known_names.h"
+-#include "server/configuration_impl.h"
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::Invoke;
+-using testing::Return;
+-using testing::ReturnRef;
+-
+-namespace quic {
+-namespace test {
+-class QuicDispatcherPeer {
+-public:
+-  static quic::QuicTimeWaitListManager* time_wait_list_manager(QuicDispatcher* dispatcher) {
+-    return dispatcher->time_wait_list_manager_.get();
+-  }
+-};
+-
+-} // namespace test
+-} // namespace quic
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicDispatcherTest : public testing::TestWithParam<Network::Address::IpVersion>,
+-                                protected Logger::Loggable<Logger::Id::main> {
+-public:
+-  EnvoyQuicDispatcherTest()
+-      : version_(GetParam()), api_(Api::createApiForTest(time_system_)),
+-        dispatcher_(api_->allocateDispatcher()), connection_helper_(*dispatcher_),
+-        crypto_config_(quic::QuicCryptoServerConfig::TESTING, quic::QuicRandom::GetInstance(),
+-                       std::make_unique<EnvoyQuicFakeProofSource>(),
+-                       quic::KeyExchangeSource::Default()),
+-        version_manager_(quic::CurrentSupportedVersions()),
+-        listener_stats_({ALL_LISTENER_STATS(POOL_COUNTER(listener_config_.listenerScope()),
+-                                            POOL_GAUGE(listener_config_.listenerScope()),
+-                                            POOL_HISTOGRAM(listener_config_.listenerScope()))}),
+-        connection_handler_(*dispatcher_, "test_thread"),
+-        envoy_quic_dispatcher_(
+-            &crypto_config_, quic_config_, &version_manager_,
+-            std::make_unique<EnvoyQuicConnectionHelper>(*dispatcher_),
+-            std::make_unique<EnvoyQuicAlarmFactory>(*dispatcher_, *connection_helper_.GetClock()),
+-            quic::kQuicDefaultConnectionIdLength, connection_handler_, listener_config_,
+-            listener_stats_, *dispatcher_) {
+-    auto writer = new testing::NiceMock<quic::test::MockPacketWriter>();
+-    envoy_quic_dispatcher_.InitializeWithWriter(writer);
+-    EXPECT_CALL(*writer, WritePacket(_, _, _, _, _))
+-        .WillRepeatedly(Return(quic::WriteResult(quic::WRITE_STATUS_OK, 0)));
+-  }
+-
+-  void SetUp() override {
+-    listen_socket_ = std::make_unique<Network::NetworkListenSocket<
+-        Network::NetworkSocketTrait<Network::Address::SocketType::Datagram>>>(
+-        Network::Test::getCanonicalLoopbackAddress(version_), nullptr, /*bind*/ true);
+-    // Advance time a bit because QuicTime regards 0 as uninitialized timestamp.
+-    time_system_.sleep(std::chrono::milliseconds(100));
+-    EXPECT_CALL(listener_config_, socket()).WillRepeatedly(ReturnRef(*listen_socket_));
+-  }
+-
+-  void TearDown() override {
+-    envoy_quic_dispatcher_.Shutdown();
+-    dispatcher_->run(Event::Dispatcher::RunType::NonBlock);
+-  }
+-
+-  std::unique_ptr<quic::QuicReceivedPacket>
+-  createFullChloPacket(const quic::QuicConnectionId& connection_id,
+-                       quic::QuicSocketAddress client_address) {
+-    EnvoyQuicClock clock(*dispatcher_);
+-    quic::CryptoHandshakeMessage chlo = quic::test::crypto_test_utils::GenerateDefaultInchoateCHLO(
+-        &clock, quic::AllSupportedVersions()[0].transport_version, &crypto_config_);
+-    chlo.SetVector(quic::kCOPT, quic::QuicTagVector{quic::kREJ});
+-    chlo.SetStringPiece(quic::kSNI, "www.abc.com");
+-    quic::CryptoHandshakeMessage full_chlo;
+-    quic::QuicReferenceCountedPointer<quic::QuicSignedServerConfig> signed_config(
+-        new quic::QuicSignedServerConfig);
+-    quic::QuicCompressedCertsCache cache(
+-        quic::QuicCompressedCertsCache::kQuicCompressedCertsCacheSize);
+-    quic::test::crypto_test_utils::GenerateFullCHLO(
+-        chlo, &crypto_config_,
+-        envoyAddressInstanceToQuicSocketAddress(listen_socket_->localAddress()), client_address,
+-        quic::AllSupportedVersions()[0].transport_version, &clock, signed_config, &cache,
+-        &full_chlo);
+-    // Overwrite version label to highest current supported version.
+-    full_chlo.SetVersion(quic::kVER, quic::CurrentSupportedVersions()[0]);
+-    quic::QuicConfig quic_config;
+-    quic_config.ToHandshakeMessage(&full_chlo,
+-                                   quic::CurrentSupportedVersions()[0].transport_version);
+-
+-    std::string packet_content(full_chlo.GetSerialized().AsStringPiece());
+-    std::unique_ptr<quic::QuicEncryptedPacket> encrypted_packet(
+-        quic::test::ConstructEncryptedPacket(connection_id, quic::EmptyQuicConnectionId(),
+-                                             /*version_flag=*/true, /*reset_flag*/ false,
+-                                             /*packet_number=*/1, packet_content));
+-    return std::unique_ptr<quic::QuicReceivedPacket>(
+-        quic::test::ConstructReceivedPacket(*encrypted_packet, clock.Now()));
+-  }
+-
+-protected:
+-  Network::Address::IpVersion version_;
+-  Event::SimulatedTimeSystemHelper time_system_;
+-  Api::ApiPtr api_;
+-  Event::DispatcherPtr dispatcher_;
+-  Network::SocketPtr listen_socket_;
+-  EnvoyQuicConnectionHelper connection_helper_;
+-  quic::QuicCryptoServerConfig crypto_config_;
+-  quic::QuicConfig quic_config_;
+-  quic::QuicVersionManager version_manager_;
+-
+-  testing::NiceMock<Network::MockListenerConfig> listener_config_;
+-  Server::ListenerStats listener_stats_;
+-  Server::ConnectionHandlerImpl connection_handler_;
+-  EnvoyQuicDispatcher envoy_quic_dispatcher_;
+-};
+-
+-INSTANTIATE_TEST_SUITE_P(IpVersions, EnvoyQuicDispatcherTest,
+-                         testing::ValuesIn(TestEnvironment::getIpVersionsForTest()),
+-                         TestUtility::ipTestParamsToString);
+-
+-TEST_P(EnvoyQuicDispatcherTest, CreateNewConnectionUponCHLO) {
+-  quic::SetVerbosityLogThreshold(2);
+-  quic::QuicSocketAddress peer_addr(version_ == Network::Address::IpVersion::v4
+-                                        ? quic::QuicIpAddress::Loopback4()
+-                                        : quic::QuicIpAddress::Loopback6(),
+-                                    54321);
+-  Network::MockFilterChain filter_chain;
+-  Network::MockFilterChainManager filter_chain_manager;
+-  EXPECT_CALL(listener_config_, filterChainManager()).WillOnce(ReturnRef(filter_chain_manager));
+-  EXPECT_CALL(filter_chain_manager, findFilterChain(_))
+-      .WillOnce(Invoke([&](const Network::ConnectionSocket& socket) {
+-        EXPECT_EQ(*listen_socket_->localAddress(), *socket.localAddress());
+-        EXPECT_EQ(Extensions::TransportSockets::TransportProtocolNames::get().Quic,
+-                  socket.detectedTransportProtocol());
+-        EXPECT_EQ(peer_addr, envoyAddressInstanceToQuicSocketAddress(socket.remoteAddress()));
+-        return &filter_chain;
+-      }));
+-  std::shared_ptr<Network::MockReadFilter> read_filter(new Network::MockReadFilter());
+-  Network::MockConnectionCallbacks network_connection_callbacks;
+-  std::vector<Network::FilterFactoryCb> filter_factory(
+-      {[&](Network::FilterManager& filter_manager) {
+-        filter_manager.addReadFilter(read_filter);
+-        read_filter->callbacks_->connection().addConnectionCallbacks(network_connection_callbacks);
+-      }});
+-  EXPECT_CALL(filter_chain, networkFilterFactories()).WillOnce(ReturnRef(filter_factory));
+-  EXPECT_CALL(listener_config_, filterChainFactory());
+-  EXPECT_CALL(listener_config_.filter_chain_factory_, createNetworkFilterChain(_, _))
+-      .WillOnce(Invoke([](Network::Connection& connection,
+-                          const std::vector<Network::FilterFactoryCb>& filter_factories) {
+-        EXPECT_EQ(1u, filter_factories.size());
+-        Server::Configuration::FilterChainUtility::buildFilterChain(connection, filter_factories);
+-        return true;
+-      }));
+-  EXPECT_CALL(*read_filter, onNewConnection())
+-      // Stop iteration to avoid calling getRead/WriteBuffer().
+-      .WillOnce(Invoke([]() { return Network::FilterStatus::StopIteration; }));
+-  EXPECT_CALL(network_connection_callbacks, onEvent(Network::ConnectionEvent::Connected));
+-
+-  quic::QuicConnectionId connection_id = quic::test::TestConnectionId(1);
+-  // Upon receiving a full CHLO. A new quic connection should be created and have its filter
+-  // installed based on self and peer address.
+-  std::unique_ptr<quic::QuicReceivedPacket> received_packet =
+-      createFullChloPacket(connection_id, peer_addr);
+-  envoy_quic_dispatcher_.ProcessPacket(
+-      envoyAddressInstanceToQuicSocketAddress(listen_socket_->localAddress()), peer_addr,
+-      *received_packet);
+-  EXPECT_EQ(1u, envoy_quic_dispatcher_.session_map().size());
+-  EXPECT_TRUE(
+-      envoy_quic_dispatcher_.session_map().find(connection_id)->second->IsEncryptionEstablished());
+-  EXPECT_EQ(1u, connection_handler_.numConnections());
+-  EXPECT_EQ("www.abc.com", read_filter->callbacks_->connection().requestedServerName());
+-  EXPECT_EQ(peer_addr, envoyAddressInstanceToQuicSocketAddress(
+-                           read_filter->callbacks_->connection().remoteAddress()));
+-  EXPECT_EQ(*listen_socket_->localAddress(), *read_filter->callbacks_->connection().localAddress());
+-  EXPECT_CALL(network_connection_callbacks, onEvent(Network::ConnectionEvent::LocalClose));
+-  // Shutdown() to close the connection.
+-  envoy_quic_dispatcher_.Shutdown();
+-}
+-
+-TEST_P(EnvoyQuicDispatcherTest, CloseConnectionDueToMissingFilterChain) {
+-  quic::QuicSocketAddress peer_addr(version_ == Network::Address::IpVersion::v4
+-                                        ? quic::QuicIpAddress::Loopback4()
+-                                        : quic::QuicIpAddress::Loopback6(),
+-                                    54321);
+-  Network::MockFilterChainManager filter_chain_manager;
+-  EXPECT_CALL(listener_config_, filterChainManager()).WillOnce(ReturnRef(filter_chain_manager));
+-  EXPECT_CALL(filter_chain_manager, findFilterChain(_))
+-      .WillOnce(Invoke([&](const Network::ConnectionSocket& socket) {
+-        EXPECT_EQ(*listen_socket_->localAddress(), *socket.localAddress());
+-        EXPECT_EQ(peer_addr, envoyAddressInstanceToQuicSocketAddress(socket.remoteAddress()));
+-        return nullptr;
+-      }));
+-  quic::QuicConnectionId connection_id = quic::test::TestConnectionId(1);
+-  std::unique_ptr<quic::QuicReceivedPacket> received_packet =
+-      createFullChloPacket(connection_id, peer_addr);
+-  envoy_quic_dispatcher_.ProcessPacket(
+-      envoyAddressInstanceToQuicSocketAddress(listen_socket_->localAddress()), peer_addr,
+-      *received_packet);
+-  EXPECT_EQ(0u, envoy_quic_dispatcher_.session_map().size());
+-  EXPECT_EQ(0u, connection_handler_.numConnections());
+-  EXPECT_TRUE(quic::test::QuicDispatcherPeer::time_wait_list_manager(&envoy_quic_dispatcher_)
+-                  ->IsConnectionIdInTimeWait(connection_id));
+-  EXPECT_EQ(1u, listener_stats_.no_filter_chain_match_.value());
+-}
+-
+-TEST_P(EnvoyQuicDispatcherTest, CloseConnectionDueToEmptyFilterChain) {
+-  quic::QuicSocketAddress peer_addr(version_ == Network::Address::IpVersion::v4
+-                                        ? quic::QuicIpAddress::Loopback4()
+-                                        : quic::QuicIpAddress::Loopback6(),
+-                                    54321);
+-  Network::MockFilterChain filter_chain;
+-  Network::MockFilterChainManager filter_chain_manager;
+-  EXPECT_CALL(listener_config_, filterChainManager()).WillOnce(ReturnRef(filter_chain_manager));
+-  EXPECT_CALL(filter_chain_manager, findFilterChain(_))
+-      .WillOnce(Invoke([&](const Network::ConnectionSocket& socket) {
+-        EXPECT_EQ(*listen_socket_->localAddress(), *socket.localAddress());
+-        EXPECT_EQ(peer_addr, envoyAddressInstanceToQuicSocketAddress(socket.remoteAddress()));
+-        return &filter_chain;
+-      }));
+-  // Empty filter_factory should cause connection close.
+-  std::vector<Network::FilterFactoryCb> filter_factory;
+-  EXPECT_CALL(filter_chain, networkFilterFactories()).WillOnce(ReturnRef(filter_factory));
+-
+-  quic::QuicConnectionId connection_id = quic::test::TestConnectionId(1);
+-  std::unique_ptr<quic::QuicReceivedPacket> received_packet =
+-      createFullChloPacket(connection_id, peer_addr);
+-  envoy_quic_dispatcher_.ProcessPacket(
+-      envoyAddressInstanceToQuicSocketAddress(listen_socket_->localAddress()), peer_addr,
+-      *received_packet);
+-  EXPECT_EQ(0u, envoy_quic_dispatcher_.session_map().size());
+-  EXPECT_EQ(0u, connection_handler_.numConnections());
+-  EXPECT_TRUE(quic::test::QuicDispatcherPeer::time_wait_list_manager(&envoy_quic_dispatcher_)
+-                  ->IsConnectionIdInTimeWait(connection_id));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_proof_source_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_proof_source_test.cc
+deleted file mode 100644
+index 4737a532f5..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_proof_source_test.cc
++++ /dev/null
+@@ -1,75 +0,0 @@
+-#include <string>
+-#include <vector>
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_verifier.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-namespace Envoy {
+-
+-namespace Quic {
+-
+-class TestGetProofCallback : public quic::ProofSource::Callback {
+-public:
+-  TestGetProofCallback(bool& called, std::string signature, std::string leaf_cert_scts,
+-                       std::vector<std::string> certs)
+-      : called_(called), expected_signature_(std::move(signature)),
+-        expected_leaf_certs_scts_(std::move(leaf_cert_scts)), expected_certs_(std::move(certs)) {}
+-
+-  // quic::ProofSource::Callback
+-  void Run(bool ok, const quic::QuicReferenceCountedPointer<quic::ProofSource::Chain>& chain,
+-           const quic::QuicCryptoProof& proof,
+-           std::unique_ptr<quic::ProofSource::Details> details) override {
+-    EXPECT_TRUE(ok);
+-    EXPECT_EQ(expected_signature_, proof.signature);
+-    EXPECT_EQ(expected_leaf_certs_scts_, proof.leaf_cert_scts);
+-    EXPECT_EQ(expected_certs_, chain->certs);
+-    EXPECT_EQ(nullptr, details);
+-    called_ = true;
+-  }
+-
+-private:
+-  bool& called_;
+-  std::string expected_signature_;
+-  std::string expected_leaf_certs_scts_;
+-  std::vector<std::string> expected_certs_;
+-};
+-
+-class EnvoyQuicFakeProofSourceTest : public ::testing::Test {
+-protected:
+-  std::string hostname_{"www.fake.com"};
+-  quic::QuicSocketAddress server_address_;
+-  quic::QuicTransportVersion version_{quic::QUIC_VERSION_UNSUPPORTED};
+-  quic::QuicStringPiece chlo_hash_{""};
+-  std::string server_config_{"Server Config"};
+-  std::vector<std::string> expected_certs_{"Fake cert"};
+-  std::string expected_signature_{absl::StrCat("Fake signature for { ", server_config_, " }")};
+-  EnvoyQuicFakeProofSource proof_source_;
+-  EnvoyQuicFakeProofVerifier proof_verifier_;
+-};
+-
+-TEST_F(EnvoyQuicFakeProofSourceTest, TestGetProof) {
+-  bool called = false;
+-  auto callback = std::make_unique<TestGetProofCallback>(called, expected_signature_,
+-                                                         "Fake timestamp", expected_certs_);
+-  proof_source_.GetProof(server_address_, hostname_, server_config_, version_, chlo_hash_,
+-                         std::move(callback));
+-  EXPECT_TRUE(called);
+-}
+-
+-TEST_F(EnvoyQuicFakeProofSourceTest, TestVerifyProof) {
+-  EXPECT_EQ(quic::QUIC_SUCCESS,
+-            proof_verifier_.VerifyProof(hostname_, /*port=*/0, server_config_, version_, chlo_hash_,
+-                                        expected_certs_, "Fake timestamp", expected_signature_,
+-                                        nullptr, nullptr, nullptr, nullptr));
+-  std::vector<std::string> wrong_certs{"wrong cert"};
+-  EXPECT_EQ(quic::QUIC_FAILURE,
+-            proof_verifier_.VerifyProof(hostname_, /*port=*/0, server_config_, version_, chlo_hash_,
+-                                        wrong_certs, "Fake timestamp", expected_signature_, nullptr,
+-                                        nullptr, nullptr, nullptr));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_server_session_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_server_session_test.cc
+deleted file mode 100644
+index 004e6af4f1..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_server_session_test.cc
++++ /dev/null
+@@ -1,401 +0,0 @@
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_versions.h"
+-#include "quiche/quic/test_tools/crypto_test_utils.h"
+-#include "quiche/quic/test_tools/quic_test_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <string>
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_session.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_connection.h"
+-#include "extensions/quic_listeners/quiche/codec_impl.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection_helper.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_fake_proof_source.h"
+-#include "extensions/transport_sockets/well_known_names.h"
+-
+-#include "envoy/stats/stats_macros.h"
+-#include "common/event/libevent_scheduler.h"
+-#include "server/configuration_impl.h"
+-#include "test/mocks/event/mocks.h"
+-#include "test/mocks/http/stream_decoder.h"
+-#include "test/mocks/http/mocks.h"
+-#include "test/mocks/network/mocks.h"
+-#include "test/mocks/stats/mocks.h"
+-#include "test/test_common/global.h"
+-#include "test/test_common/logging.h"
+-#include "test/test_common/simulated_time_system.h"
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::_;
+-using testing::Invoke;
+-using testing::Return;
+-using testing::ReturnRef;
+-
+-#include <iostream>
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class TestEnvoyQuicServerConnection : public EnvoyQuicServerConnection {
+-public:
+-  TestEnvoyQuicServerConnection(quic::QuicConnectionHelperInterface& helper,
+-                                quic::QuicAlarmFactory& alarm_factory,
+-                                quic::QuicPacketWriter& writer,
+-                                const quic::ParsedQuicVersionVector& supported_versions,
+-                                Network::ListenerConfig& listener_config,
+-                                Server::ListenerStats& stats)
+-      : EnvoyQuicServerConnection(quic::test::TestConnectionId(),
+-                                  quic::QuicSocketAddress(quic::QuicIpAddress::Loopback4(), 12345),
+-                                  helper, alarm_factory, &writer, /*owns_writer=*/false,
+-                                  supported_versions, listener_config, stats) {}
+-
+-  Network::Connection::ConnectionStats& connectionStats() const {
+-    return EnvoyQuicConnection::connectionStats();
+-  }
+-
+-  MOCK_METHOD2(SendConnectionClosePacket, void(quic::QuicErrorCode, const std::string&));
+-  MOCK_METHOD1(SendControlFrame, bool(const quic::QuicFrame& frame));
+-};
+-
+-class EnvoyQuicServerSessionTest : public testing::TestWithParam<bool> {
+-public:
+-  EnvoyQuicServerSessionTest()
+-      : api_(Api::createApiForTest(time_system_)), dispatcher_(api_->allocateDispatcher()),
+-        connection_helper_(*dispatcher_),
+-        alarm_factory_(*dispatcher_, *connection_helper_.GetClock()), quic_version_([]() {
+-          SetQuicReloadableFlag(quic_enable_version_99, GetParam());
+-          return quic::ParsedVersionOfIndex(quic::CurrentSupportedVersions(), 0);
+-        }()),
+-        listener_stats_({ALL_LISTENER_STATS(POOL_COUNTER(listener_config_.listenerScope()),
+-                                            POOL_GAUGE(listener_config_.listenerScope()),
+-                                            POOL_HISTOGRAM(listener_config_.listenerScope()))}),
+-        quic_connection_(new TestEnvoyQuicServerConnection(connection_helper_, alarm_factory_,
+-                                                           writer_, quic_version_, listener_config_,
+-                                                           listener_stats_)),
+-        crypto_config_(quic::QuicCryptoServerConfig::TESTING, quic::QuicRandom::GetInstance(),
+-                       std::make_unique<EnvoyQuicFakeProofSource>(),
+-                       quic::KeyExchangeSource::Default()),
+-        envoy_quic_session_(quic_config_, quic_version_,
+-                            std::unique_ptr<TestEnvoyQuicServerConnection>(quic_connection_),
+-                            /*visitor=*/nullptr, &crypto_stream_helper_, &crypto_config_,
+-                            &compressed_certs_cache_, *dispatcher_),
+-        read_filter_(new Network::MockReadFilter()) {
+-    EXPECT_EQ(time_system_.systemTime(), envoy_quic_session_.streamInfo().startTime());
+-    EXPECT_EQ(EMPTY_STRING, envoy_quic_session_.nextProtocol());
+-
+-    // Advance time and trigger update of Dispatcher::approximateMonotonicTime()
+-    // because zero QuicTime is considered uninitialized.
+-    time_system_.sleep(std::chrono::milliseconds(1));
+-    connection_helper_.GetClock()->Now();
+-
+-    ON_CALL(writer_, WritePacket(_, _, _, _, _))
+-        .WillByDefault(testing::Return(quic::WriteResult(quic::WRITE_STATUS_OK, 1)));
+-    ON_CALL(crypto_stream_helper_, CanAcceptClientHello(_, _, _, _, _)).WillByDefault(Return(true));
+-  }
+-
+-  void SetUp() override { envoy_quic_session_.Initialize(); }
+-
+-  bool installReadFilter() {
+-    // Setup read filter.
+-    envoy_quic_session_.addReadFilter(read_filter_);
+-    EXPECT_EQ(Http::Protocol::Http2,
+-              read_filter_->callbacks_->connection().streamInfo().protocol().value());
+-    EXPECT_EQ(envoy_quic_session_.id(), read_filter_->callbacks_->connection().id());
+-    EXPECT_EQ(&envoy_quic_session_, &read_filter_->callbacks_->connection());
+-    read_filter_->callbacks_->connection().addConnectionCallbacks(network_connection_callbacks_);
+-    read_filter_->callbacks_->connection().setConnectionStats(
+-        {read_total_, read_current_, write_total_, write_current_, nullptr, nullptr});
+-    EXPECT_EQ(&read_total_, &quic_connection_->connectionStats().read_total_);
+-    EXPECT_CALL(*read_filter_, onNewConnection()).WillOnce(Invoke([this]() {
+-      // Create ServerConnection instance and setup callbacks for it.
+-      http_connection_ = std::make_unique<QuicHttpServerConnectionImpl>(envoy_quic_session_,
+-                                                                        http_connection_callbacks_);
+-      EXPECT_EQ(Http::Protocol::Http2, http_connection_->protocol());
+-      // Stop iteration to avoid calling getRead/WriteBuffer().
+-      return Network::FilterStatus::StopIteration;
+-    }));
+-    return envoy_quic_session_.initializeReadFilters();
+-  }
+-
+-  void TearDown() override {
+-    if (quic_connection_->connected()) {
+-      EXPECT_CALL(*quic_connection_,
+-                  SendConnectionClosePacket(quic::QUIC_NO_ERROR, "Closed by application"));
+-      EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-      envoy_quic_session_.close(Network::ConnectionCloseType::NoFlush);
+-    }
+-  }
+-
+-protected:
+-  Event::SimulatedTimeSystemHelper time_system_;
+-  Api::ApiPtr api_;
+-  Event::DispatcherPtr dispatcher_;
+-  EnvoyQuicConnectionHelper connection_helper_;
+-  EnvoyQuicAlarmFactory alarm_factory_;
+-  quic::ParsedQuicVersionVector quic_version_;
+-  testing::NiceMock<quic::test::MockPacketWriter> writer_;
+-  testing::NiceMock<Network::MockListenerConfig> listener_config_;
+-  Server::ListenerStats listener_stats_;
+-  TestEnvoyQuicServerConnection* quic_connection_;
+-  quic::QuicConfig quic_config_;
+-  quic::QuicCryptoServerConfig crypto_config_;
+-  testing::NiceMock<quic::test::MockQuicCryptoServerStreamHelper> crypto_stream_helper_;
+-  EnvoyQuicServerSession envoy_quic_session_;
+-  quic::QuicCompressedCertsCache compressed_certs_cache_{100};
+-  std::shared_ptr<Network::MockReadFilter> read_filter_;
+-  Network::MockConnectionCallbacks network_connection_callbacks_;
+-  Http::MockServerConnectionCallbacks http_connection_callbacks_;
+-  testing::StrictMock<Stats::MockCounter> read_total_;
+-  testing::StrictMock<Stats::MockGauge> read_current_;
+-  testing::StrictMock<Stats::MockCounter> write_total_;
+-  testing::StrictMock<Stats::MockGauge> write_current_;
+-  Http::ServerConnectionPtr http_connection_;
+-};
+-
+-INSTANTIATE_TEST_SUITE_P(EnvoyQuicServerSessionTests, EnvoyQuicServerSessionTest,
+-                         testing::ValuesIn({true, false}));
+-
+-TEST_P(EnvoyQuicServerSessionTest, NewStream) {
+-  installReadFilter();
+-
+-  Http::MockStreamDecoder request_decoder;
+-  EXPECT_CALL(http_connection_callbacks_, newStream(_, false))
+-      .WillOnce(testing::ReturnRef(request_decoder));
+-  quic::QuicStreamId stream_id =
+-      quic_version_[0].transport_version == quic::QUIC_VERSION_99 ? 4u : 5u;
+-  auto stream =
+-      reinterpret_cast<quic::QuicSpdyStream*>(envoy_quic_session_.GetOrCreateStream(stream_id));
+-  // Receive a GET request on created stream.
+-  quic::QuicHeaderList headers;
+-  headers.OnHeaderBlockStart();
+-  std::string host("www.abc.com");
+-  headers.OnHeader(":authority", host);
+-  headers.OnHeader(":method", "GET");
+-  headers.OnHeader(":path", "/");
+-  headers.OnHeaderBlockEnd(/*uncompressed_header_bytes=*/0, /*compressed_header_bytes=*/0);
+-  // Request headers should be propagated to decoder.
+-  EXPECT_CALL(request_decoder, decodeHeaders_(_, /*end_stream=*/true))
+-      .WillOnce(Invoke([&host](const Http::HeaderMapPtr& decoded_headers, bool) {
+-        EXPECT_EQ(host, decoded_headers->Host()->value().getStringView());
+-        EXPECT_EQ("/", decoded_headers->Path()->value().getStringView());
+-        EXPECT_EQ(Http::Headers::get().MethodValues.Get,
+-                  decoded_headers->Method()->value().getStringView());
+-      }));
+-  EXPECT_CALL(request_decoder, decodeData(_, true))
+-      .Times(testing::AtMost(1))
+-      .WillOnce(Invoke([](Buffer::Instance& buffer, bool) { EXPECT_EQ(0, buffer.length()); }));
+-  stream->OnStreamHeaderList(/*fin=*/true, headers.uncompressed_header_bytes(), headers);
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, InvalidIncomingStreamId) {
+-  quic::SetVerbosityLogThreshold(1);
+-  installReadFilter();
+-  Http::MockStreamDecoder request_decoder;
+-  Http::MockStreamCallbacks stream_callbacks;
+-  // IETF stream 5 and G-Quic stream 2 are server initiated.
+-  quic::QuicStreamId stream_id =
+-      quic_version_[0].transport_version == quic::QUIC_VERSION_99 ? 5u : 2u;
+-  std::string data("aaaa");
+-  quic::QuicStreamFrame stream_frame(stream_id, false, 0, data);
+-  EXPECT_CALL(http_connection_callbacks_, newStream(_, false)).Times(0);
+-  EXPECT_CALL(*quic_connection_, SendConnectionClosePacket(quic::QUIC_INVALID_STREAM_ID,
+-                                                           "Data for nonexistent stream"));
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-
+-  envoy_quic_session_.OnStreamFrame(stream_frame);
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, NoNewStreamForInvalidIncomingStream) {
+-  quic::SetVerbosityLogThreshold(1);
+-  installReadFilter();
+-  Http::MockStreamDecoder request_decoder;
+-  Http::MockStreamCallbacks stream_callbacks;
+-  // IETF stream 5 and G-Quic stream 2 are server initiated.
+-  quic::QuicStreamId stream_id =
+-      quic_version_[0].transport_version == quic::QUIC_VERSION_99 ? 5u : 2u;
+-  EXPECT_CALL(http_connection_callbacks_, newStream(_, false)).Times(0);
+-  EXPECT_CALL(*quic_connection_, SendConnectionClosePacket(quic::QUIC_INVALID_STREAM_ID,
+-                                                           "Data for nonexistent stream"));
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-
+-  // Stream creation on closed connection should fail.
+-  EXPECT_EQ(nullptr, envoy_quic_session_.GetOrCreateStream(stream_id));
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, OnResetFrame) {
+-  installReadFilter();
+-  Http::MockStreamDecoder request_decoder;
+-  Http::MockStreamCallbacks stream_callbacks;
+-  EXPECT_CALL(http_connection_callbacks_, newStream(_, false))
+-      .WillRepeatedly(Invoke([&request_decoder, &stream_callbacks](Http::StreamEncoder& encoder,
+-                                                                   bool) -> Http::StreamDecoder& {
+-        encoder.getStream().addCallbacks(stream_callbacks);
+-        return request_decoder;
+-      }));
+-
+-  // G-QUIC or IETF bi-directional stream.
+-  quic::QuicStreamId stream_id =
+-      quic_version_[0].transport_version == quic::QUIC_VERSION_99 ? 4u : 5u;
+-
+-  quic::QuicStream* stream1 = envoy_quic_session_.GetOrCreateStream(stream_id);
+-  quic::QuicRstStreamFrame rst1(/*control_frame_id=*/1u, stream1->id(),
+-                                quic::QUIC_ERROR_PROCESSING_STREAM, /*bytes_written=*/0u);
+-  EXPECT_CALL(stream_callbacks, onResetStream(Http::StreamResetReason::RemoteReset, _));
+-  if (quic_version_[0].transport_version < quic::QUIC_VERSION_99) {
+-    EXPECT_CALL(*quic_connection_, SendControlFrame(_))
+-        .WillOnce(Invoke([stream_id](const quic::QuicFrame& frame) {
+-          EXPECT_EQ(stream_id, frame.rst_stream_frame->stream_id);
+-          EXPECT_EQ(quic::QUIC_RST_ACKNOWLEDGEMENT, frame.rst_stream_frame->error_code);
+-          return false;
+-        }));
+-  }
+-  stream1->OnStreamReset(rst1);
+-
+-  // G-QUIC bi-directional stream or IETF read uni-directional stream.
+-  quic::QuicStream* stream2 = envoy_quic_session_.GetOrCreateStream(stream_id + 4u);
+-  quic::QuicRstStreamFrame rst2(/*control_frame_id=*/1u, stream2->id(), quic::QUIC_REFUSED_STREAM,
+-                                /*bytes_written=*/0u);
+-  EXPECT_CALL(stream_callbacks,
+-              onResetStream(Http::StreamResetReason::RemoteRefusedStreamReset, _));
+-  stream2->OnStreamReset(rst2);
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, ConnectionClose) {
+-  installReadFilter();
+-
+-  std::string error_details("dummy details");
+-  quic::QuicErrorCode error(quic::QUIC_INVALID_FRAME_DATA);
+-  quic::QuicConnectionCloseFrame frame(error, error_details);
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::RemoteClose));
+-  quic_connection_->OnConnectionCloseFrame(frame);
+-  EXPECT_EQ(absl::StrCat(quic::QuicErrorCodeToString(error), " with details: ", error_details),
+-            envoy_quic_session_.transportFailureReason());
+-  EXPECT_EQ(Network::Connection::State::Closed, envoy_quic_session_.state());
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, ConnectionCloseWithActiveStream) {
+-  installReadFilter();
+-
+-  Http::MockStreamDecoder request_decoder;
+-  Http::MockStreamCallbacks stream_callbacks;
+-  EXPECT_CALL(http_connection_callbacks_, newStream(_, false))
+-      .WillOnce(Invoke([&request_decoder, &stream_callbacks](Http::StreamEncoder& encoder,
+-                                                             bool) -> Http::StreamDecoder& {
+-        encoder.getStream().addCallbacks(stream_callbacks);
+-        return request_decoder;
+-      }));
+-  quic::QuicStreamId stream_id =
+-      quic_version_[0].transport_version == quic::QUIC_VERSION_99 ? 4u : 5u;
+-  quic::QuicStream* stream = envoy_quic_session_.GetOrCreateStream(stream_id);
+-  EXPECT_CALL(*quic_connection_,
+-              SendConnectionClosePacket(quic::QUIC_NO_ERROR, "Closed by application"));
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-  EXPECT_CALL(stream_callbacks, onResetStream(Http::StreamResetReason::ConnectionTermination, _));
+-  envoy_quic_session_.close(Network::ConnectionCloseType::NoFlush);
+-  EXPECT_EQ(Network::Connection::State::Closed, envoy_quic_session_.state());
+-  EXPECT_TRUE(stream->write_side_closed() && stream->reading_stopped());
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, FlushCloseNotSupported) {
+-  installReadFilter();
+-
+-  EXPECT_CALL(*quic_connection_,
+-              SendConnectionClosePacket(quic::QUIC_NO_ERROR, "Closed by application"));
+-  EXPECT_CALL(network_connection_callbacks_, onEvent(Network::ConnectionEvent::LocalClose));
+-  envoy_quic_session_.close(Network::ConnectionCloseType::FlushWrite);
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, ShutdownNotice) {
+-  installReadFilter();
+-  // Not verifying dummy implementation, just to have coverage.
+-  EXPECT_DEATH(envoy_quic_session_.enableHalfClose(true), "");
+-  EXPECT_EQ(nullptr, envoy_quic_session_.ssl());
+-  EXPECT_DEATH(envoy_quic_session_.aboveHighWatermark(), "");
+-  EXPECT_DEATH(envoy_quic_session_.setDelayedCloseTimeout(std::chrono::milliseconds(1)), "");
+-  http_connection_->shutdownNotice();
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, GoAway) {
+-  installReadFilter();
+-  if (quic_version_[0].transport_version < quic::QUIC_VERSION_99) {
+-    EXPECT_CALL(*quic_connection_, SendControlFrame(_));
+-  }
+-  http_connection_->goAway();
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, InitializeFilterChain) {
+-  // Generate a CHLO packet.
+-  quic::CryptoHandshakeMessage chlo = quic::test::crypto_test_utils::GenerateDefaultInchoateCHLO(
+-      connection_helper_.GetClock(), quic::CurrentSupportedVersions()[0].transport_version,
+-      &crypto_config_);
+-  chlo.SetVector(quic::kCOPT, quic::QuicTagVector{quic::kREJ});
+-  std::string packet_content(chlo.GetSerialized().AsStringPiece());
+-  auto encrypted_packet =
+-      std::unique_ptr<quic::QuicEncryptedPacket>(quic::test::ConstructEncryptedPacket(
+-          quic_connection_->connection_id(), quic::EmptyQuicConnectionId(), /*version_flag=*/true,
+-          /*reset_flag*/ false, /*packet_number=*/1, packet_content));
+-
+-  quic::QuicSocketAddress self_address(
+-      envoyAddressInstanceToQuicSocketAddress(listener_config_.socket().localAddress()));
+-  auto packet = std::unique_ptr<quic::QuicReceivedPacket>(
+-      quic::test::ConstructReceivedPacket(*encrypted_packet, connection_helper_.GetClock()->Now()));
+-
+-  // Receiving above packet should trigger filter chain retrieval.
+-  Network::MockFilterChainManager filter_chain_manager;
+-  EXPECT_CALL(listener_config_, filterChainManager()).WillOnce(ReturnRef(filter_chain_manager));
+-  Network::MockFilterChain filter_chain;
+-  EXPECT_CALL(filter_chain_manager, findFilterChain(_))
+-      .WillOnce(Invoke([&](const Network::ConnectionSocket& socket) {
+-        EXPECT_EQ(*quicAddressToEnvoyAddressInstance(quic_connection_->peer_address()),
+-                  *socket.remoteAddress());
+-        EXPECT_EQ(*quicAddressToEnvoyAddressInstance(self_address), *socket.localAddress());
+-        EXPECT_EQ(listener_config_.socket().ioHandle().fd(), socket.ioHandle().fd());
+-        EXPECT_EQ(Extensions::TransportSockets::TransportProtocolNames::get().Quic,
+-                  socket.detectedTransportProtocol());
+-        return &filter_chain;
+-      }));
+-  std::vector<Network::FilterFactoryCb> filter_factory{[this](
+-                                                           Network::FilterManager& filter_manager) {
+-    filter_manager.addReadFilter(read_filter_);
+-    read_filter_->callbacks_->connection().addConnectionCallbacks(network_connection_callbacks_);
+-  }};
+-  EXPECT_CALL(filter_chain, networkFilterFactories()).WillOnce(ReturnRef(filter_factory));
+-  EXPECT_CALL(*read_filter_, onNewConnection())
+-      // Stop iteration to avoid calling getRead/WriteBuffer().
+-      .WillOnce(Return(Network::FilterStatus::StopIteration));
+-  EXPECT_CALL(listener_config_.filter_chain_factory_, createNetworkFilterChain(_, _))
+-      .WillOnce(Invoke([](Network::Connection& connection,
+-                          const std::vector<Network::FilterFactoryCb>& filter_factories) {
+-        EXPECT_EQ(1u, filter_factories.size());
+-        Server::Configuration::FilterChainUtility::buildFilterChain(connection, filter_factories);
+-        return true;
+-      }));
+-  // A reject should be sent because of the inchoate CHLO.
+-  EXPECT_CALL(writer_, WritePacket(_, _, _, _, _))
+-      .WillOnce(testing::Return(quic::WriteResult(quic::WRITE_STATUS_OK, 1)));
+-  quic_connection_->ProcessUdpPacket(self_address, quic_connection_->peer_address(), *packet);
+-  EXPECT_TRUE(quic_connection_->connected());
+-  EXPECT_EQ(nullptr, envoy_quic_session_.socketOptions());
+-  EXPECT_FALSE(envoy_quic_session_.IsEncryptionEstablished());
+-  EXPECT_TRUE(quic_connection_->connectionSocket()->ioHandle().isOpen());
+-  EXPECT_TRUE(quic_connection_->connectionSocket()->ioHandle().close().ok());
+-  EXPECT_FALSE(quic_connection_->connectionSocket()->ioHandle().isOpen());
+-}
+-
+-TEST_P(EnvoyQuicServerSessionTest, NetworkConnectionInterface) {
+-  installReadFilter();
+-  EXPECT_EQ(dispatcher_.get(), &envoy_quic_session_.dispatcher());
+-  EXPECT_TRUE(envoy_quic_session_.readEnabled());
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_server_stream_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_server_stream_test.cc
+deleted file mode 100644
+index b77714985c..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_server_stream_test.cc
++++ /dev/null
+@@ -1,252 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_stream.h"
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/core/quic_versions.h"
+-#include "quiche/quic/core/http/quic_server_session_base.h"
+-#include "quiche/quic/test_tools/quic_test_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include <string>
+-
+-#include "common/event/libevent_scheduler.h"
+-#include "common/http/headers.h"
+-#include "test/test_common/utility.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_alarm_factory.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_server_connection.h"
+-#include "extensions/quic_listeners/quiche/envoy_quic_connection_helper.h"
+-#include "test/mocks/http/stream_decoder.h"
+-#include "test/mocks/network/mocks.h"
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::_;
+-using testing::Invoke;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class MockQuicServerSession : public quic::QuicServerSessionBase {
+-public:
+-  MockQuicServerSession(const quic::QuicConfig& config,
+-                        const quic::ParsedQuicVersionVector& supported_versions,
+-                        quic::QuicConnection* connection, quic::QuicSession::Visitor* visitor,
+-                        quic::QuicCryptoServerStream::Helper* helper,
+-                        const quic::QuicCryptoServerConfig* crypto_config,
+-                        quic::QuicCompressedCertsCache* compressed_certs_cache)
+-      : quic::QuicServerSessionBase(config, supported_versions, connection, visitor, helper,
+-                                    crypto_config, compressed_certs_cache) {}
+-
+-  MOCK_METHOD1(CreateIncomingStream, quic::QuicSpdyStream*(quic::QuicStreamId id));
+-  MOCK_METHOD1(CreateIncomingStream, quic::QuicSpdyStream*(quic::PendingStream* pending));
+-  MOCK_METHOD0(CreateOutgoingBidirectionalStream, quic::QuicSpdyStream*());
+-  MOCK_METHOD0(CreateOutgoingUnidirectionalStream, quic::QuicSpdyStream*());
+-  MOCK_METHOD1(ShouldCreateIncomingStream, bool(quic::QuicStreamId id));
+-  MOCK_METHOD0(ShouldCreateOutgoingBidirectionalStream, bool());
+-  MOCK_METHOD0(ShouldCreateOutgoingUnidirectionalStream, bool());
+-  MOCK_METHOD2(CreateQuicCryptoServerStream,
+-               quic::QuicCryptoServerStream*(const quic::QuicCryptoServerConfig*,
+-                                             quic::QuicCompressedCertsCache*));
+-};
+-
+-class EnvoyQuicServerStreamTest : public testing::TestWithParam<bool> {
+-public:
+-  EnvoyQuicServerStreamTest()
+-      : api_(Api::createApiForTest()), dispatcher_(api_->allocateDispatcher()),
+-        connection_helper_(*dispatcher_),
+-        alarm_factory_(*dispatcher_, *connection_helper_.GetClock()), quic_version_([]() {
+-          SetQuicReloadableFlag(quic_enable_version_99, GetParam());
+-          return quic::CurrentSupportedVersions()[0];
+-        }()),
+-        listener_stats_({ALL_LISTENER_STATS(POOL_COUNTER(listener_config_.listenerScope()),
+-                                            POOL_GAUGE(listener_config_.listenerScope()),
+-                                            POOL_HISTOGRAM(listener_config_.listenerScope()))}),
+-        quic_connection_(quic::test::TestConnectionId(),
+-                         quic::QuicSocketAddress(quic::QuicIpAddress::Any6(), 12345),
+-                         connection_helper_, alarm_factory_, &writer_,
+-                         /*owns_writer=*/false, {quic_version_}, listener_config_, listener_stats_),
+-        quic_session_(quic_config_, {quic_version_}, &quic_connection_, /*visitor=*/nullptr,
+-                      /*helper=*/nullptr, /*crypto_config=*/nullptr,
+-                      /*compressed_certs_cache=*/nullptr),
+-        stream_id_(quic_version_.transport_version == quic::QUIC_VERSION_99 ? 4u : 5u),
+-        quic_stream_(stream_id_, &quic_session_, quic::BIDIRECTIONAL) {
+-    quic::SetVerbosityLogThreshold(3);
+-
+-    quic_stream_.setDecoder(stream_decoder_);
+-  }
+-
+-  void SetUp() override {
+-    headers_.OnHeaderBlockStart();
+-    headers_.OnHeader(":authority", host_);
+-    headers_.OnHeader(":method", "GET");
+-    headers_.OnHeader(":path", "/");
+-    headers_.OnHeaderBlockEnd(/*uncompressed_header_bytes=*/0, /*compressed_header_bytes=*/0);
+-
+-    trailers_.OnHeaderBlockStart();
+-    trailers_.OnHeader("key1", "value1");
+-    if (quic_version_.transport_version != quic::QUIC_VERSION_99) {
+-      // ":final-offset" is required and stripped off by quic.
+-      trailers_.OnHeader(":final-offset", absl::StrCat("", request_body_.length()));
+-    }
+-    trailers_.OnHeaderBlockEnd(/*uncompressed_header_bytes=*/0, /*compressed_header_bytes=*/0);
+-  }
+-
+-protected:
+-  Api::ApiPtr api_;
+-  Event::DispatcherPtr dispatcher_;
+-  EnvoyQuicConnectionHelper connection_helper_;
+-  EnvoyQuicAlarmFactory alarm_factory_;
+-  testing::NiceMock<quic::test::MockPacketWriter> writer_;
+-  quic::ParsedQuicVersion quic_version_;
+-  quic::QuicConfig quic_config_;
+-  testing::NiceMock<Network::MockListenerConfig> listener_config_;
+-  Server::ListenerStats listener_stats_;
+-  EnvoyQuicServerConnection quic_connection_;
+-  MockQuicServerSession quic_session_;
+-  quic::QuicStreamId stream_id_;
+-  EnvoyQuicServerStream quic_stream_;
+-  Http::MockStreamDecoder stream_decoder_;
+-  quic::QuicHeaderList headers_;
+-  quic::QuicHeaderList trailers_;
+-  std::string host_{"www.abc.com"};
+-  std::string request_body_{"Hello world"};
+-};
+-
+-INSTANTIATE_TEST_SUITE_P(EnvoyQuicServerStreamTests, EnvoyQuicServerStreamTest,
+-                         testing::ValuesIn({true, false}));
+-
+-TEST_P(EnvoyQuicServerStreamTest, DecodeHeadersAndBody) {
+-  EXPECT_CALL(stream_decoder_, decodeHeaders_(_, /*end_stream=*/false))
+-      .WillOnce(Invoke([this](const Http::HeaderMapPtr& headers, bool) {
+-        EXPECT_EQ(host_, headers->Host()->value().getStringView());
+-        EXPECT_EQ("/", headers->Path()->value().getStringView());
+-        EXPECT_EQ(Http::Headers::get().MethodValues.Get,
+-                  headers->Method()->value().getStringView());
+-      }));
+-  if (quic_version_.transport_version == quic::QUIC_VERSION_99) {
+-    quic_stream_.OnHeadersDecoded(headers_);
+-  } else {
+-    quic_stream_.OnStreamHeaderList(/*fin=*/false, headers_.uncompressed_header_bytes(), headers_);
+-  }
+-  EXPECT_TRUE(quic_stream_.FinishedReadingHeaders());
+-
+-  EXPECT_CALL(stream_decoder_, decodeData(_, _))
+-      .WillOnce(Invoke([this](Buffer::Instance& buffer, bool finished_reading) {
+-        EXPECT_EQ(request_body_, buffer.toString());
+-        EXPECT_TRUE(finished_reading);
+-      }));
+-  std::string data = request_body_;
+-  if (quic_version_.transport_version == quic::QUIC_VERSION_99) {
+-    std::unique_ptr<char[]> data_buffer;
+-    quic::HttpEncoder encoder;
+-    quic::QuicByteCount data_frame_header_length =
+-        encoder.SerializeDataFrameHeader(request_body_.length(), &data_buffer);
+-    quic::QuicStringPiece data_frame_header(data_buffer.get(), data_frame_header_length);
+-    data = absl::StrCat(data_frame_header, request_body_);
+-  }
+-  quic::QuicStreamFrame frame(stream_id_, true, 0, data);
+-  quic_stream_.OnStreamFrame(frame);
+-}
+-
+-TEST_P(EnvoyQuicServerStreamTest, DecodeHeadersBodyAndTrailers) {
+-  EXPECT_CALL(stream_decoder_, decodeHeaders_(_, /*end_stream=*/false))
+-      .WillOnce(Invoke([this](const Http::HeaderMapPtr& headers, bool) {
+-        EXPECT_EQ(host_, headers->Host()->value().getStringView());
+-        EXPECT_EQ("/", headers->Path()->value().getStringView());
+-        EXPECT_EQ(Http::Headers::get().MethodValues.Get,
+-                  headers->Method()->value().getStringView());
+-      }));
+-  quic_stream_.OnStreamHeaderList(/*fin=*/false, headers_.uncompressed_header_bytes(), headers_);
+-  EXPECT_TRUE(quic_stream_.FinishedReadingHeaders());
+-
+-  std::string data = request_body_;
+-  if (quic_version_.transport_version == quic::QUIC_VERSION_99) {
+-    std::unique_ptr<char[]> data_buffer;
+-    quic::HttpEncoder encoder;
+-    quic::QuicByteCount data_frame_header_length =
+-        encoder.SerializeDataFrameHeader(request_body_.length(), &data_buffer);
+-    quic::QuicStringPiece data_frame_header(data_buffer.get(), data_frame_header_length);
+-    data = absl::StrCat(data_frame_header, request_body_);
+-  }
+-  quic::QuicStreamFrame frame(stream_id_, false, 0, data);
+-  EXPECT_CALL(stream_decoder_, decodeData(_, _))
+-      .Times(testing::AtMost(2))
+-      .WillOnce(Invoke([this](Buffer::Instance& buffer, bool finished_reading) {
+-        EXPECT_EQ(request_body_, buffer.toString());
+-        EXPECT_FALSE(finished_reading);
+-      }))
+-      // Depends on QUIC version, there may be an empty STREAM_FRAME with FIN. But
+-      // since there is trailers, finished_reading should always be false.
+-      .WillOnce(Invoke([](Buffer::Instance& buffer, bool finished_reading) {
+-        EXPECT_FALSE(finished_reading);
+-        EXPECT_EQ(0, buffer.length());
+-      }));
+-  quic_stream_.OnStreamFrame(frame);
+-
+-  EXPECT_CALL(stream_decoder_, decodeTrailers_(_))
+-      .WillOnce(Invoke([](const Http::HeaderMapPtr& headers) {
+-        Http::LowerCaseString key1("key1");
+-        Http::LowerCaseString key2(":final-offset");
+-        EXPECT_EQ("value1", headers->get(key1)->value().getStringView());
+-        EXPECT_EQ(nullptr, headers->get(key2));
+-      }));
+-  quic_stream_.OnStreamHeaderList(/*fin=*/true, trailers_.uncompressed_header_bytes(), trailers_);
+-}
+-
+-TEST_P(EnvoyQuicServerStreamTest, OutOfOrderTrailers) {
+-  if (quic::VersionUsesQpack(quic_version_.transport_version)) {
+-    return;
+-  }
+-  EXPECT_CALL(stream_decoder_, decodeHeaders_(_, /*end_stream=*/false))
+-      .WillOnce(Invoke([this](const Http::HeaderMapPtr& headers, bool) {
+-        EXPECT_EQ(host_, headers->Host()->value().getStringView());
+-        EXPECT_EQ("/", headers->Path()->value().getStringView());
+-        EXPECT_EQ(Http::Headers::get().MethodValues.Get,
+-                  headers->Method()->value().getStringView());
+-      }));
+-  quic_stream_.OnStreamHeaderList(/*fin=*/false, headers_.uncompressed_header_bytes(), headers_);
+-  EXPECT_TRUE(quic_stream_.FinishedReadingHeaders());
+-
+-  // Trailer should be delivered to HCM later after body arrives.
+-  quic_stream_.OnStreamHeaderList(/*fin=*/true, trailers_.uncompressed_header_bytes(), trailers_);
+-
+-  std::string data = request_body_;
+-  if (quic_version_.transport_version == quic::QUIC_VERSION_99) {
+-    std::unique_ptr<char[]> data_buffer;
+-    quic::HttpEncoder encoder;
+-    quic::QuicByteCount data_frame_header_length =
+-        encoder.SerializeDataFrameHeader(request_body_.length(), &data_buffer);
+-    quic::QuicStringPiece data_frame_header(data_buffer.get(), data_frame_header_length);
+-    data = absl::StrCat(data_frame_header, request_body_);
+-  }
+-  quic::QuicStreamFrame frame(stream_id_, false, 0, data);
+-  EXPECT_CALL(stream_decoder_, decodeData(_, _))
+-      .Times(testing::AtMost(2))
+-      .WillOnce(Invoke([this](Buffer::Instance& buffer, bool finished_reading) {
+-        EXPECT_EQ(request_body_, buffer.toString());
+-        EXPECT_FALSE(finished_reading);
+-      }))
+-      // Depends on QUIC version, there may be an empty STREAM_FRAME with FIN. But
+-      // since there is trailers, finished_reading should always be false.
+-      .WillOnce(Invoke([](Buffer::Instance& buffer, bool finished_reading) {
+-        EXPECT_FALSE(finished_reading);
+-        EXPECT_EQ(0, buffer.length());
+-      }));
+-
+-  EXPECT_CALL(stream_decoder_, decodeTrailers_(_))
+-      .WillOnce(Invoke([](const Http::HeaderMapPtr& headers) {
+-        Http::LowerCaseString key1("key1");
+-        Http::LowerCaseString key2(":final-offset");
+-        EXPECT_EQ("value1", headers->get(key1)->value().getStringView());
+-        EXPECT_EQ(nullptr, headers->get(key2));
+-      }));
+-  quic_stream_.OnStreamFrame(frame);
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_utils_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_utils_test.cc
+deleted file mode 100644
+index 7fff3cc792..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_utils_test.cc
++++ /dev/null
+@@ -1,65 +0,0 @@
+-#include "extensions/quic_listeners/quiche/envoy_quic_utils.h"
+-
+-#pragma GCC diagnostic push
+-// QUICHE allows unused parameters.
+-#pragma GCC diagnostic ignored "-Wunused-parameter"
+-// QUICHE uses offsetof().
+-#pragma GCC diagnostic ignored "-Winvalid-offsetof"
+-
+-#include "quiche/quic/test_tools/quic_test_utils.h"
+-
+-#pragma GCC diagnostic pop
+-
+-#include "test/mocks/api/mocks.h"
+-#include "test/test_common/threadsafe_singleton_injector.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::_;
+-using testing::Return;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-TEST(EnvoyQuicUtilsTest, ConversionBetweenQuicAddressAndEnvoyAddress) {
+-  // Mock out socket() system call to test both V4 and V6 address conversion.
+-  testing::NiceMock<Envoy::Api::MockOsSysCalls> os_sys_calls;
+-  TestThreadsafeSingletonInjector<Envoy::Api::OsSysCallsImpl> os_calls{&os_sys_calls};
+-  ON_CALL(os_sys_calls, socket(_, _, _)).WillByDefault(Return(Api::SysCallIntResult{1, 0}));
+-  ON_CALL(os_sys_calls, close(_)).WillByDefault(Return(Api::SysCallIntResult{0, 0}));
+-
+-  quic::QuicSocketAddress quic_uninitialized_addr;
+-  EXPECT_EQ(nullptr, quicAddressToEnvoyAddressInstance(quic_uninitialized_addr));
+-
+-  for (const std::string& ip_str : {"fd00:0:0:1::1", "1.2.3.4"}) {
+-    quic::QuicIpAddress quic_ip;
+-    quic_ip.FromString(ip_str);
+-    quic::QuicSocketAddress quic_addr(quic_ip, 12345);
+-    Network::Address::InstanceConstSharedPtr envoy_addr =
+-        quicAddressToEnvoyAddressInstance(quic_addr);
+-    EXPECT_EQ(quic_addr.ToString(), envoy_addr->asStringView());
+-    EXPECT_EQ(quic_addr, envoyAddressInstanceToQuicSocketAddress(envoy_addr));
+-  }
+-}
+-
+-TEST(EnvoyQuicUtilsTest, HeadersConversion) {
+-  spdy::SpdyHeaderBlock headers_block;
+-  headers_block[":host"] = "www.google.com";
+-  headers_block[":path"] = "/index.hml";
+-  headers_block[":scheme"] = "https";
+-  Http::HeaderMapImplPtr envoy_headers = spdyHeaderBlockToEnvoyHeaders(headers_block);
+-  EXPECT_EQ(headers_block.size(), envoy_headers->size());
+-  EXPECT_EQ("www.google.com",
+-            envoy_headers->get(Http::LowerCaseString(":host"))->value().getStringView());
+-  EXPECT_EQ("/index.hml",
+-            envoy_headers->get(Http::LowerCaseString(":path"))->value().getStringView());
+-  EXPECT_EQ("https", envoy_headers->get(Http::LowerCaseString(":scheme"))->value().getStringView());
+-
+-  quic::QuicHeaderList quic_headers = quic::test::AsHeaderList(headers_block);
+-  Http::HeaderMapImplPtr envoy_headers2 = quicHeadersToEnvoyHeaders(quic_headers);
+-  EXPECT_EQ(*envoy_headers, *envoy_headers2);
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/envoy_quic_writer_test.cc b/test/extensions/quic_listeners/quiche/envoy_quic_writer_test.cc
+deleted file mode 100644
+index d418531ba3..0000000000
+--- a/test/extensions/quic_listeners/quiche/envoy_quic_writer_test.cc
++++ /dev/null
+@@ -1,138 +0,0 @@
+-#include <sys/types.h>
+-
+-#include <memory>
+-#include <string>
+-
+-#include "common/network/address_impl.h"
+-#include "common/network/io_socket_error_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/envoy_quic_packet_writer.h"
+-
+-#include "test/mocks/api/mocks.h"
+-#include "test/mocks/network/mocks.h"
+-#include "test/test_common/threadsafe_singleton_injector.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::Return;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class EnvoyQuicWriterTest : public ::testing::Test {
+-public:
+-  EnvoyQuicWriterTest() : envoy_quic_writer_(socket_) {
+-    self_address_.FromString("::");
+-    quic::QuicIpAddress peer_ip;
+-    peer_ip.FromString("::1");
+-    peer_address_ = quic::QuicSocketAddress(peer_ip, /*port=*/123);
+-    ON_CALL(os_sys_calls_, socket(_, _, _)).WillByDefault(Return(Api::SysCallIntResult{3, 0}));
+-    ON_CALL(os_sys_calls_, close(3)).WillByDefault(Return(Api::SysCallIntResult{0, 0}));
+-  }
+-
+-  void verifySendData(const std::string& content, const msghdr* message) {
+-    EXPECT_EQ(peer_address_.ToString(), Network::Address::addressFromSockAddr(
+-                                            *reinterpret_cast<sockaddr_storage*>(message->msg_name),
+-                                            message->msg_namelen, /*v6only=*/false)
+-                                            ->asString());
+-    cmsghdr* const cmsg = CMSG_FIRSTHDR(message);
+-    auto pktinfo = reinterpret_cast<in6_pktinfo*>(CMSG_DATA(cmsg));
+-    EXPECT_EQ(0, memcmp(self_address_.GetIPv6().s6_addr, pktinfo->ipi6_addr.s6_addr,
+-                        sizeof(pktinfo->ipi6_addr.s6_addr)));
+-    EXPECT_EQ(1, message->msg_iovlen);
+-    iovec iov = message->msg_iov[0];
+-    EXPECT_EQ(content, std::string(reinterpret_cast<char*>(iov.iov_base), iov.iov_len));
+-  }
+-
+-protected:
+-  testing::NiceMock<Api::MockOsSysCalls> os_sys_calls_;
+-  TestThreadsafeSingletonInjector<Api::OsSysCallsImpl> os_calls_{&os_sys_calls_};
+-  testing::NiceMock<Network::MockListenSocket> socket_;
+-  quic::QuicIpAddress self_address_;
+-  quic::QuicSocketAddress peer_address_;
+-  EnvoyQuicPacketWriter envoy_quic_writer_;
+-};
+-
+-TEST_F(EnvoyQuicWriterTest, AssertOnNonNullPacketOption) {
+-  std::string str("Hello World!");
+-  EXPECT_DEBUG_DEATH(envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                    peer_address_,
+-                                                    reinterpret_cast<quic::PerPacketOptions*>(0x1)),
+-                     "");
+-}
+-
+-TEST_F(EnvoyQuicWriterTest, SendSuccessfully) {
+-  std::string str("Hello World!");
+-
+-  EXPECT_CALL(os_sys_calls_, sendmsg(_, _, _))
+-      .WillOnce(testing::Invoke([this, str](int, const msghdr* message, int) {
+-        verifySendData(str, message);
+-        return Api::SysCallSizeResult{static_cast<ssize_t>(str.length()), 0};
+-      }));
+-  quic::WriteResult result = envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                            peer_address_, nullptr);
+-  EXPECT_EQ(quic::WRITE_STATUS_OK, result.status);
+-  EXPECT_EQ(str.length(), result.bytes_written);
+-  EXPECT_FALSE(envoy_quic_writer_.IsWriteBlocked());
+-}
+-
+-TEST_F(EnvoyQuicWriterTest, SendBlocked) {
+-  std::string str("Hello World!");
+-  EXPECT_CALL(os_sys_calls_, sendmsg(_, _, _))
+-      .WillOnce(testing::Invoke([this, str](int, const msghdr* message, int) {
+-        verifySendData(str, message);
+-        return Api::SysCallSizeResult{-1, EAGAIN};
+-      }));
+-  quic::WriteResult result = envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                            peer_address_, nullptr);
+-  EXPECT_EQ(quic::WRITE_STATUS_BLOCKED, result.status);
+-  EXPECT_EQ(static_cast<int>(Api::IoError::IoErrorCode::Again), result.error_code);
+-  EXPECT_TRUE(envoy_quic_writer_.IsWriteBlocked());
+-  // Writing while blocked is not allowed.
+-#ifdef NDEBUG
+-  EXPECT_CALL(os_sys_calls_, sendmsg(_, _, _))
+-      .WillOnce(testing::Invoke([this, str](int, const msghdr* message, int) {
+-        verifySendData(str, message);
+-        return Api::SysCallSizeResult{-1, EAGAIN};
+-      }));
+-#endif
+-  EXPECT_DEBUG_DEATH(envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                    peer_address_, nullptr),
+-                     "");
+-  envoy_quic_writer_.SetWritable();
+-  EXPECT_FALSE(envoy_quic_writer_.IsWriteBlocked());
+-}
+-
+-TEST_F(EnvoyQuicWriterTest, SendFailure) {
+-  std::string str("Hello World!");
+-  EXPECT_CALL(os_sys_calls_, sendmsg(_, _, _))
+-      .WillOnce(testing::Invoke([this, str](int, const msghdr* message, int) {
+-        verifySendData(str, message);
+-        return Api::SysCallSizeResult{-1, ENOTSUP};
+-      }));
+-  quic::WriteResult result = envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                            peer_address_, nullptr);
+-  EXPECT_EQ(quic::WRITE_STATUS_ERROR, result.status);
+-  EXPECT_EQ(static_cast<int>(Api::IoError::IoErrorCode::NoSupport), result.error_code);
+-  EXPECT_FALSE(envoy_quic_writer_.IsWriteBlocked());
+-}
+-
+-TEST_F(EnvoyQuicWriterTest, SendFailureMessageTooBig) {
+-  std::string str("Hello World!");
+-  EXPECT_CALL(os_sys_calls_, sendmsg(_, _, _))
+-      .WillOnce(testing::Invoke([this, str](int, const msghdr* message, int) {
+-        verifySendData(str, message);
+-        return Api::SysCallSizeResult{-1, EMSGSIZE};
+-      }));
+-  quic::WriteResult result = envoy_quic_writer_.WritePacket(str.data(), str.length(), self_address_,
+-                                                            peer_address_, nullptr);
+-  // Currently MessageSize should be propagated through error_code. This test
+-  // would fail if QUICHE changes to propagate through status in the future.
+-  EXPECT_EQ(quic::WRITE_STATUS_ERROR, result.status);
+-  EXPECT_EQ(static_cast<int>(Api::IoError::IoErrorCode::MessageTooBig), result.error_code);
+-  EXPECT_FALSE(envoy_quic_writer_.IsWriteBlocked());
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/platform/BUILD b/test/extensions/quic_listeners/quiche/platform/BUILD
+deleted file mode 100644
+index 09ef037677..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/BUILD
++++ /dev/null
+@@ -1,239 +0,0 @@
+-licenses(["notice"])  # Apache 2
+-
+-load(
+-    "//bazel:envoy_build_system.bzl",
+-    "envoy_cc_fuzz_test",
+-    "envoy_cc_test",
+-    "envoy_cc_test_binary",
+-    "envoy_cc_test_library",
+-    "envoy_package",
+-    "envoy_proto_library",
+-)
+-
+-envoy_package()
+-
+-envoy_cc_test(
+-    name = "http2_platform_test",
+-    srcs = ["http2_platform_test.cc"],
+-    external_deps = ["quiche_http2_platform"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche/platform:flags_impl_lib",
+-        "//test/test_common:logging_lib",
+-        "//test/test_common:utility_lib",
+-        "@com_googlesource_quiche//:http2_platform_reconstruct_object",
+-        "@com_googlesource_quiche//:http2_test_tools_random",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "quic_platform_test",
+-    srcs = select({
+-        "//bazel:linux": ["quic_platform_test.cc"],
+-        "//conditions:default": [],
+-    }),
+-    copts = ["-Wno-unused-parameter"],
+-    data = ["//test/extensions/transport_sockets/tls/test_data:certs"],
+-    external_deps = ["quiche_quic_platform"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":quic_platform_epoll_clock_lib",
+-        "//source/common/memory:stats_lib",
+-        "//source/extensions/quic_listeners/quiche/platform:flags_impl_lib",
+-        "//test/common/buffer:utility_lib",
+-        "//test/common/stats:stat_test_utility_lib",
+-        "//test/extensions/transport_sockets/tls:ssl_test_utils",
+-        "//test/mocks/api:api_mocks",
+-        "//test/test_common:logging_lib",
+-        "//test/test_common:threadsafe_singleton_injector_lib",
+-        "//test/test_common:utility_lib",
+-        "@com_googlesource_quiche//:epoll_server_lib",
+-        "@com_googlesource_quiche//:quic_core_buffer_allocator_lib",
+-        "@com_googlesource_quiche//:quic_core_error_codes_lib",
+-        "@com_googlesource_quiche//:quic_core_types_lib",
+-        "@com_googlesource_quiche//:quic_platform_expect_bug",
+-        "@com_googlesource_quiche//:quic_platform_mem_slice_span",
+-        "@com_googlesource_quiche//:quic_platform_mem_slice_storage",
+-        "@com_googlesource_quiche//:quic_platform_mock_log",
+-        "@com_googlesource_quiche//:quic_platform_port_utils",
+-        "@com_googlesource_quiche//:quic_platform_sleep",
+-        "@com_googlesource_quiche//:quic_platform_system_event_loop",
+-        "@com_googlesource_quiche//:quic_platform_test",
+-        "@com_googlesource_quiche//:quic_platform_test_output",
+-        "@com_googlesource_quiche//:quic_platform_thread",
+-    ],
+-)
+-
+-envoy_cc_test(
+-    name = "spdy_platform_test",
+-    srcs = ["spdy_platform_test.cc"],
+-    external_deps = ["quiche_spdy_platform"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche/platform:flags_impl_lib",
+-        "//test/test_common:logging_lib",
+-        "//test/test_common:utility_lib",
+-        "@com_googlesource_quiche//:spdy_platform",
+-        "@com_googlesource_quiche//:spdy_platform_test_helpers",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "epoll_server_platform_impl_lib",
+-    hdrs = [
+-        "epoll_address_test_utils_impl.h",
+-        "epoll_bug_impl.h",
+-        "epoll_expect_bug_impl.h",
+-        "epoll_export_impl.h",
+-        "epoll_logging_impl.h",
+-        "epoll_ptr_util_impl.h",
+-        "epoll_test_impl.h",
+-        "epoll_thread_impl.h",
+-        "epoll_time_impl.h",
+-    ],
+-    external_deps = ["abseil_time"],
+-    deps = [
+-        ":quic_platform_expect_bug_impl_lib",
+-        ":quic_platform_thread_impl_lib",
+-        "//include/envoy/network:address_interface",
+-        "//source/extensions/quic_listeners/quiche/platform:quic_platform_base_impl_lib",
+-        "//test/test_common:environment_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "http2_platform_reconstruct_object_impl_lib",
+-    hdrs = ["http2_reconstruct_object_impl.h"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_epoll_clock_lib",
+-    srcs = select({
+-        "//bazel:linux": ["quic_epoll_clock.cc"],
+-        "//conditions:default": [],
+-    }),
+-    hdrs = select({
+-        "//bazel:linux": ["quic_epoll_clock.h"],
+-        "//conditions:default": [],
+-    }),
+-    tags = ["nofips"],
+-    deps = [
+-        "@com_googlesource_quiche//:quic_platform",
+-        "@com_googlesource_quiche//:quic_platform_epoll_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_epoll_impl_lib",
+-    hdrs = ["quic_epoll_impl.h"],
+-    tags = ["nofips"],
+-    deps = ["@com_googlesource_quiche//:epoll_server_lib"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_expect_bug_impl_lib",
+-    hdrs = ["quic_expect_bug_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "@com_googlesource_quiche//:quic_platform_base",
+-        "@com_googlesource_quiche//:quic_platform_mock_log",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_mock_log_impl_lib",
+-    hdrs = ["quic_mock_log_impl.h"],
+-    tags = ["nofips"],
+-    deps = ["@com_googlesource_quiche//:quic_platform_base"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_port_utils_impl_lib",
+-    srcs = ["quic_port_utils_impl.cc"],
+-    hdrs = ["quic_port_utils_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/common/network:utility_lib",
+-        "//test/test_common:environment_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_test_mem_slice_vector_impl_lib",
+-    hdrs = ["quic_test_mem_slice_vector_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/buffer:buffer_interface",
+-        "@com_googlesource_quiche//:quic_platform_mem_slice_span",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_sleep_impl_lib",
+-    hdrs = ["quic_sleep_impl.h"],
+-    tags = ["nofips"],
+-    deps = ["@com_googlesource_quiche//:quic_core_time_lib"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_system_event_loop_impl_lib",
+-    hdrs = ["quic_system_event_loop_impl.h"],
+-    tags = ["nofips"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_thread_impl_lib",
+-    hdrs = ["quic_thread_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//include/envoy/thread:thread_interface",
+-        "//source/common/common:assert_lib",
+-        "//test/test_common:thread_factory_for_test_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_test_impl_lib",
+-    hdrs = ["quic_test_impl.h"],
+-    tags = ["nofips"],
+-    deps = ["//source/common/common:assert_lib"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quic_platform_test_output_impl_lib",
+-    srcs = ["quic_test_output_impl.cc"],
+-    hdrs = ["quic_test_output_impl.h"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/common/filesystem:filesystem_lib",
+-        "@com_googlesource_quiche//:quic_platform_base",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "quiche_common_platform_test_impl_lib",
+-    hdrs = ["quiche_test_impl.h"],
+-)
+-
+-envoy_cc_test_library(
+-    name = "spdy_platform_test_helpers_impl_lib",
+-    hdrs = ["spdy_test_helpers_impl.h"],
+-    deps = [
+-        ":quic_platform_expect_bug_impl_lib",
+-    ],
+-)
+-
+-envoy_cc_test_library(
+-    name = "spdy_platform_test_impl_lib",
+-    hdrs = ["spdy_test_impl.h"],
+-)
+-
+-envoy_cc_test(
+-    name = "envoy_quic_clock_test",
+-    srcs = ["envoy_quic_clock_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        "//source/extensions/quic_listeners/quiche/platform:envoy_quic_clock_lib",
+-        "//test/test_common:simulated_time_system_lib",
+-        "//test/test_common:test_time_lib",
+-        "//test/test_common:utility_lib",
+-    ],
+-)
+diff --git a/test/extensions/quic_listeners/quiche/platform/envoy_quic_clock_test.cc b/test/extensions/quic_listeners/quiche/platform/envoy_quic_clock_test.cc
+deleted file mode 100644
+index cd1a9b7f58..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/envoy_quic_clock_test.cc
++++ /dev/null
+@@ -1,78 +0,0 @@
+-#include <memory>
+-
+-#include "extensions/quic_listeners/quiche/platform/envoy_quic_clock.h"
+-
+-#include "test/test_common/simulated_time_system.h"
+-#include "test/test_common/test_time.h"
+-#include "test/test_common/utility.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-TEST(EnvoyQuicClockTest, TestNow) {
+-  Event::SimulatedTimeSystemHelper time_system;
+-  Api::ApiPtr api = Api::createApiForTest(time_system);
+-  Event::DispatcherPtr dispatcher = api->allocateDispatcher();
+-  EnvoyQuicClock clock(*dispatcher);
+-  uint64_t mono_time = std::chrono::duration_cast<std::chrono::microseconds>(
+-                           time_system.monotonicTime().time_since_epoch())
+-                           .count();
+-  uint64_t sys_time = std::chrono::duration_cast<std::chrono::microseconds>(
+-                          time_system.systemTime().time_since_epoch())
+-                          .count();
+-  // Advance time by 1000000us.
+-  time_system.sleep(std::chrono::microseconds(1000000));
+-  EXPECT_EQ(mono_time + 1000000, (clock.Now() - quic::QuicTime::Zero()).ToMicroseconds());
+-  EXPECT_EQ(sys_time + 1000000, clock.WallNow().ToUNIXMicroseconds());
+-
+-  // Advance time by 10us.
+-  time_system.sleep(std::chrono::microseconds(10));
+-  EXPECT_EQ(mono_time + 1000000 + 10, (clock.Now() - quic::QuicTime::Zero()).ToMicroseconds());
+-  EXPECT_EQ(sys_time + 1000000 + 10, clock.WallNow().ToUNIXMicroseconds());
+-
+-  // Advance time by 2ms.
+-  time_system.sleep(std::chrono::milliseconds(2));
+-  EXPECT_EQ(mono_time + 1000000 + 10 + 2 * 1000,
+-            (clock.Now() - quic::QuicTime::Zero()).ToMicroseconds());
+-  EXPECT_EQ(sys_time + 1000000 + 10 + 2 * 1000, clock.WallNow().ToUNIXMicroseconds());
+-}
+-
+-// Tests that Now() should never go back.
+-TEST(EnvoyQuicClockTest, TestMonotonicityWithReadTimeSystem) {
+-  Event::TestRealTimeSystem time_system;
+-  Api::ApiPtr api = Api::createApiForTest(time_system);
+-  Event::DispatcherPtr dispatcher = api->allocateDispatcher();
+-  EnvoyQuicClock clock(*dispatcher);
+-  quic::QuicTime last_now = clock.Now();
+-  for (int i = 0; i < 1000; ++i) {
+-    quic::QuicTime now = clock.Now();
+-    ASSERT_LE(last_now, now);
+-    last_now = now;
+-  }
+-}
+-
+-TEST(EnvoyQuicClockTest, ApproximateNow) {
+-  Event::SimulatedTimeSystemHelper time_system;
+-  Api::ApiPtr api = Api::createApiForTest(time_system);
+-  Event::DispatcherPtr dispatcher = api->allocateDispatcher();
+-  EnvoyQuicClock clock(*dispatcher);
+-
+-  // ApproximateTime() is cached, it not change only because time passes.
+-  const int kDeltaMicroseconds = 10;
+-  quic::QuicTime approximate_now1 = clock.ApproximateNow();
+-  time_system.sleep(std::chrono::microseconds(kDeltaMicroseconds));
+-  quic::QuicTime approximate_now2 = clock.ApproximateNow();
+-  EXPECT_EQ(approximate_now1, approximate_now2);
+-
+-  // Calling Now() updates ApproximateTime().
+-  quic::QuicTime now = clock.Now();
+-  approximate_now2 = clock.ApproximateNow();
+-  EXPECT_EQ(now, approximate_now2);
+-  EXPECT_EQ(now, approximate_now1 + quic::QuicTime::Delta::FromMicroseconds(kDeltaMicroseconds));
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_address_test_utils_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_address_test_utils_impl.h
+deleted file mode 100644
+index 9accbd699a..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_address_test_utils_impl.h
++++ /dev/null
+@@ -1,44 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <sys/socket.h>
+-
+-#include <algorithm>
+-
+-#include "envoy/network/address.h"
+-
+-#include "test/test_common/environment.h"
+-
+-namespace epoll_server {
+-
+-namespace {
+-
+-int addressFamilyUnderTestHelper() {
+-  std::vector<Envoy::Network::Address::IpVersion> versions =
+-      Envoy::TestEnvironment::getIpVersionsForTest();
+-  if (std::find(versions.begin(), versions.end(), Envoy::Network::Address::IpVersion::v4) !=
+-      versions.end()) {
+-    return AF_INET;
+-  }
+-  if (std::find(versions.begin(), versions.end(), Envoy::Network::Address::IpVersion::v6) !=
+-      versions.end()) {
+-    return AF_INET6;
+-  }
+-  return -1;
+-}
+-
+-} // namespace
+-
+-// Returns the address family to be used for test. Return v4 if the environment
+-// supports v4 only or both v4 and v6. Otherwise return v6 or an invalid value.
+-int AddressFamilyUnderTestImpl() {
+-  static const int version = addressFamilyUnderTestHelper();
+-  return version;
+-}
+-
+-} // namespace epoll_server
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_bug_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_bug_impl.h
+deleted file mode 100644
+index 7ecd325246..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_bug_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_bug_tracker_impl.h"
+-
+-#define EPOLL_BUG_IMPL QUIC_BUG_IMPL
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_expect_bug_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_expect_bug_impl.h
+deleted file mode 100644
+index 9748ecab32..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_expect_bug_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h"
+-
+-#define EXPECT_EPOLL_BUG_IMPL EXPECT_QUIC_BUG_IMPL
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_export_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_export_impl.h
+deleted file mode 100644
+index 65d77158aa..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_export_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#define EPOLL_EXPORT
+-#define EPOLL_EXPORT_PRIVATE
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_logging_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_logging_impl.h
+deleted file mode 100644
+index 36ca6d4f79..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_logging_impl.h
++++ /dev/null
+@@ -1,20 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_logging_impl.h"
+-
+-namespace epoll_server {
+-
+-#define EPOLL_LOG_IMPL(severity) QUIC_LOG_IMPL(severity)
+-#define EPOLL_VLOG_IMPL(verbosity) QUIC_VLOG_IMPL(verbosity)
+-
+-#define EPOLL_PLOG_IMPL(severity) QUIC_PLOG_IMPL(severity)
+-
+-#define EPOLL_DVLOG_IMPL(verbosity) QUIC_DVLOG_IMPL(verbosity)
+-
+-} // namespace epoll_server
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_ptr_util_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_ptr_util_impl.h
+deleted file mode 100644
+index 12da8b11d3..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_ptr_util_impl.h
++++ /dev/null
+@@ -1,17 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <memory>
+-
+-namespace epoll_server {
+-
+-template <typename T, typename... Args> std::unique_ptr<T> EpollMakeUniqueImpl(Args&&... args) {
+-  return std::make_unique<T>(std::forward<Args>(args)...);
+-}
+-
+-} // namespace epoll_server
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_test_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_test_impl.h
+deleted file mode 100644
+index f0f25ed3b1..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_test_impl.h
++++ /dev/null
+@@ -1,12 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using EpollTestImpl = ::testing::Test;
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_thread_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_thread_impl.h
+deleted file mode 100644
+index be5b5271b7..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_thread_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_thread_impl.h"
+-
+-namespace epoll_server {
+-
+-using EpollThreadImpl = quic::QuicThreadImpl;
+-
+-} // namespace epoll_server
+diff --git a/test/extensions/quic_listeners/quiche/platform/epoll_time_impl.h b/test/extensions/quic_listeners/quiche/platform/epoll_time_impl.h
+deleted file mode 100644
+index 123ceb7449..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/epoll_time_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/time/clock.h"
+-
+-namespace epoll_server {
+-
+-inline int64_t WallTimeNowInUsecImpl() { return absl::GetCurrentTimeNanos() / 1000; }
+-
+-} // namespace epoll_server
+diff --git a/test/extensions/quic_listeners/quiche/platform/http2_platform_test.cc b/test/extensions/quic_listeners/quiche/platform/http2_platform_test.cc
+deleted file mode 100644
+index 68e191111b..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/http2_platform_test.cc
++++ /dev/null
+@@ -1,147 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <memory>
+-#include <string>
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#include "test/test_common/logging.h"
+-
+-#include "gtest/gtest.h"
+-#include "quiche/http2/platform/api/http2_arraysize.h"
+-#include "quiche/http2/platform/api/http2_bug_tracker.h"
+-#include "quiche/http2/platform/api/http2_containers.h"
+-#include "quiche/http2/platform/api/http2_estimate_memory_usage.h"
+-#include "quiche/http2/platform/api/http2_flags.h"
+-#include "quiche/http2/platform/api/http2_logging.h"
+-#include "quiche/http2/platform/api/http2_macros.h"
+-#include "quiche/http2/platform/api/http2_optional.h"
+-#include "quiche/http2/platform/api/http2_reconstruct_object.h"
+-#include "quiche/http2/platform/api/http2_string_piece.h"
+-#include "quiche/http2/test_tools/http2_random.h"
+-
+-// Basic tests to validate functioning of the QUICHE http2 platform
+-// implementation. For platform APIs in which the implementation is a simple
+-// typedef/passthrough to a std:: or absl:: construct, the tests are kept
+-// minimal, and serve primarily to verify the APIs compile and link without
+-// issue.
+-
+-namespace http2 {
+-namespace {
+-
+-TEST(Http2PlatformTest, Http2Arraysize) {
+-  int array[] = {0, 1, 2, 3, 4};
+-  EXPECT_EQ(5, HTTP2_ARRAYSIZE(array));
+-}
+-
+-TEST(Http2PlatformTest, Http2BugTracker) {
+-  EXPECT_DEBUG_DEATH(HTTP2_BUG << "Here is a bug,", " bug");
+-  EXPECT_DEBUG_DEATH(HTTP2_BUG_IF(true) << "There is a bug,", " bug");
+-  EXPECT_LOG_NOT_CONTAINS("error", "", HTTP2_BUG_IF(false) << "A feature is not a bug.");
+-
+-  EXPECT_EQ(true, FLAGS_http2_always_log_bugs_for_tests);
+-}
+-
+-TEST(Http2PlatformTest, Http2Deque) {
+-  http2::Http2Deque<int> deque;
+-  deque.push_back(10);
+-  EXPECT_EQ(10, deque.back());
+-}
+-
+-TEST(Http2PlatformTest, Http2EstimateMemoryUsage) {
+-  std::string s = "foo";
+-  // Stubbed out to always return 0.
+-  EXPECT_EQ(0, http2::Http2EstimateMemoryUsage(s));
+-}
+-
+-TEST(Http2PlatformTest, Http2Log) {
+-  // HTTP2_LOG macros are defined to QUIC_LOG macros, which is tested in
+-  // QuicPlatformTest. Here we just make sure HTTP2_LOG macros compile.
+-  HTTP2_LOG(INFO) << "INFO log may not show up by default.";
+-  HTTP2_LOG(ERROR) << "ERROR log should show up by default.";
+-
+-  // VLOG are only emitted if INFO is enabled and verbosity level is high enough.
+-  HTTP2_VLOG(1) << "VLOG(1)";
+-
+-  HTTP2_DLOG(INFO) << "DLOG(INFO)";
+-  HTTP2_DLOG(ERROR) << "DLOG(ERROR)";
+-
+-  HTTP2_DLOG_IF(ERROR, true) << "DLOG_IF(ERROR, true)";
+-  HTTP2_DLOG_IF(ERROR, false) << "DLOG_IF(ERROR, false)";
+-
+-  HTTP2_DVLOG(2) << "DVLOG(2)";
+-
+-  HTTP2_DVLOG_IF(3, true) << "DVLOG_IF(3, true)";
+-  HTTP2_DVLOG_IF(4, false) << "DVLOG_IF(4, false)";
+-
+-  HTTP2_DLOG_EVERY_N(ERROR, 2) << "DLOG_EVERY_N(ERROR, 2)";
+-}
+-
+-TEST(Http2PlatformTest, Http2Optional) {
+-  http2::Http2Optional<int> opt;
+-  EXPECT_FALSE(opt.has_value());
+-  opt = 3;
+-  EXPECT_TRUE(opt.has_value());
+-}
+-
+-TEST(Http2PlatformTest, Http2ReconstructObject) {
+-  http2::test::Http2Random rng;
+-  std::string s;
+-
+-  http2::test::Http2ReconstructObject(&s, &rng, "123");
+-  EXPECT_EQ("123", s);
+-
+-  http2::test::Http2ReconstructObject(&s, &rng, "456");
+-  EXPECT_EQ("456", s);
+-
+-  http2::test::Http2DefaultReconstructObject(&s, &rng);
+-  EXPECT_EQ("", s);
+-}
+-
+-TEST(Http2PlatformTest, Http2StringPiece) {
+-  std::string s = "bar";
+-  http2::Http2StringPiece sp(s);
+-  EXPECT_EQ('b', sp[0]);
+-}
+-
+-TEST(Http2PlatformTest, Http2Macro) {
+-  EXPECT_DEBUG_DEATH(HTTP2_UNREACHABLE(), "");
+-  EXPECT_DEATH(HTTP2_DIE_IF_NULL(nullptr), "");
+-}
+-
+-TEST(Http2PlatformTest, Http2Flags) {
+-  auto& flag_registry = quiche::FlagRegistry::GetInstance();
+-  flag_registry.ResetFlags();
+-  EXPECT_FALSE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-  SetHttp2ReloadableFlag(http2_testonly_default_false, true);
+-  EXPECT_TRUE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-
+-  for (std::string s : {"1", "t", "true", "TRUE", "y", "yes", "Yes"}) {
+-    SetHttp2ReloadableFlag(http2_testonly_default_false, false);
+-    EXPECT_FALSE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-    EXPECT_TRUE(flag_registry.FindFlag("http2_reloadable_flag_http2_testonly_default_false")
+-                    ->SetValueFromString(s));
+-    EXPECT_TRUE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-  }
+-  for (std::string s : {"0", "f", "false", "FALSE", "n", "no", "No"}) {
+-    SetHttp2ReloadableFlag(http2_testonly_default_false, true);
+-    EXPECT_TRUE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-    EXPECT_TRUE(flag_registry.FindFlag("http2_reloadable_flag_http2_testonly_default_false")
+-                    ->SetValueFromString(s));
+-    EXPECT_FALSE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-  }
+-  for (std::string s : {"some", "invalid", "values", ""}) {
+-    SetHttp2ReloadableFlag(http2_testonly_default_false, false);
+-    EXPECT_FALSE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-    EXPECT_FALSE(flag_registry.FindFlag("http2_reloadable_flag_http2_testonly_default_false")
+-                     ->SetValueFromString(s));
+-    EXPECT_FALSE(GetHttp2ReloadableFlag(http2_testonly_default_false));
+-  }
+-}
+-
+-} // namespace
+-} // namespace http2
+diff --git a/test/extensions/quic_listeners/quiche/platform/http2_reconstruct_object_impl.h b/test/extensions/quic_listeners/quiche/platform/http2_reconstruct_object_impl.h
+deleted file mode 100644
+index 974e3fa48b..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/http2_reconstruct_object_impl.h
++++ /dev/null
+@@ -1,32 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <utility>
+-
+-namespace http2 {
+-namespace test {
+-
+-class Http2Random;
+-
+-// Reconstruct an object so that it is initialized as when it was first
+-// constructed. Runs the destructor to handle objects that might own resources,
+-// and runs the constructor with the provided arguments, if any.
+-template <class T, class... Args>
+-void Http2ReconstructObjectImpl(T* ptr, Http2Random* /*rng*/, Args&&... args) {
+-  ptr->~T();
+-  ::new (ptr) T(std::forward<Args>(args)...);
+-}
+-
+-// This version applies default-initialization to the object.
+-template <class T> void Http2DefaultReconstructObjectImpl(T* ptr, Http2Random* /*rng*/) {
+-  ptr->~T();
+-  ::new (ptr) T;
+-}
+-
+-} // namespace test
+-} // namespace http2
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.cc b/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.cc
+deleted file mode 100644
+index 0ba0e1a010..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.cc
++++ /dev/null
+@@ -1,38 +0,0 @@
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h"
+-
+-namespace quic {
+-
+-QuicEpollClock::QuicEpollClock(epoll_server::SimpleEpollServer* epoll_server)
+-    : epoll_server_(epoll_server), largest_time_(QuicTime::Zero()) {}
+-
+-QuicTime QuicEpollClock::ApproximateNow() const {
+-  return CreateTimeFromMicroseconds(epoll_server_->ApproximateNowInUsec());
+-}
+-
+-QuicTime QuicEpollClock::Now() const {
+-  QuicTime now = CreateTimeFromMicroseconds(epoll_server_->NowInUsec());
+-
+-  if (now <= largest_time_) {
+-    // Time not increasing, return |largest_time_|.
+-    return largest_time_;
+-  }
+-
+-  largest_time_ = now;
+-  return largest_time_;
+-}
+-
+-QuicWallTime QuicEpollClock::WallNow() const {
+-  return QuicWallTime::FromUNIXMicroseconds(epoll_server_->ApproximateNowInUsec());
+-}
+-
+-QuicTime QuicEpollClock::ConvertWallTimeToQuicTime(const QuicWallTime& walltime) const {
+-  return QuicTime::Zero() + QuicTime::Delta::FromMicroseconds(walltime.ToUNIXMicroseconds());
+-}
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h b/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h
+deleted file mode 100644
+index f1446dbb4b..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h
++++ /dev/null
+@@ -1,47 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/epoll_server/simple_epoll_server.h"
+-#include "quiche/quic/core/quic_time.h"
+-#include "quiche/quic/platform/api/quic_clock.h"
+-
+-namespace quic {
+-
+-// Clock to efficiently retrieve an approximately accurate time from an
+-// epoll_server::SimpleEpollServer.
+-class QuicEpollClock : public QuicClock {
+-public:
+-  explicit QuicEpollClock(epoll_server::SimpleEpollServer* epoll_server);
+-
+-  QuicEpollClock(const QuicEpollClock&) = delete;
+-  QuicEpollClock& operator=(const QuicEpollClock&) = delete;
+-
+-  ~QuicEpollClock() override = default;
+-
+-  // Returns the approximate current time as a QuicTime object.
+-  QuicTime ApproximateNow() const override;
+-
+-  // Returns the current time as a QuicTime object.
+-  // Note: this uses significant resources, please use only if needed.
+-  QuicTime Now() const override;
+-
+-  // Returns the current time as a QuicWallTime object.
+-  // Note: this uses significant resources, please use only if needed.
+-  QuicWallTime WallNow() const override;
+-
+-  // Override to do less work in this implementation. The epoll clock is
+-  // already based on system (unix epoch) time, no conversion required.
+-  QuicTime ConvertWallTimeToQuicTime(const QuicWallTime& walltime) const override;
+-
+-protected:
+-  epoll_server::SimpleEpollServer* epoll_server_;
+-  // Largest time returned from Now() so far.
+-  mutable QuicTime largest_time_;
+-};
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_epoll_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_epoll_impl.h
+deleted file mode 100644
+index 82f81cfee7..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_epoll_impl.h
++++ /dev/null
+@@ -1,18 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/epoll_server/simple_epoll_server.h"
+-
+-namespace quic {
+-
+-using QuicEpollServerImpl = epoll_server::SimpleEpollServer;
+-using QuicEpollEventImpl = epoll_server::EpollEvent;
+-using QuicEpollAlarmBaseImpl = epoll_server::EpollAlarm;
+-using QuicEpollCallbackInterfaceImpl = epoll_server::EpollCallbackInterface;
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h
+deleted file mode 100644
+index 7ddba5ef37..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/quic/platform/api/quic_logging.h"
+-#include "quiche/quic/platform/api/quic_mock_log.h"
+-
+-#define EXPECT_QUIC_BUG_IMPL(statement, regex)                                                     \
+-  EXPECT_QUIC_DFATAL_IMPL(statement, testing::ContainsRegex(regex))
+-
+-#define EXPECT_QUIC_PEER_BUG_IMPL(statement, regex)                                                \
+-  EXPECT_QUIC_LOG_IMPL(statement, ERROR, testing::ContainsRegex(regex))
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_mock_log_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_mock_log_impl.h
+deleted file mode 100644
+index f5cdc5e744..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_mock_log_impl.h
++++ /dev/null
+@@ -1,98 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-
+-#include "common/common/assert.h"
+-
+-#include "gmock/gmock.h"
+-#include "quiche/quic/platform/api/quic_logging.h"
+-
+-namespace quic {
+-
+-// A QuicEnvoyMockLog object captures QUIC_LOG() messages emitted between StartCapturingLogs() and
+-// destruction(or StopCapturingLogs()).
+-class QuicEnvoyMockLog : public QuicLogSink {
+-public:
+-  QuicEnvoyMockLog() = default;
+-
+-  ~QuicEnvoyMockLog() override {
+-    if (is_capturing_) {
+-      StopCapturingLogs();
+-    }
+-  }
+-
+-  MOCK_METHOD2(Log, void(QuicLogLevel level, const std::string& message));
+-
+-  void StartCapturingLogs() {
+-    ASSERT(!is_capturing_);
+-    is_capturing_ = true;
+-    original_sink_ = SetLogSink(this);
+-  }
+-
+-  void StopCapturingLogs() {
+-    ASSERT(is_capturing_);
+-    is_capturing_ = false;
+-    SetLogSink(original_sink_);
+-  }
+-
+-private:
+-  QuicLogSink* original_sink_;
+-  bool is_capturing_{false};
+-};
+-
+-// ScopedDisableExitOnDFatal is used to disable exiting the program when we encounter a
+-// QUIC_LOG(DFATAL) within the current block. After we leave the current block, the previous
+-// behavior is restored.
+-class ScopedDisableExitOnDFatal {
+-public:
+-  ScopedDisableExitOnDFatal() : previous_value_(IsDFatalExitDisabled()) {
+-    SetDFatalExitDisabled(true);
+-  }
+-
+-  ScopedDisableExitOnDFatal(const ScopedDisableExitOnDFatal&) = delete;
+-  ScopedDisableExitOnDFatal& operator=(const ScopedDisableExitOnDFatal&) = delete;
+-
+-  ~ScopedDisableExitOnDFatal() { SetDFatalExitDisabled(previous_value_); }
+-
+-private:
+-  const bool previous_value_;
+-};
+-
+-} // namespace quic
+-
+-using QuicMockLogImpl = quic::QuicEnvoyMockLog;
+-
+-#define CREATE_QUIC_MOCK_LOG_IMPL(log) QuicMockLog log
+-
+-#define EXPECT_QUIC_LOG_CALL_IMPL(log) EXPECT_CALL(log, Log(testing::_, testing::_))
+-
+-#define EXPECT_QUIC_LOG_CALL_CONTAINS_IMPL(log, level, content)                                    \
+-  EXPECT_CALL(log, Log(quic::level, testing::HasSubstr(content)))
+-
+-// Not part of the api exposed by quic_mock_log.h. This is used by
+-// quic_expect_bug_impl.h.
+-#define EXPECT_QUIC_LOG_IMPL(statement, level, matcher)                                            \
+-  do {                                                                                             \
+-    quic::QuicEnvoyMockLog mock_log;                                                               \
+-    EXPECT_CALL(mock_log, Log(quic::level, matcher)).Times(testing::AtLeast(1));                   \
+-    mock_log.StartCapturingLogs();                                                                 \
+-    { statement; }                                                                                 \
+-    mock_log.StopCapturingLogs();                                                                  \
+-    if (!testing::Mock::VerifyAndClear(&mock_log)) {                                               \
+-      GTEST_NONFATAL_FAILURE_("");                                                                 \
+-    }                                                                                              \
+-  } while (false)
+-
+-#define EXPECT_QUIC_DFATAL_IMPL(statement, matcher)                                                \
+-  EXPECT_QUIC_LOG_IMPL(                                                                            \
+-      {                                                                                            \
+-        quic::ScopedDisableExitOnDFatal disable_exit_on_dfatal;                                    \
+-        statement;                                                                                 \
+-      },                                                                                           \
+-      DFATAL, matcher)
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_platform_test.cc b/test/extensions/quic_listeners/quiche/platform/quic_platform_test.cc
+deleted file mode 100644
+index 615a5273ae..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_platform_test.cc
++++ /dev/null
+@@ -1,814 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <netinet/in.h>
+-
+-#include <fstream>
+-#include <unordered_set>
+-
+-#include "common/memory/stats.h"
+-#include "common/network/utility.h"
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#include "test/common/buffer/utility.h"
+-#include "test/common/stats/stat_test_utility.h"
+-#include "test/extensions/quic_listeners/quiche/platform/quic_epoll_clock.h"
+-#include "test/extensions/transport_sockets/tls/ssl_test_utility.h"
+-#include "test/mocks/api/mocks.h"
+-#include "test/test_common/environment.h"
+-#include "test/test_common/logging.h"
+-#include "test/test_common/network_utility.h"
+-#include "test/test_common/threadsafe_singleton_injector.h"
+-#include "test/test_common/utility.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-#include "quiche/epoll_server/fake_simple_epoll_server.h"
+-#include "quiche/quic/platform/api/quic_aligned.h"
+-#include "quiche/quic/platform/api/quic_arraysize.h"
+-#include "quiche/quic/platform/api/quic_bug_tracker.h"
+-#include "quiche/quic/platform/api/quic_cert_utils.h"
+-#include "quiche/quic/platform/api/quic_client_stats.h"
+-#include "quiche/quic/platform/api/quic_containers.h"
+-#include "quiche/quic/platform/api/quic_endian.h"
+-#include "quiche/quic/platform/api/quic_estimate_memory_usage.h"
+-#include "quiche/quic/platform/api/quic_expect_bug.h"
+-#include "quiche/quic/platform/api/quic_exported_stats.h"
+-#include "quiche/quic/platform/api/quic_file_utils.h"
+-#include "quiche/quic/platform/api/quic_flags.h"
+-#include "quiche/quic/platform/api/quic_hostname_utils.h"
+-#include "quiche/quic/platform/api/quic_logging.h"
+-#include "quiche/quic/platform/api/quic_macros.h"
+-#include "quiche/quic/platform/api/quic_map_util.h"
+-#include "quiche/quic/platform/api/quic_mem_slice.h"
+-#include "quiche/quic/platform/api/quic_mem_slice_span.h"
+-#include "quiche/quic/platform/api/quic_mem_slice_storage.h"
+-#include "quiche/quic/platform/api/quic_mock_log.h"
+-#include "quiche/quic/platform/api/quic_mutex.h"
+-#include "quiche/quic/platform/api/quic_optional.h"
+-#include "quiche/quic/platform/api/quic_pcc_sender.h"
+-#include "quiche/quic/platform/api/quic_port_utils.h"
+-#include "quiche/quic/platform/api/quic_ptr_util.h"
+-#include "quiche/quic/platform/api/quic_server_stats.h"
+-#include "quiche/quic/platform/api/quic_sleep.h"
+-#include "quiche/quic/platform/api/quic_stack_trace.h"
+-#include "quiche/quic/platform/api/quic_stream_buffer_allocator.h"
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-#include "quiche/quic/platform/api/quic_system_event_loop.h"
+-#include "quiche/quic/platform/api/quic_test.h"
+-#include "quiche/quic/platform/api/quic_test_output.h"
+-#include "quiche/quic/platform/api/quic_thread.h"
+-#include "quiche/quic/platform/api/quic_uint128.h"
+-
+-// Basic tests to validate functioning of the QUICHE quic platform
+-// implementation. For platform APIs in which the implementation is a simple
+-// typedef/passthrough to a std:: or absl:: construct, the tests are kept
+-// minimal, and serve primarily to verify the APIs compile and link without
+-// issue.
+-
+-using testing::_;
+-using testing::HasSubstr;
+-using testing::Return;
+-
+-namespace quic {
+-namespace {
+-
+-class QuicPlatformTest : public testing::Test {
+-protected:
+-  QuicPlatformTest()
+-      : log_level_(GetLogger().level()), verbosity_log_threshold_(GetVerbosityLogThreshold()) {
+-    SetVerbosityLogThreshold(0);
+-    GetLogger().set_level(ERROR);
+-  }
+-
+-  ~QuicPlatformTest() override {
+-    SetVerbosityLogThreshold(verbosity_log_threshold_);
+-    GetLogger().set_level(log_level_);
+-  }
+-
+-  const QuicLogLevel log_level_;
+-  const int verbosity_log_threshold_;
+-};
+-
+-TEST_F(QuicPlatformTest, QuicAlignOf) { EXPECT_LT(0, QUIC_ALIGN_OF(int)); }
+-
+-TEST_F(QuicPlatformTest, QuicArraysize) {
+-  int array[] = {0, 1, 2, 3, 4};
+-  EXPECT_EQ(5, QUIC_ARRAYSIZE(array));
+-}
+-
+-enum class TestEnum { ZERO = 0, ONE, TWO, COUNT };
+-
+-TEST_F(QuicPlatformTest, QuicBugTracker) {
+-  EXPECT_DEBUG_DEATH(QUIC_BUG << "Here is a bug,", " bug");
+-  EXPECT_DEBUG_DEATH(QUIC_BUG_IF(true) << "There is a bug,", " bug");
+-  EXPECT_LOG_NOT_CONTAINS("error", "", QUIC_BUG_IF(false) << "A feature is not a bug.");
+-
+-  EXPECT_LOG_CONTAINS("error", " bug", QUIC_PEER_BUG << "Everywhere's a bug,");
+-  EXPECT_LOG_CONTAINS("error", " here", QUIC_PEER_BUG_IF(true) << "Including here.");
+-  EXPECT_LOG_NOT_CONTAINS("error", "", QUIC_PEER_BUG_IF(false) << "But not there.");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicClientStats) {
+-  // Just make sure they compile.
+-  QUIC_CLIENT_HISTOGRAM_ENUM("my.enum.histogram", TestEnum::ONE, TestEnum::COUNT, "doc");
+-  QUIC_CLIENT_HISTOGRAM_BOOL("my.bool.histogram", false, "doc");
+-  QUIC_CLIENT_HISTOGRAM_TIMES("my.timing.histogram", QuicTime::Delta::FromSeconds(5),
+-                              QuicTime::Delta::FromSeconds(1), QuicTime::Delta::FromSecond(3600),
+-                              100, "doc");
+-  QUIC_CLIENT_HISTOGRAM_COUNTS("my.count.histogram", 123, 0, 1000, 100, "doc");
+-  QuicClientSparseHistogram("my.sparse.histogram", 345);
+-  // Make sure compiler doesn't report unused-parameter error.
+-  bool should_be_used;
+-  QUIC_CLIENT_HISTOGRAM_BOOL("my.bool.histogram", should_be_used, "doc");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicExpectBug) {
+-  auto bug = [](const char* error_message) { QUIC_BUG << error_message; };
+-
+-  auto peer_bug = [](const char* error_message) { QUIC_PEER_BUG << error_message; };
+-
+-  EXPECT_QUIC_BUG(bug("bug one is expected"), "bug one");
+-  EXPECT_QUIC_BUG(bug("bug two is expected"), "bug two");
+-
+-  EXPECT_QUIC_PEER_BUG(peer_bug("peer_bug_1 is expected"), "peer_bug_1");
+-  EXPECT_QUIC_PEER_BUG(peer_bug("peer_bug_2 is expected"), "peer_bug_2");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicExportedStats) {
+-  // Just make sure they compile.
+-  QUIC_HISTOGRAM_ENUM("my.enum.histogram", TestEnum::ONE, TestEnum::COUNT, "doc");
+-  QUIC_HISTOGRAM_BOOL("my.bool.histogram", false, "doc");
+-  QUIC_HISTOGRAM_TIMES("my.timing.histogram", QuicTime::Delta::FromSeconds(5),
+-                       QuicTime::Delta::FromSeconds(1), QuicTime::Delta::FromSecond(3600), 100,
+-                       "doc");
+-  QUIC_HISTOGRAM_COUNTS("my.count.histogram", 123, 0, 1000, 100, "doc");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicHostnameUtils) {
+-  EXPECT_FALSE(QuicHostnameUtils::IsValidSNI("!!"));
+-  EXPECT_FALSE(QuicHostnameUtils::IsValidSNI("envoyproxy"));
+-  EXPECT_TRUE(QuicHostnameUtils::IsValidSNI("www.envoyproxy.io"));
+-  EXPECT_EQ("lyft.com", QuicHostnameUtils::NormalizeHostname("lyft.com"));
+-  EXPECT_EQ("google.com", QuicHostnameUtils::NormalizeHostname("google.com..."));
+-  EXPECT_EQ("quicwg.org", QuicHostnameUtils::NormalizeHostname("QUICWG.ORG"));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicUnorderedMap) {
+-  QuicUnorderedMap<std::string, int> umap;
+-  umap.insert({"foo", 2});
+-  EXPECT_EQ(2, umap["foo"]);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicUnorderedSet) {
+-  QuicUnorderedSet<std::string> uset({"foo", "bar"});
+-  EXPECT_EQ(1, uset.count("bar"));
+-  EXPECT_EQ(0, uset.count("qux"));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicQueue) {
+-  QuicQueue<int> queue;
+-  queue.push(10);
+-  EXPECT_EQ(10, queue.back());
+-}
+-
+-TEST_F(QuicPlatformTest, QuicDeque) {
+-  QuicDeque<int> deque;
+-  deque.push_back(10);
+-  EXPECT_EQ(10, deque.back());
+-}
+-
+-TEST_F(QuicPlatformTest, QuicInlinedVector) {
+-  QuicInlinedVector<int, 5> vec;
+-  vec.push_back(3);
+-  EXPECT_EQ(3, vec[0]);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicEndian) {
+-  EXPECT_EQ(0x1234, QuicEndian::NetToHost16(QuicEndian::HostToNet16(0x1234)));
+-  EXPECT_EQ(0x12345678, QuicEndian::NetToHost32(QuicEndian::HostToNet32(0x12345678)));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicEstimateMemoryUsage) {
+-  std::string s = "foo";
+-  // Stubbed out to always return 0.
+-  EXPECT_EQ(0, QuicEstimateMemoryUsage(s));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicMapUtil) {
+-  std::map<std::string, int> stdmap = {{"one", 1}, {"two", 2}, {"three", 3}};
+-  EXPECT_TRUE(QuicContainsKey(stdmap, "one"));
+-  EXPECT_FALSE(QuicContainsKey(stdmap, "zero"));
+-
+-  QuicUnorderedMap<int, int> umap = {{1, 1}, {2, 4}, {3, 9}};
+-  EXPECT_TRUE(QuicContainsKey(umap, 2));
+-  EXPECT_FALSE(QuicContainsKey(umap, 10));
+-
+-  QuicUnorderedSet<std::string> uset({"foo", "bar"});
+-  EXPECT_TRUE(QuicContainsKey(uset, "foo"));
+-  EXPECT_FALSE(QuicContainsKey(uset, "abc"));
+-
+-  std::vector<int> stdvec = {1, 2, 3};
+-  EXPECT_TRUE(QuicContainsValue(stdvec, 1));
+-  EXPECT_FALSE(QuicContainsValue(stdvec, 0));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicMockLog) {
+-  ASSERT_EQ(ERROR, GetLogger().level());
+-
+-  {
+-    // Test a mock log that is not capturing logs.
+-    CREATE_QUIC_MOCK_LOG(log);
+-    EXPECT_QUIC_LOG_CALL(log).Times(0);
+-    QUIC_LOG(ERROR) << "This should be logged but not captured by the mock.";
+-  }
+-
+-  // Test nested mock logs.
+-  CREATE_QUIC_MOCK_LOG(outer_log);
+-  outer_log.StartCapturingLogs();
+-
+-  {
+-    // Test a mock log that captures logs.
+-    CREATE_QUIC_MOCK_LOG(inner_log);
+-    inner_log.StartCapturingLogs();
+-
+-    EXPECT_QUIC_LOG_CALL_CONTAINS(inner_log, ERROR, "Inner log message");
+-    QUIC_LOG(ERROR) << "Inner log message should be captured.";
+-
+-    // Destruction of inner_log should restore the QUIC log sink to outer_log.
+-  }
+-
+-  EXPECT_QUIC_LOG_CALL_CONTAINS(outer_log, ERROR, "Outer log message");
+-  QUIC_LOG(ERROR) << "Outer log message should be captured.";
+-}
+-
+-TEST_F(QuicPlatformTest, QuicServerStats) {
+-  // Just make sure they compile.
+-  QUIC_SERVER_HISTOGRAM_ENUM("my.enum.histogram", TestEnum::ONE, TestEnum::COUNT, "doc");
+-  QUIC_SERVER_HISTOGRAM_BOOL("my.bool.histogram", false, "doc");
+-  QUIC_SERVER_HISTOGRAM_TIMES("my.timing.histogram", QuicTime::Delta::FromSeconds(5),
+-                              QuicTime::Delta::FromSeconds(1), QuicTime::Delta::FromSecond(3600),
+-                              100, "doc");
+-  QUIC_SERVER_HISTOGRAM_COUNTS("my.count.histogram", 123, 0, 1000, 100, "doc");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicStackTraceTest) {
+-  EXPECT_THAT(QuicStackTrace(), HasSubstr("QuicStackTraceTest"));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicSleep) { QuicSleep(QuicTime::Delta::FromMilliseconds(20)); }
+-
+-TEST_F(QuicPlatformTest, QuicStringPiece) {
+-  std::string s = "bar";
+-  QuicStringPiece sp(s);
+-  EXPECT_EQ('b', sp[0]);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicThread) {
+-  class AdderThread : public QuicThread {
+-  public:
+-    AdderThread(int* value, int increment)
+-        : QuicThread("adder_thread"), value_(value), increment_(increment) {}
+-
+-    ~AdderThread() override = default;
+-
+-  protected:
+-    void Run() override { *value_ += increment_; }
+-
+-  private:
+-    int* value_;
+-    int increment_;
+-  };
+-
+-  int value = 0;
+-
+-  // A QuicThread that is never started, which is ok.
+-  { AdderThread t0(&value, 1); }
+-  EXPECT_EQ(0, value);
+-
+-  // A QuicThread that is started and joined as usual.
+-  {
+-    AdderThread t1(&value, 1);
+-    t1.Start();
+-    t1.Join();
+-  }
+-  EXPECT_EQ(1, value);
+-
+-  // QuicThread will panic if it's started but not joined.
+-  EXPECT_DEATH_LOG_TO_STDERR({ AdderThread(&value, 2).Start(); },
+-                             "QuicThread should be joined before destruction");
+-}
+-
+-TEST_F(QuicPlatformTest, QuicUint128) {
+-  QuicUint128 i = MakeQuicUint128(16777216, 315);
+-  EXPECT_EQ(315, QuicUint128Low64(i));
+-  EXPECT_EQ(16777216, QuicUint128High64(i));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicPtrUtil) {
+-  auto p = QuicWrapUnique(new std::string("aaa"));
+-  EXPECT_EQ("aaa", *p);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicLog) {
+-  // By default, tests emit logs at level ERROR or higher.
+-  ASSERT_EQ(ERROR, GetLogger().level());
+-
+-  int i = 0;
+-
+-  QUIC_LOG(INFO) << (i = 10);
+-  QUIC_LOG_IF(INFO, false) << i++;
+-  QUIC_LOG_IF(INFO, true) << i++;
+-  EXPECT_EQ(0, i);
+-
+-  EXPECT_LOG_CONTAINS("error", "i=11", QUIC_LOG(ERROR) << "i=" << (i = 11));
+-  EXPECT_EQ(11, i);
+-
+-  QUIC_LOG_IF(ERROR, false) << i++;
+-  EXPECT_EQ(11, i);
+-
+-  EXPECT_LOG_CONTAINS("error", "i=11", QUIC_LOG_IF(ERROR, true) << "i=" << i++);
+-  EXPECT_EQ(12, i);
+-
+-  // Set QUIC log level to INFO, since VLOG is emitted at the INFO level.
+-  GetLogger().set_level(INFO);
+-
+-  ASSERT_EQ(0, GetVerbosityLogThreshold());
+-
+-  QUIC_VLOG(1) << (i = 1);
+-  EXPECT_EQ(12, i);
+-
+-  SetVerbosityLogThreshold(1);
+-
+-  EXPECT_LOG_CONTAINS("info", "i=1", QUIC_VLOG(1) << "i=" << (i = 1));
+-  EXPECT_EQ(1, i);
+-
+-  errno = EINVAL;
+-  EXPECT_LOG_CONTAINS("info", "i=3:", QUIC_PLOG(INFO) << "i=" << (i = 3));
+-  EXPECT_EQ(3, i);
+-}
+-
+-#ifdef NDEBUG
+-#define VALUE_BY_COMPILE_MODE(debug_mode_value, release_mode_value) release_mode_value
+-#else
+-#define VALUE_BY_COMPILE_MODE(debug_mode_value, release_mode_value) debug_mode_value
+-#endif
+-
+-TEST_F(QuicPlatformTest, LogIoManipulators) {
+-  GetLogger().set_level(ERROR);
+-  QUIC_DLOG(ERROR) << "aaaa" << std::endl;
+-  EXPECT_LOG_CONTAINS("error", "aaaa\n\n", QUIC_LOG(ERROR) << "aaaa" << std::endl << std::endl);
+-  EXPECT_LOG_NOT_CONTAINS("error", "aaaa\n\n\n",
+-                          QUIC_LOG(ERROR) << "aaaa" << std::endl
+-                                          << std::endl);
+-
+-  EXPECT_LOG_CONTAINS("error", "42 in octal is 52",
+-                      QUIC_LOG(ERROR) << 42 << " in octal is " << std::oct << 42);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicDLog) {
+-  int i = 0;
+-
+-  GetLogger().set_level(ERROR);
+-
+-  QUIC_DLOG(INFO) << (i = 10);
+-  QUIC_DLOG_IF(INFO, false) << i++;
+-  QUIC_DLOG_IF(INFO, true) << i++;
+-  EXPECT_EQ(0, i);
+-
+-  GetLogger().set_level(INFO);
+-
+-  QUIC_DLOG(INFO) << (i = 10);
+-  QUIC_DLOG_IF(INFO, false) << i++;
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(10, 0), i);
+-
+-  QUIC_DLOG_IF(INFO, true) << (i = 11);
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(11, 0), i);
+-
+-  ASSERT_EQ(0, GetVerbosityLogThreshold());
+-
+-  QUIC_DVLOG(1) << (i = 1);
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(11, 0), i);
+-
+-  SetVerbosityLogThreshold(1);
+-
+-  QUIC_DVLOG(1) << (i = 1);
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(1, 0), i);
+-
+-  QUIC_DVLOG_IF(1, false) << (i = 2);
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(1, 0), i);
+-
+-  QUIC_DVLOG_IF(1, true) << (i = 2);
+-  EXPECT_EQ(VALUE_BY_COMPILE_MODE(2, 0), i);
+-}
+-
+-#undef VALUE_BY_COMPILE_MODE
+-
+-TEST_F(QuicPlatformTest, QuicCHECK) {
+-  CHECK(1 == 1);
+-  CHECK(1 == 1) << " 1 == 1 is forever true.";
+-
+-  EXPECT_DEBUG_DEATH({ DCHECK(false) << " Supposed to fail in debug mode."; },
+-                     "CHECK failed:.* Supposed to fail in debug mode.");
+-  EXPECT_DEBUG_DEATH({ DCHECK(false); }, "CHECK failed");
+-
+-  EXPECT_DEATH_LOG_TO_STDERR({ CHECK(false) << " Supposed to fail in all modes."; },
+-                             "CHECK failed:.* Supposed to fail in all modes.");
+-  EXPECT_DEATH_LOG_TO_STDERR({ CHECK(false); }, "CHECK failed");
+-}
+-
+-// Test the behaviors of the cross products of
+-//
+-//   {QUIC_LOG, QUIC_DLOG} x {FATAL, DFATAL} x {debug, release}
+-TEST_F(QuicPlatformTest, QuicFatalLog) {
+-#ifdef NDEBUG
+-  // Release build
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_LOG(FATAL) << "Should abort 0", "Should abort 0");
+-  QUIC_LOG(DFATAL) << "Should not abort";
+-  QUIC_DLOG(FATAL) << "Should compile out";
+-  QUIC_DLOG(DFATAL) << "Should compile out";
+-#else
+-  // Debug build
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_LOG(FATAL) << "Should abort 1", "Should abort 1");
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_LOG(DFATAL) << "Should abort 2", "Should abort 2");
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_DLOG(FATAL) << "Should abort 3", "Should abort 3");
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_DLOG(DFATAL) << "Should abort 4", "Should abort 4");
+-#endif
+-}
+-
+-TEST_F(QuicPlatformTest, QuicBranchPrediction) {
+-  GetLogger().set_level(INFO);
+-
+-  if (QUIC_PREDICT_FALSE(rand() % RAND_MAX == 123456789)) {
+-    QUIC_LOG(INFO) << "Go buy some lottery tickets.";
+-  } else {
+-    QUIC_LOG(INFO) << "As predicted.";
+-  }
+-}
+-
+-TEST_F(QuicPlatformTest, QuicNotReached) {
+-#ifdef NDEBUG
+-  QUIC_NOTREACHED(); // Expect no-op.
+-#else
+-  EXPECT_DEATH_LOG_TO_STDERR(QUIC_NOTREACHED(), "not reached");
+-#endif
+-}
+-
+-TEST_F(QuicPlatformTest, QuicMutex) {
+-  QuicMutex mu;
+-
+-  QuicWriterMutexLock wmu(&mu);
+-  mu.AssertReaderHeld();
+-  mu.WriterUnlock();
+-  {
+-    QuicReaderMutexLock rmu(&mu);
+-    mu.AssertReaderHeld();
+-  }
+-  mu.WriterLock();
+-}
+-
+-TEST_F(QuicPlatformTest, QuicNotification) {
+-  QuicNotification notification;
+-  EXPECT_FALSE(notification.HasBeenNotified());
+-  notification.Notify();
+-  notification.WaitForNotification();
+-  EXPECT_TRUE(notification.HasBeenNotified());
+-}
+-
+-TEST_F(QuicPlatformTest, QuicCertUtils) {
+-  bssl::UniquePtr<X509> x509_cert =
+-      Envoy::Extensions::TransportSockets::Tls::readCertFromFile(Envoy::TestEnvironment::substitute(
+-          "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem"));
+-  // Encode X509 cert with DER encoding.
+-  unsigned char* der = nullptr;
+-  int len = i2d_X509(x509_cert.get(), &der);
+-  ASSERT_GT(len, 0);
+-  QuicStringPiece out;
+-  QuicCertUtils::ExtractSubjectNameFromDERCert(
+-      QuicStringPiece(reinterpret_cast<const char*>(der), len), &out);
+-  EXPECT_EQ("0z1\v0\t\x6\x3U\x4\x6\x13\x2US1\x13"
+-            "0\x11\x6\x3U\x4\b\f\nCalifornia1\x16"
+-            "0\x14\x6\x3U\x4\a\f\rSan Francisco1\r"
+-            "0\v\x6\x3U\x4\n\f\x4Lyft1\x19"
+-            "0\x17\x6\x3U\x4\v\f\x10Lyft Engineering1\x14"
+-            "0\x12\x6\x3U\x4\x3\f\vTest Server",
+-            out);
+-  OPENSSL_free(static_cast<void*>(der));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicTestOutput) {
+-  Envoy::TestEnvironment::setEnvVar("QUIC_TEST_OUTPUT_DIR", "/tmp", /*overwrite=*/false);
+-
+-  // Set log level to INFO to see the test output path in log.
+-  GetLogger().set_level(INFO);
+-
+-  EXPECT_LOG_NOT_CONTAINS("warn", "",
+-                          QuicRecordTestOutput("quic_test_output.1", "output 1 content\n"));
+-  EXPECT_LOG_NOT_CONTAINS("error", "",
+-                          QuicRecordTestOutput("quic_test_output.2", "output 2 content\n"));
+-  EXPECT_LOG_CONTAINS("info", "Recorded test output into",
+-                      QuicRecordTestOutput("quic_test_output.3", "output 3 content\n"));
+-}
+-
+-TEST_F(QuicPlatformTest, ApproximateNowInUsec) {
+-  epoll_server::test::FakeSimpleEpollServer epoll_server;
+-  QuicEpollClock clock(&epoll_server);
+-
+-  epoll_server.set_now_in_usec(1000000);
+-  EXPECT_EQ(1000000, (clock.ApproximateNow() - QuicTime::Zero()).ToMicroseconds());
+-  EXPECT_EQ(1u, clock.WallNow().ToUNIXSeconds());
+-  EXPECT_EQ(1000000u, clock.WallNow().ToUNIXMicroseconds());
+-
+-  epoll_server.AdvanceBy(5);
+-  EXPECT_EQ(1000005, (clock.ApproximateNow() - QuicTime::Zero()).ToMicroseconds());
+-  EXPECT_EQ(1u, clock.WallNow().ToUNIXSeconds());
+-  EXPECT_EQ(1000005u, clock.WallNow().ToUNIXMicroseconds());
+-
+-  epoll_server.AdvanceBy(10 * 1000000);
+-  EXPECT_EQ(11u, clock.WallNow().ToUNIXSeconds());
+-  EXPECT_EQ(11000005u, clock.WallNow().ToUNIXMicroseconds());
+-}
+-
+-TEST_F(QuicPlatformTest, NowInUsec) {
+-  epoll_server::test::FakeSimpleEpollServer epoll_server;
+-  QuicEpollClock clock(&epoll_server);
+-
+-  epoll_server.set_now_in_usec(1000000);
+-  EXPECT_EQ(1000000, (clock.Now() - QuicTime::Zero()).ToMicroseconds());
+-
+-  epoll_server.AdvanceBy(5);
+-  EXPECT_EQ(1000005, (clock.Now() - QuicTime::Zero()).ToMicroseconds());
+-}
+-
+-TEST_F(QuicPlatformTest, MonotonicityWithRealEpollClock) {
+-  epoll_server::SimpleEpollServer epoll_server;
+-  QuicEpollClock clock(&epoll_server);
+-
+-  quic::QuicTime last_now = clock.Now();
+-  for (int i = 0; i < 1e5; ++i) {
+-    quic::QuicTime now = clock.Now();
+-
+-    ASSERT_LE(last_now, now);
+-
+-    last_now = now;
+-  }
+-}
+-
+-TEST_F(QuicPlatformTest, MonotonicityWithFakeEpollClock) {
+-  epoll_server::test::FakeSimpleEpollServer epoll_server;
+-  QuicEpollClock clock(&epoll_server);
+-
+-  epoll_server.set_now_in_usec(100);
+-  quic::QuicTime last_now = clock.Now();
+-
+-  epoll_server.set_now_in_usec(90);
+-  quic::QuicTime now = clock.Now();
+-
+-  ASSERT_EQ(last_now, now);
+-}
+-
+-TEST_F(QuicPlatformTest, QuicFlags) {
+-  auto& flag_registry = quiche::FlagRegistry::GetInstance();
+-  flag_registry.ResetFlags();
+-
+-  EXPECT_FALSE(GetQuicReloadableFlag(quic_testonly_default_false));
+-  EXPECT_TRUE(GetQuicReloadableFlag(quic_testonly_default_true));
+-  SetQuicReloadableFlag(quic_testonly_default_false, true);
+-  EXPECT_TRUE(GetQuicReloadableFlag(quic_testonly_default_false));
+-
+-  EXPECT_FALSE(GetQuicRestartFlag(quic_testonly_default_false));
+-  EXPECT_TRUE(GetQuicRestartFlag(quic_testonly_default_true));
+-  SetQuicRestartFlag(quic_testonly_default_false, true);
+-  EXPECT_TRUE(GetQuicRestartFlag(quic_testonly_default_false));
+-
+-  EXPECT_EQ(200, GetQuicFlag(FLAGS_quic_time_wait_list_seconds));
+-  SetQuicFlag(FLAGS_quic_time_wait_list_seconds, 100);
+-  EXPECT_EQ(100, GetQuicFlag(FLAGS_quic_time_wait_list_seconds));
+-
+-  flag_registry.ResetFlags();
+-  EXPECT_FALSE(GetQuicReloadableFlag(quic_testonly_default_false));
+-  EXPECT_TRUE(GetQuicRestartFlag(quic_testonly_default_true));
+-  EXPECT_EQ(200, GetQuicFlag(FLAGS_quic_time_wait_list_seconds));
+-  flag_registry.FindFlag("quic_reloadable_flag_quic_testonly_default_false")
+-      ->SetValueFromString("true");
+-  flag_registry.FindFlag("quic_restart_flag_quic_testonly_default_true")->SetValueFromString("0");
+-  flag_registry.FindFlag("quic_time_wait_list_seconds")->SetValueFromString("100");
+-  EXPECT_TRUE(GetQuicReloadableFlag(quic_testonly_default_false));
+-  EXPECT_FALSE(GetQuicRestartFlag(quic_testonly_default_true));
+-  EXPECT_EQ(100, GetQuicFlag(FLAGS_quic_time_wait_list_seconds));
+-}
+-
+-TEST_F(QuicPlatformTest, QuicPccSender) {
+-  EXPECT_DEATH_LOG_TO_STDERR(quic::CreatePccSender(/*clock=*/nullptr, /*rtt_stats=*/nullptr,
+-                                                   /*unacked_packets=*/nullptr, /*random=*/nullptr,
+-                                                   /*stats=*/nullptr,
+-                                                   /*initial_congestion_window=*/0,
+-                                                   /*max_congestion_window=*/0),
+-                             "PccSender is not supported.");
+-}
+-
+-class FileUtilsTest : public testing::Test {
+-public:
+-  FileUtilsTest() : dir_path_(Envoy::TestEnvironment::temporaryPath("quic_file_util_test")) {
+-    files_to_remove_.push(dir_path_);
+-  }
+-
+-protected:
+-  void SetUp() override { Envoy::TestUtility::createDirectory(dir_path_); }
+-
+-  void TearDown() override {
+-    while (!files_to_remove_.empty()) {
+-      const std::string& f = files_to_remove_.top();
+-      Envoy::TestEnvironment::removePath(f);
+-      files_to_remove_.pop();
+-    }
+-  }
+-
+-  void addSubDirs(std::list<std::string> sub_dirs) {
+-    for (const std::string& dir_name : sub_dirs) {
+-      const std::string full_path = dir_path_ + "/" + dir_name;
+-      Envoy::TestUtility::createDirectory(full_path);
+-      files_to_remove_.push(full_path);
+-    }
+-  }
+-
+-  void addFiles(std::list<std::string> files) {
+-    for (const std::string& file_name : files) {
+-      const std::string full_path = dir_path_ + "/" + file_name;
+-      { const std::ofstream file(full_path); }
+-      files_to_remove_.push(full_path);
+-    }
+-  }
+-
+-  const std::string dir_path_;
+-  std::stack<std::string> files_to_remove_;
+-};
+-
+-TEST_F(FileUtilsTest, ReadDirContents) {
+-  addSubDirs({"sub_dir1", "sub_dir2", "sub_dir1/sub_dir1_1"});
+-  addFiles({"file", "sub_dir1/sub_file1", "sub_dir1/sub_dir1_1/sub_file1_1", "sub_dir2/sub_file2"});
+-
+-  EXPECT_THAT(ReadFileContents(dir_path_),
+-              testing::UnorderedElementsAre(dir_path_ + "/file", dir_path_ + "/sub_dir1/sub_file1",
+-                                            dir_path_ + "/sub_dir1/sub_dir1_1/sub_file1_1",
+-                                            dir_path_ + "/sub_dir2/sub_file2"));
+-}
+-
+-TEST_F(FileUtilsTest, ReadFileContents) {
+-  const std::string data = "test string\ntest";
+-  const std::string file_path =
+-      Envoy::TestEnvironment::writeStringToFileForTest("test_envoy", data);
+-  std::string output;
+-  ReadFileContents(file_path, &output);
+-  EXPECT_EQ(data, output);
+-}
+-
+-TEST_F(QuicPlatformTest, PickUnsedPort) {
+-  int port = QuicPickUnusedPortOrDie();
+-  std::vector<Envoy::Network::Address::IpVersion> supported_versions =
+-      Envoy::TestEnvironment::getIpVersionsForTest();
+-  for (auto ip_version : supported_versions) {
+-    Envoy::Network::Address::InstanceConstSharedPtr addr =
+-        Envoy::Network::Test::getCanonicalLoopbackAddress(ip_version);
+-    Envoy::Network::Address::InstanceConstSharedPtr addr_with_port =
+-        Envoy::Network::Utility::getAddressWithPort(*addr, port);
+-    Envoy::Network::IoHandlePtr io_handle =
+-        addr_with_port->socket(Envoy::Network::Address::SocketType::Datagram);
+-    // binding of given port should success.
+-    EXPECT_EQ(0, addr_with_port->bind(io_handle->fd()).rc_);
+-  }
+-}
+-
+-TEST_F(QuicPlatformTest, FailToPickUnsedPort) {
+-  Envoy::Api::MockOsSysCalls os_sys_calls;
+-  Envoy::TestThreadsafeSingletonInjector<Envoy::Api::OsSysCallsImpl> os_calls(&os_sys_calls);
+-  // Actually create sockets.
+-  EXPECT_CALL(os_sys_calls, socket(_, _, _)).WillRepeatedly([](int domain, int type, int protocol) {
+-    int fd = ::socket(domain, type, protocol);
+-    return Envoy::Api::SysCallIntResult{fd, errno};
+-  });
+-  // Fail bind call's to mimic port exhaustion.
+-  EXPECT_CALL(os_sys_calls, bind(_, _, _))
+-      .WillRepeatedly(Return(Envoy::Api::SysCallIntResult{-1, EADDRINUSE}));
+-  EXPECT_DEATH_LOG_TO_STDERR(QuicPickUnusedPortOrDie(), "Failed to pick a port for test.");
+-}
+-
+-TEST_F(QuicPlatformTest, TestEnvoyQuicBufferAllocator) {
+-  QuicStreamBufferAllocator allocator;
+-  Envoy::Stats::TestUtil::MemoryTest memory_test;
+-  if (memory_test.mode() == Envoy::Stats::TestUtil::MemoryTest::Mode::Disabled) {
+-    return;
+-  }
+-  char* p = allocator.New(1024);
+-  EXPECT_NE(nullptr, p);
+-  EXPECT_GT(memory_test.consumedBytes(), 0);
+-  memset(p, 'a', 1024);
+-  allocator.Delete(p);
+-  EXPECT_EQ(memory_test.consumedBytes(), 0);
+-}
+-
+-TEST_F(QuicPlatformTest, TestSystemEventLoop) {
+-  // These two interfaces are no-op in Envoy. The test just makes sure they
+-  // build.
+-  QuicRunSystemEventLoopIteration();
+-  QuicSystemEventLoop("dummy");
+-}
+-
+-QUIC_MUST_USE_RESULT bool dummyTestFunction() { return false; }
+-
+-TEST_F(QuicPlatformTest, TestQuicMacros) {
+-  // Just make sure it compiles.
+-  EXPECT_FALSE(dummyTestFunction());
+-  int a QUIC_UNUSED;
+-}
+-
+-TEST_F(QuicPlatformTest, TestQuicOptional) {
+-  QuicOptional<int32_t> maybe_a;
+-  EXPECT_FALSE(maybe_a.has_value());
+-  maybe_a = 1;
+-  EXPECT_EQ(1, *maybe_a);
+-}
+-
+-class QuicMemSliceTest : public Envoy::Buffer::BufferImplementationParamTest {
+-public:
+-  ~QuicMemSliceTest() override = default;
+-};
+-
+-INSTANTIATE_TEST_SUITE_P(QuicMemSliceTests, QuicMemSliceTest,
+-                         testing::ValuesIn({Envoy::Buffer::BufferImplementation::Old,
+-                                            Envoy::Buffer::BufferImplementation::New}));
+-
+-TEST_P(QuicMemSliceTest, ConstructMemSliceFromBuffer) {
+-  std::string str(512, 'b');
+-  // Fragment needs to out-live buffer.
+-  bool fragment_releaser_called = false;
+-  Envoy::Buffer::BufferFragmentImpl fragment(
+-      str.data(), str.length(),
+-      [&fragment_releaser_called](const void*, size_t, const Envoy::Buffer::BufferFragmentImpl*) {
+-        // Used to verify that mem slice release appropriately.
+-        fragment_releaser_called = true;
+-      });
+-  Envoy::Buffer::OwnedImpl buffer;
+-  Envoy::Buffer::BufferImplementationParamTest::verifyImplementation(buffer);
+-  EXPECT_DEBUG_DEATH(quic::QuicMemSlice slice0{quic::QuicMemSliceImpl(buffer, 0)}, "");
+-  std::string str2(1024, 'a');
+-  // str2 is copied.
+-  buffer.add(str2);
+-  EXPECT_EQ(1u, buffer.getRawSlices(nullptr, 0));
+-  buffer.addBufferFragment(fragment);
+-
+-  quic::QuicMemSlice slice1{quic::QuicMemSliceImpl(buffer, str2.length())};
+-  EXPECT_EQ(str.length(), buffer.length());
+-  EXPECT_EQ(str2, std::string(slice1.data(), slice1.length()));
+-  std::string str2_old = str2; // NOLINT(performance-unnecessary-copy-initialization)
+-  // slice1 is released, but str2 should not be affected.
+-  slice1.Reset();
+-  EXPECT_TRUE(slice1.empty());
+-  EXPECT_EQ(nullptr, slice1.data());
+-  EXPECT_EQ(str2_old, str2);
+-
+-  quic::QuicMemSlice slice2{quic::QuicMemSliceImpl(buffer, str.length())};
+-  EXPECT_EQ(0, buffer.length());
+-  EXPECT_EQ(str.data(), slice2.data());
+-  EXPECT_EQ(str, std::string(slice2.data(), slice2.length()));
+-  slice2.Reset();
+-  EXPECT_TRUE(slice2.empty());
+-  EXPECT_EQ(nullptr, slice2.data());
+-  EXPECT_TRUE(fragment_releaser_called);
+-}
+-
+-TEST_P(QuicMemSliceTest, ConstructQuicMemSliceSpan) {
+-  Envoy::Buffer::OwnedImpl buffer;
+-  Envoy::Buffer::BufferImplementationParamTest::verifyImplementation(buffer);
+-  std::string str(1024, 'a');
+-  buffer.add(str);
+-  quic::QuicMemSlice slice{quic::QuicMemSliceImpl(buffer, str.length())};
+-
+-  QuicMemSliceSpan span(&slice);
+-  EXPECT_EQ(1024u, span.total_length());
+-  EXPECT_EQ(str, span.GetData(0));
+-}
+-
+-TEST_P(QuicMemSliceTest, QuicMemSliceStorage) {
+-  std::string str(512, 'a');
+-  struct iovec iov = {const_cast<char*>(str.data()), str.length()};
+-  SimpleBufferAllocator allocator;
+-  QuicMemSliceStorage storage(&iov, 1, &allocator, 1024);
+-  // Test copy constructor.
+-  QuicMemSliceStorage other = storage;
+-  QuicMemSliceSpan span = storage.ToSpan();
+-  EXPECT_EQ(1u, span.NumSlices());
+-  EXPECT_EQ(str.length(), span.total_length());
+-  EXPECT_EQ(str, span.GetData(0));
+-  QuicMemSliceSpan span_other = other.ToSpan();
+-  EXPECT_EQ(1u, span_other.NumSlices());
+-  EXPECT_EQ(str, span_other.GetData(0));
+-  EXPECT_NE(span_other.GetData(0).data(), span.GetData(0).data());
+-}
+-
+-} // namespace
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.cc b/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.cc
+deleted file mode 100644
+index 5dee83fb04..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.cc
++++ /dev/null
+@@ -1,44 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.h"
+-
+-#include "envoy/network/address.h"
+-
+-#include "common/common/assert.h"
+-#include "common/network/utility.h"
+-
+-#include "test/test_common/environment.h"
+-#include "test/test_common/network_utility.h"
+-
+-namespace quic {
+-
+-int QuicPickUnusedPortOrDieImpl() {
+-  std::vector<Envoy::Network::Address::IpVersion> supported_versions =
+-      Envoy::TestEnvironment::getIpVersionsForTest();
+-  ASSERT(!supported_versions.empty());
+-  // Checking availability under corresponding supported version if test
+-  // supports v4 only or v6 only.
+-  // If it supports both v4 and v6, checking availability under v6 with IPV6_V6ONLY
+-  // set to false is sufficient because such socket can be used on v4-mapped
+-  // v6 address.
+-  const Envoy::Network::Address::IpVersion ip_version =
+-      supported_versions.size() == 1 ? supported_versions[0]
+-                                     : Envoy::Network::Address::IpVersion::v6;
+-  auto addr_port = Envoy::Network::Utility::parseInternetAddressAndPort(
+-      fmt::format("{}:{}", Envoy::Network::Test::getAnyAddressUrlString(ip_version), /*port*/ 0),
+-      /*v6only*/ false);
+-  ASSERT(addr_port != nullptr);
+-  addr_port = Envoy::Network::Test::findOrCheckFreePort(
+-      addr_port, Envoy::Network::Address::SocketType::Datagram);
+-  if (addr_port != nullptr && addr_port->ip() != nullptr) {
+-    // Find a port.
+-    return addr_port->ip()->port();
+-  }
+-  RELEASE_ASSERT(false, "Failed to pick a port for test.");
+-}
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.h
+deleted file mode 100644
+index 405266ca0c..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_port_utils_impl.h
++++ /dev/null
+@@ -1,16 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-namespace quic {
+-
+-int QuicPickUnusedPortOrDieImpl();
+-inline void QuicRecyclePortImpl(int) {
+-  // No-op with current port picking implementation.
+-}
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_sleep_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_sleep_impl.h
+deleted file mode 100644
+index 189cfc9d37..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_sleep_impl.h
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "absl/time/clock.h"
+-#include "absl/time/time.h"
+-#include "quiche/quic/core/quic_time.h"
+-
+-namespace quic {
+-
+-inline void QuicSleepImpl(QuicTime::Delta duration) {
+-  absl::SleepFor(absl::Microseconds(duration.ToMicroseconds()));
+-}
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_system_event_loop_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_system_event_loop_impl.h
+deleted file mode 100644
+index d695e02625..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_system_event_loop_impl.h
++++ /dev/null
+@@ -1,19 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-
+-inline void QuicRunSystemEventLoopIterationImpl() {
+-  // No-op.
+-}
+-
+-class QuicSystemEventLoopImpl {
+-public:
+-  // Only used by quic_client_bin.cc which is not required in Envoy.
+-  QuicSystemEventLoopImpl(std::string /*context_name*/) {}
+-};
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_test_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_test_impl.h
+deleted file mode 100644
+index 3782acc9d8..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_test_impl.h
++++ /dev/null
+@@ -1,28 +0,0 @@
+-#pragma once
+-
+-#include <string>
+-
+-#include "common/common/assert.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-// TODO(mpwarres): implement once QUICHE flag mechanism is defined.
+-class QuicFlagSaverImpl {};
+-
+-// No special setup needed for tests to use threads.
+-class ScopedEnvironmentForThreadsImpl {};
+-
+-using QuicTestImpl = ::testing::Test;
+-
+-template <class T> using QuicTestWithParamImpl = ::testing::TestWithParam<T>;
+-
+-inline std::string QuicGetTestMemoryCachePathImpl() {
+-  NOT_IMPLEMENTED_GCOVR_EXCL_LINE; // TODO(mpwarres): implement
+-}
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_test_mem_slice_vector_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_test_mem_slice_vector_impl.h
+deleted file mode 100644
+index 04b6d246e9..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_test_mem_slice_vector_impl.h
++++ /dev/null
+@@ -1,36 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "common/buffer/buffer_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/platform/quic_mem_slice_span_impl.h"
+-
+-namespace quic {
+-namespace test {
+-
+-class QuicTestMemSliceVectorImpl {
+-public:
+-  explicit QuicTestMemSliceVectorImpl(std::vector<std::pair<char*, size_t>> buffers) {
+-    for (auto it : buffers) {
+-      auto fragment = new Envoy::Buffer::BufferFragmentImpl(
+-          it.first, it.second,
+-          [](const void*, size_t, const Envoy::Buffer::BufferFragmentImpl* fragment) {
+-            delete fragment;
+-          });
+-      buffer_.addBufferFragment(*fragment);
+-    }
+-  }
+-
+-  QuicMemSliceSpanImpl span() { return QuicMemSliceSpanImpl(buffer_); }
+-
+-private:
+-  Envoy::Buffer::OwnedImpl buffer_;
+-};
+-
+-} // namespace test
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.cc b/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.cc
+deleted file mode 100644
+index fb4fb3c19d..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.cc
++++ /dev/null
+@@ -1,79 +0,0 @@
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.h"
+-
+-#include <cstdlib>
+-
+-#include "common/filesystem/filesystem_impl.h"
+-
+-#include "absl/time/clock.h"
+-#include "absl/time/time.h"
+-#include "fmt/printf.h"
+-#include "gtest/gtest.h"
+-#include "quiche/quic/platform/api/quic_logging.h"
+-
+-namespace quic {
+-namespace {
+-
+-void QuicRecordTestOutputToFile(const std::string& filename, QuicStringPiece data) {
+-  const char* output_dir_env = std::getenv("QUIC_TEST_OUTPUT_DIR");
+-  if (output_dir_env == nullptr) {
+-    QUIC_LOG(WARNING) << "Could not save test output since QUIC_TEST_OUTPUT_DIR is not set";
+-    return;
+-  }
+-
+-  std::string output_dir = output_dir_env;
+-  if (output_dir.empty()) {
+-    QUIC_LOG(WARNING) << "Could not save test output since QUIC_TEST_OUTPUT_DIR is empty";
+-    return;
+-  }
+-
+-  if (output_dir.back() != '/') {
+-    output_dir += '/';
+-  }
+-
+-  Envoy::Filesystem::InstanceImplPosix file_system;
+-  if (!file_system.directoryExists(output_dir)) {
+-    QUIC_LOG(ERROR) << "Directory does not exist while writing test output: " << output_dir;
+-    return;
+-  }
+-
+-  static constexpr Envoy::Filesystem::FlagSet DefaultFlags{
+-      1 << Envoy::Filesystem::File::Operation::Read |
+-      1 << Envoy::Filesystem::File::Operation::Write |
+-      1 << Envoy::Filesystem::File::Operation::Create |
+-      1 << Envoy::Filesystem::File::Operation::Append};
+-
+-  const std::string output_path = output_dir + filename;
+-  Envoy::Filesystem::FilePtr file = file_system.createFile(output_path);
+-  if (!file->open(DefaultFlags).rc_) {
+-    QUIC_LOG(ERROR) << "Failed to open test output file: " << output_path;
+-    return;
+-  }
+-
+-  if (file->write(data).rc_ != static_cast<ssize_t>(data.size())) {
+-    QUIC_LOG(ERROR) << "Failed to write to test output file: " << output_path;
+-  } else {
+-    QUIC_LOG(INFO) << "Recorded test output into " << output_path;
+-  }
+-
+-  file->close();
+-}
+-} // namespace
+-
+-void QuicRecordTestOutputImpl(QuicStringPiece identifier, QuicStringPiece data) {
+-  const testing::TestInfo* test_info = testing::UnitTest::GetInstance()->current_test_info();
+-
+-  std::string timestamp = absl::FormatTime("%Y%m%d%H%M%S", absl::Now(), absl::LocalTimeZone());
+-
+-  std::string filename = fmt::sprintf("%s.%s.%s.%s.qtr", test_info->name(),
+-                                      test_info->test_case_name(), identifier.data(), timestamp);
+-
+-  QuicRecordTestOutputToFile(filename, data);
+-}
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.h
+deleted file mode 100644
+index a611ad7af6..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_test_output_impl.h
++++ /dev/null
+@@ -1,15 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "quiche/quic/platform/api/quic_string_piece.h"
+-
+-namespace quic {
+-
+-void QuicRecordTestOutputImpl(QuicStringPiece identifier, QuicStringPiece data);
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quic_thread_impl.h b/test/extensions/quic_listeners/quiche/platform/quic_thread_impl.h
+deleted file mode 100644
+index e2d87917b1..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quic_thread_impl.h
++++ /dev/null
+@@ -1,72 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include <string>
+-
+-#include "envoy/thread/thread.h"
+-
+-#include "common/common/assert.h"
+-
+-#include "test/test_common/thread_factory_for_test.h"
+-
+-#include "absl/synchronization/notification.h"
+-
+-namespace quic {
+-
+-// A class representing a thread of execution in QUIC.
+-class QuicThreadImpl {
+-public:
+-  QuicThreadImpl(const std::string& /*name*/)
+-      : thread_factory_(Envoy::Thread::threadFactoryForTest()) {}
+-
+-  QuicThreadImpl(const QuicThreadImpl&) = delete;
+-  QuicThreadImpl& operator=(const QuicThreadImpl&) = delete;
+-
+-  virtual ~QuicThreadImpl() {
+-    if (thread_ != nullptr) {
+-      PANIC("QuicThread should be joined before destruction.");
+-    }
+-  }
+-
+-  void Start() {
+-    if (thread_ != nullptr || thread_is_set_.HasBeenNotified()) {
+-      PANIC("QuicThread can only be started once.");
+-    }
+-    thread_ = thread_factory_.createThread([this]() {
+-      thread_is_set_.WaitForNotification();
+-      this->Run();
+-    });
+-    thread_is_set_.Notify();
+-  }
+-
+-  void Join() {
+-    if (thread_ == nullptr) {
+-      PANIC("QuicThread has not been started.");
+-    }
+-    thread_->join();
+-    thread_ = nullptr;
+-  }
+-
+-protected:
+-  virtual void Run() {
+-    // We don't want this function to be pure virtual, because it will be called if:
+-    // 1. An object of a derived class calls Start(), which starts the child thread
+-    // but has not called Run() yet.
+-    // 2. The destructor of the derived class is called, but not the destructor
+-    // of this base class.
+-    // 3. The child thread calls QuicThreadImpl::Run()(this function), since the destructor of the
+-    // derived class has been called.
+-  }
+-
+-private:
+-  Envoy::Thread::ThreadPtr thread_;
+-  Envoy::Thread::ThreadFactory& thread_factory_;
+-  absl::Notification thread_is_set_; // Whether |thread_| is set in parent.
+-};
+-
+-} // namespace quic
+diff --git a/test/extensions/quic_listeners/quiche/platform/quiche_test_impl.h b/test/extensions/quic_listeners/quiche/platform/quiche_test_impl.h
+deleted file mode 100644
+index e351735c3a..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/quiche_test_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+diff --git a/test/extensions/quic_listeners/quiche/platform/spdy_platform_test.cc b/test/extensions/quic_listeners/quiche/platform/spdy_platform_test.cc
+deleted file mode 100644
+index d20c03ce65..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/spdy_platform_test.cc
++++ /dev/null
+@@ -1,135 +0,0 @@
+-#include <functional>
+-#include <string>
+-
+-#include "extensions/quic_listeners/quiche/platform/flags_impl.h"
+-
+-#include "test/test_common/logging.h"
+-
+-#include "gtest/gtest.h"
+-#include "quiche/spdy/platform/api/spdy_arraysize.h"
+-#include "quiche/spdy/platform/api/spdy_bug_tracker.h"
+-#include "quiche/spdy/platform/api/spdy_containers.h"
+-#include "quiche/spdy/platform/api/spdy_endianness_util.h"
+-#include "quiche/spdy/platform/api/spdy_estimate_memory_usage.h"
+-#include "quiche/spdy/platform/api/spdy_flags.h"
+-#include "quiche/spdy/platform/api/spdy_logging.h"
+-#include "quiche/spdy/platform/api/spdy_ptr_util.h"
+-#include "quiche/spdy/platform/api/spdy_string_piece.h"
+-#include "quiche/spdy/platform/api/spdy_test_helpers.h"
+-
+-// Basic tests to validate functioning of the QUICHE spdy platform
+-// implementation. For platform APIs in which the implementation is a simple
+-// typedef/passthrough to a std:: or absl:: construct, the tests are kept
+-// minimal, and serve primarily to verify the APIs compile and link without
+-// issue.
+-
+-namespace Envoy {
+-namespace Extensions {
+-namespace QuicListeners {
+-namespace Quiche {
+-namespace {
+-
+-TEST(SpdyPlatformTest, SpdyArraysize) {
+-  int array[] = {0, 1, 2, 3, 4};
+-  EXPECT_EQ(5, SPDY_ARRAYSIZE(array));
+-}
+-
+-TEST(SpdyPlatformTest, SpdyBugTracker) {
+-  EXPECT_DEBUG_DEATH(SPDY_BUG << "Here is a bug,", " bug");
+-  EXPECT_DEBUG_DEATH(SPDY_BUG_IF(true) << "There is a bug,", " bug");
+-  EXPECT_LOG_NOT_CONTAINS("error", "", SPDY_BUG_IF(false) << "A feature is not a bug.");
+-
+-  EXPECT_EQ(true, FLAGS_spdy_always_log_bugs_for_tests);
+-}
+-
+-TEST(SpdyPlatformTest, SpdyHashMap) {
+-  spdy::SpdyHashMap<std::string, int> hmap;
+-  hmap.insert({"foo", 2});
+-  EXPECT_EQ(2, hmap["foo"]);
+-}
+-
+-TEST(SpdyPlatformTest, SpdyHashSet) {
+-  spdy::SpdyHashSet<std::string, spdy::SpdyHash<std::string>, std::equal_to<std::string>> hset(
+-      {"foo", "bar"});
+-  EXPECT_EQ(1, hset.count("bar"));
+-  EXPECT_EQ(0, hset.count("qux"));
+-}
+-
+-TEST(SpdyPlatformTest, SpdyEndianness) {
+-  EXPECT_EQ(0x1234, spdy::SpdyNetToHost16(spdy::SpdyHostToNet16(0x1234)));
+-  EXPECT_EQ(0x12345678, spdy::SpdyNetToHost32(spdy::SpdyHostToNet32(0x12345678)));
+-}
+-
+-TEST(SpdyPlatformTest, SpdyEstimateMemoryUsage) {
+-  std::string s = "foo";
+-  // Stubbed out to always return 0.
+-  EXPECT_EQ(0, spdy::SpdyEstimateMemoryUsage(s));
+-}
+-
+-TEST(SpdyPlatformTest, SpdyLog) {
+-  // SPDY_LOG macros are defined to QUIC_LOG macros, which is tested in
+-  // QuicPlatformTest. Here we just make sure SPDY_LOG macros compile.
+-  SPDY_LOG(INFO) << "INFO log may not show up by default.";
+-  SPDY_LOG(ERROR) << "ERROR log should show up by default.";
+-
+-  // VLOG is only emitted if INFO is enabled and verbosity level is high enough.
+-  SPDY_VLOG(1) << "VLOG(1)";
+-
+-  SPDY_DLOG(INFO) << "DLOG(INFO)";
+-  SPDY_DLOG(ERROR) << "DLOG(ERROR)";
+-
+-  SPDY_DLOG_IF(ERROR, true) << "DLOG_IF(ERROR, true)";
+-  SPDY_DLOG_IF(ERROR, false) << "DLOG_IF(ERROR, false)";
+-
+-  SPDY_DVLOG(2) << "DVLOG(2)";
+-
+-  SPDY_DVLOG_IF(3, true) << "DVLOG_IF(3, true)";
+-  SPDY_DVLOG_IF(4, false) << "DVLOG_IF(4, false)";
+-}
+-
+-TEST(SpdyPlatformTest, SpdyWrapUnique) {
+-  auto p = spdy::SpdyWrapUnique(new int(6));
+-  EXPECT_EQ(6, *p);
+-}
+-
+-TEST(SpdyPlatformTest, SpdyString) {
+-  std::string s = "foo";
+-  EXPECT_EQ('o', s[1]);
+-}
+-
+-TEST(SpdyPlatformTest, SpdyStringPiece) {
+-  std::string s = "bar";
+-  spdy::SpdyStringPiece sp(s);
+-  EXPECT_EQ('b', sp[0]);
+-}
+-
+-TEST(SpdyPlatformTest, SpdyTestHelpers) {
+-  auto bug = [](const char* error_message) { SPDY_BUG << error_message; };
+-
+-  EXPECT_SPDY_BUG(bug("bug one is expected"), "bug one");
+-  EXPECT_SPDY_BUG(bug("bug two is expected"), "bug two");
+-}
+-
+-TEST(SpdyPlatformTest, SpdyFlags) {
+-  auto& flag_registry = quiche::FlagRegistry::GetInstance();
+-  flag_registry.ResetFlags();
+-  EXPECT_FALSE(GetSpdyReloadableFlag(spdy_testonly_default_false));
+-  EXPECT_FALSE(GetSpdyRestartFlag(spdy_testonly_default_false));
+-
+-  flag_registry.FindFlag("spdy_reloadable_flag_spdy_testonly_default_false")
+-      ->SetValueFromString("true");
+-  EXPECT_TRUE(GetSpdyReloadableFlag(spdy_testonly_default_false));
+-  EXPECT_FALSE(GetSpdyRestartFlag(spdy_testonly_default_false));
+-
+-  flag_registry.ResetFlags();
+-  flag_registry.FindFlag("spdy_restart_flag_spdy_testonly_default_false")
+-      ->SetValueFromString("yes");
+-  EXPECT_FALSE(GetSpdyReloadableFlag(spdy_testonly_default_false));
+-  EXPECT_TRUE(GetSpdyRestartFlag(spdy_testonly_default_false));
+-}
+-
+-} // namespace
+-} // namespace Quiche
+-} // namespace QuicListeners
+-} // namespace Extensions
+-} // namespace Envoy
+diff --git a/test/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h b/test/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
+deleted file mode 100644
+index 5ed27e1ffc..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/spdy_test_helpers_impl.h
++++ /dev/null
+@@ -1,11 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-//
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "test/extensions/quic_listeners/quiche/platform/quic_expect_bug_impl.h"
+-
+-#define EXPECT_SPDY_BUG_IMPL EXPECT_QUIC_BUG_IMPL
+diff --git a/test/extensions/quic_listeners/quiche/platform/spdy_test_impl.h b/test/extensions/quic_listeners/quiche/platform/spdy_test_impl.h
+deleted file mode 100644
+index e351735c3a..0000000000
+--- a/test/extensions/quic_listeners/quiche/platform/spdy_test_impl.h
++++ /dev/null
+@@ -1,10 +0,0 @@
+-#pragma once
+-
+-// NOLINT(namespace-envoy)
+-
+-// This file is part of the QUICHE platform implementation, and is not to be
+-// consumed or referenced directly by other Envoy code. It serves purely as a
+-// porting layer for QUICHE.
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+diff --git a/test/extensions/quic_listeners/quiche/quic_io_handle_wrapper_test.cc b/test/extensions/quic_listeners/quiche/quic_io_handle_wrapper_test.cc
+deleted file mode 100644
+index e72edcd45e..0000000000
+--- a/test/extensions/quic_listeners/quiche/quic_io_handle_wrapper_test.cc
++++ /dev/null
+@@ -1,88 +0,0 @@
+-#include <sys/socket.h>
+-
+-#include <memory>
+-
+-#include "common/network/address_impl.h"
+-
+-#include "extensions/quic_listeners/quiche/quic_io_handle_wrapper.h"
+-
+-#include "test/mocks/api/mocks.h"
+-#include "test/mocks/network/mocks.h"
+-#include "test/test_common/threadsafe_singleton_injector.h"
+-
+-#include "gmock/gmock.h"
+-#include "gtest/gtest.h"
+-
+-using testing::Return;
+-
+-namespace Envoy {
+-namespace Quic {
+-
+-class QuicIoHandleWrapperTest : public testing::Test {
+-public:
+-  QuicIoHandleWrapperTest() : wrapper_(std::make_unique<QuicIoHandleWrapper>(socket_.ioHandle())) {
+-    EXPECT_TRUE(wrapper_->isOpen());
+-    EXPECT_FALSE(socket_.ioHandle().isOpen());
+-  }
+-  ~QuicIoHandleWrapperTest() override = default;
+-
+-protected:
+-  testing::NiceMock<Network::MockListenSocket> socket_;
+-  std::unique_ptr<QuicIoHandleWrapper> wrapper_;
+-  testing::StrictMock<Envoy::Api::MockOsSysCalls> os_sys_calls_;
+-  TestThreadsafeSingletonInjector<Envoy::Api::OsSysCallsImpl> os_calls_{&os_sys_calls_};
+-};
+-
+-TEST_F(QuicIoHandleWrapperTest, Close) {
+-  EXPECT_TRUE(wrapper_->close().ok());
+-  EXPECT_FALSE(wrapper_->isOpen());
+-}
+-
+-TEST_F(QuicIoHandleWrapperTest, DelegateIoHandleCalls) {
+-  int fd = socket_.ioHandle().fd();
+-  char data[5];
+-  Buffer::RawSlice slice{data, 5};
+-  EXPECT_CALL(os_sys_calls_, readv(fd, _, 1)).WillOnce(Return(Api::SysCallSizeResult{5u, 0}));
+-  wrapper_->readv(5, &slice, 1);
+-
+-  EXPECT_CALL(os_sys_calls_, writev(fd, _, 1)).WillOnce(Return(Api::SysCallSizeResult{5u, 0}));
+-  wrapper_->writev(&slice, 1);
+-
+-  EXPECT_CALL(os_sys_calls_, socket(AF_INET6, SOCK_STREAM, 0))
+-      .WillRepeatedly(Return(Api::SysCallIntResult{1, 0}));
+-  EXPECT_CALL(os_sys_calls_, close(1)).WillRepeatedly(Return(Api::SysCallIntResult{0, 0}));
+-
+-  Network::Address::InstanceConstSharedPtr addr(new Network::Address::Ipv4Instance(12345));
+-  EXPECT_CALL(os_sys_calls_, sendto(fd, data, 5u, 0, _, _))
+-      .WillOnce(Return(Api::SysCallSizeResult{5u, 0}));
+-  wrapper_->sendto(slice, 0, *addr);
+-
+-  EXPECT_CALL(os_sys_calls_, sendmsg(fd, _, 0)).WillOnce(Return(Api::SysCallSizeResult{5u, 0}));
+-  wrapper_->sendmsg(&slice, 1, 0, /*self_ip=*/nullptr, *addr);
+-
+-  Network::IoHandle::RecvMsgOutput output(nullptr);
+-  EXPECT_CALL(os_sys_calls_, recvmsg(fd, _, 0)).WillOnce(Invoke([](int, struct msghdr* msg, int) {
+-    sockaddr_storage ss;
+-    auto ipv6_addr = reinterpret_cast<sockaddr_in6*>(&ss);
+-    memset(ipv6_addr, 0, sizeof(sockaddr_in6));
+-    ipv6_addr->sin6_family = AF_INET6;
+-    ipv6_addr->sin6_addr = in6addr_loopback;
+-    ipv6_addr->sin6_port = htons(54321);
+-    *reinterpret_cast<sockaddr_in6*>(msg->msg_name) = *ipv6_addr;
+-    msg->msg_namelen = sizeof(sockaddr_in6);
+-    return Api::SysCallSizeResult{5u, 0};
+-  }));
+-  wrapper_->recvmsg(&slice, 1, /*self_port=*/12345, output);
+-
+-  EXPECT_TRUE(wrapper_->close().ok());
+-
+-  // Following calls shouldn't be delegated.
+-  wrapper_->readv(5, &slice, 1);
+-  wrapper_->writev(&slice, 1);
+-  wrapper_->sendto(slice, 0, *addr);
+-  wrapper_->sendmsg(&slice, 1, 0, /*self_ip=*/nullptr, *addr);
+-  wrapper_->recvmsg(&slice, 1, /*self_port=*/12345, output);
+-}
+-
+-} // namespace Quic
+-} // namespace Envoy
+diff --git a/test/extensions/tracers/dynamic_ot/config_test.cc b/test/extensions/tracers/dynamic_ot/config_test.cc
+index 5c11d6172f..df518e9287 100644
+--- a/test/extensions/tracers/dynamic_ot/config_test.cc
++++ b/test/extensions/tracers/dynamic_ot/config_test.cc
+@@ -17,7 +17,11 @@ namespace Tracers {
+ namespace DynamicOt {
+ namespace {
+ 
+-TEST(DynamicOtTracerConfigTest, DynamicOpentracingHttpTracer) {
++// Disabled due to heapcheck reporting false positives when the test is statically linked with libstdc++
++// See https://github.com/envoyproxy/envoy/issues/7647 for the discussion
++// TODO (dmitri-d) there currently isn't a way to resolve this: some tests will fail when libstdc++ is
++// dynamically linked, this test fails when it's statically linked
++TEST(DynamicOtTracerConfigTest, DISABLED_DynamicOpentracingHttpTracer) {
+   NiceMock<Server::MockInstance> server;
+   EXPECT_CALL(server.cluster_manager_, get(Eq("fake_cluster")))
+       .WillRepeatedly(Return(&server.cluster_manager_.thread_local_cluster_));
+diff --git a/test/extensions/tracers/dynamic_ot/dynamic_opentracing_driver_impl_test.cc b/test/extensions/tracers/dynamic_ot/dynamic_opentracing_driver_impl_test.cc
+index 8600689167..9ca0b1030d 100644
+--- a/test/extensions/tracers/dynamic_ot/dynamic_opentracing_driver_impl_test.cc
++++ b/test/extensions/tracers/dynamic_ot/dynamic_opentracing_driver_impl_test.cc
+@@ -53,7 +53,11 @@ TEST_F(DynamicOpenTracingDriverTest, formatErrorMessage) {
+             DynamicOpenTracingDriver::formatErrorMessage(error_code, "abc"));
+ }
+ 
+-TEST_F(DynamicOpenTracingDriverTest, InitializeDriver) {
++// Disabled due to heapcheck reporting false positives when the test is statically linked with libstdc++
++// See https://github.com/envoyproxy/envoy/issues/7647 for the discussion
++// TODO (dmitri-d) there currently isn't a way to resolve this: some tests will fail when libstdc++ is
++// dynamically linked, this test fails when it's statically linked
++TEST_F(DynamicOpenTracingDriverTest, DISABLED_InitializeDriver) {
+   {
+     std::string invalid_library = "abc123";
+     std::string invalid_config = R"EOF(
+@@ -70,7 +74,11 @@ TEST_F(DynamicOpenTracingDriverTest, InitializeDriver) {
+   }
+ }
+ 
+-TEST_F(DynamicOpenTracingDriverTest, FlushSpans) {
++// Disabled due to failing with "JSON supplied is not valid" error when the test is statically linked with libstdc++
++// See https://github.com/envoyproxy/envoy/issues/7647 for the discussion
++// TODO (dmitri-d) there currently isn't a way to resolve this: some tests will fail when libstdc++ is
++// dynamically linked, this test fails when it's statically linked
++TEST_F(DynamicOpenTracingDriverTest, DISABLED_FlushSpans) {
+   setupValidDriver();
+ 
+   Tracing::SpanPtr first_span = driver_->startSpan(config_, request_headers_, operation_name_,
+diff --git a/test/extensions/transport_sockets/tls/BUILD b/test/extensions/transport_sockets/tls/BUILD
+index 94f93e62a6..17d4ec2d44 100644
+--- a/test/extensions/transport_sockets/tls/BUILD
++++ b/test/extensions/transport_sockets/tls/BUILD
+@@ -25,7 +25,6 @@ envoy_cc_test(
+     external_deps = ["ssl"],
+     shard_count = 4,
+     deps = [
+-        ":test_private_key_method_provider_test_lib",
+         "//include/envoy/network:transport_socket_interface",
+         "//source/common/buffer:buffer_lib",
+         "//source/common/common:empty_string",
+@@ -40,6 +39,7 @@ envoy_cc_test(
+         "//source/extensions/filters/listener/tls_inspector:tls_inspector_lib",
+         "//source/extensions/transport_sockets/tls:context_config_lib",
+         "//source/extensions/transport_sockets/tls:context_lib",
++        "//source/extensions/transport_sockets/tls:openssl_impl_lib",
+         "//source/extensions/transport_sockets/tls:ssl_socket_lib",
+         "//source/extensions/transport_sockets/tls:utility_lib",
+         "//source/extensions/transport_sockets/tls/private_key:private_key_manager_lib",
+@@ -94,7 +94,10 @@ envoy_cc_test(
+         "gen_unittest_certs.sh",
+         "//test/extensions/transport_sockets/tls/test_data:certs",
+     ],
+-    external_deps = ["ssl"],
++    external_deps = [
++        "ssl",
++        "bssl_wrapper_lib",
++    ],
+     deps = [
+         ":ssl_test_utils",
+         "//source/extensions/transport_sockets/tls:utility_lib",
+@@ -114,23 +117,3 @@ envoy_cc_test_library(
+         "//test/test_common:environment_lib",
+     ],
+ )
+-
+-envoy_cc_test_library(
+-    name = "test_private_key_method_provider_test_lib",
+-    srcs = [
+-        "test_private_key_method_provider.cc",
+-    ],
+-    hdrs = [
+-        "test_private_key_method_provider.h",
+-    ],
+-    external_deps = ["ssl"],
+-    deps = [
+-        "//include/envoy/api:api_interface",
+-        "//include/envoy/event:dispatcher_interface",
+-        "//include/envoy/server:transport_socket_config_interface",
+-        "//include/envoy/ssl/private_key:private_key_config_interface",
+-        "//include/envoy/ssl/private_key:private_key_interface",
+-        "//source/common/config:utility_lib",
+-        "//source/common/protobuf:utility_lib",
+-    ],
+-)
+diff --git a/test/extensions/transport_sockets/tls/context_impl_test.cc b/test/extensions/transport_sockets/tls/context_impl_test.cc
+index 3b6b596b5f..bff2cabb27 100644
+--- a/test/extensions/transport_sockets/tls/context_impl_test.cc
++++ b/test/extensions/transport_sockets/tls/context_impl_test.cc
+@@ -674,12 +674,7 @@ TEST_F(ClientContextConfigImplTest, RSA1024Cert) {
+   Stats::IsolatedStoreImpl store;
+   EXPECT_THROW_WITH_REGEX(
+       manager.createSslClientContext(store, client_context_config), EnvoyException,
+-      "Failed to load certificate chain from .*selfsigned_rsa_1024_cert.pem, only RSA certificates "
+-#ifdef BORINGSSL_FIPS
+-      "with 2048-bit or 3072-bit keys are supported in FIPS mode");
+-#else
+-      "with 2048-bit or larger keys are supported");
+-#endif
++      "Failed to load certificate chain from .*selfsigned_rsa_1024_cert.pem*");
+ }
+ 
+ // Validate that 3072-bit RSA certificates load successfully.
+@@ -716,14 +711,7 @@ TEST_F(ClientContextConfigImplTest, RSA4096Cert) {
+   Event::SimulatedTimeSystem time_system;
+   ContextManagerImpl manager(time_system);
+   Stats::IsolatedStoreImpl store;
+-#ifdef BORINGSSL_FIPS
+-  EXPECT_THROW_WITH_REGEX(
+-      manager.createSslClientContext(store, client_context_config), EnvoyException,
+-      "Failed to load certificate chain from .*selfsigned_rsa_4096_cert.pem, only RSA certificates "
+-      "with 2048-bit or 3072-bit keys are supported in FIPS mode");
+-#else
+   manager.createSslClientContext(store, client_context_config);
+-#endif
+ }
+ 
+ // Validate that P256 ECDSA certs load.
+@@ -1271,6 +1259,8 @@ TEST_F(ServerContextConfigImplTest, PrivateKeyMethodLoadFailureNoProvider) {
+       "Failed to load incomplete certificate from ");
+ }
+ 
++// TODO (dmitri-d) we do not support key providers under OpenSSL atm.
++/*
+ TEST_F(ServerContextConfigImplTest, PrivateKeyMethodLoadFailureNoMethod) {
+   envoy::api::v2::auth::DownstreamTlsContext tls_context;
+   tls_context.mutable_common_tls_context()->add_tls_certificates();
+@@ -1305,6 +1295,7 @@ TEST_F(ServerContextConfigImplTest, PrivateKeyMethodLoadFailureNoMethod) {
+           manager.createSslServerContext(store, server_context_config, std::vector<std::string>{})),
+       EnvoyException, "Failed to get BoringSSL private key method from provider");
+ }
++*/
+ 
+ TEST_F(ServerContextConfigImplTest, PrivateKeyMethodLoadSuccess) {
+   envoy::api::v2::auth::DownstreamTlsContext tls_context;
+diff --git a/test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc b/test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc
+index c3d0960dc0..ddf410761d 100644
+--- a/test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc
++++ b/test/extensions/transport_sockets/tls/integration/ssl_integration_test.cc
+@@ -54,8 +54,10 @@ SslIntegrationTestBase::makeSslClientConnection(const ClientSslTransportOptions&
+             " -showcerts -debug -msg -CAfile "
+             "{{ test_rundir }}/test/config/integration/certs/cacert.pem "
+             "-servername lyft.com -cert "
++            //"{{ test_rundir }}/test/config/integration/certs/client_ecdsacert.pem "
+             "{{ test_rundir }}/test/config/integration/certs/clientcert.pem "
+             "-key "
++            //"{{ test_rundir }}/test/config/integration/certs/client_ecdsakey.pem ",
+             "{{ test_rundir }}/test/config/integration/certs/clientkey.pem ",
+         version_);
+     ENVOY_LOG_MISC(debug, "Executing {}", s_client_cmd);
+diff --git a/test/extensions/transport_sockets/tls/ssl_socket_test.cc b/test/extensions/transport_sockets/tls/ssl_socket_test.cc
+index db7ff48d96..f12b90c70c 100644
+--- a/test/extensions/transport_sockets/tls/ssl_socket_test.cc
++++ b/test/extensions/transport_sockets/tls/ssl_socket_test.cc
+@@ -26,7 +26,6 @@
+ #include "test/extensions/transport_sockets/tls/test_data/san_dns_cert_info.h"
+ #include "test/extensions/transport_sockets/tls/test_data/san_uri_cert_info.h"
+ #include "test/extensions/transport_sockets/tls/test_data/selfsigned_ecdsa_p256_cert_info.h"
+-#include "test/extensions/transport_sockets/tls/test_private_key_method_provider.h"
+ #include "test/mocks/buffer/mocks.h"
+ #include "test/mocks/network/mocks.h"
+ #include "test/mocks/secret/mocks.h"
+@@ -254,6 +253,8 @@ void testUtil(const TestUtilOptions& options) {
+   ON_CALL(server_factory_context, api()).WillByDefault(ReturnRef(*server_api));
+ 
+   // For private key method testing.
++  // TODO (dmitri-d) This is currently not supported under openssl
++/*
+   NiceMock<Ssl::MockContextManager> context_manager;
+   Extensions::PrivateKeyMethodProvider::TestPrivateKeyMethodFactory test_factory;
+   Registry::InjectFactory<Ssl::PrivateKeyMethodProviderInstanceFactory>
+@@ -267,6 +268,7 @@ void testUtil(const TestUtilOptions& options) {
+         .WillOnce(ReturnRef(private_key_method_manager))
+         .WillRepeatedly(ReturnRef(private_key_method_manager));
+   }
++*/
+ 
+   envoy::api::v2::auth::DownstreamTlsContext server_tls_context;
+   TestUtility::loadFromYaml(TestEnvironment::substitute(options.serverCtxYaml()),
+@@ -584,8 +586,8 @@ const std::string testUtilV2(const TestUtilOptionsV2& options) {
+     SSL* client_ssl_socket = ssl_socket->rawSslForTest();
+     SSL_CTX* client_ssl_context = SSL_get_SSL_CTX(client_ssl_socket);
+     SSL_SESSION* client_ssl_session =
+-        SSL_SESSION_from_bytes(reinterpret_cast<const uint8_t*>(options.clientSession().data()),
+-                               options.clientSession().size(), client_ssl_context);
++            Envoy::Extensions::TransportSockets::Tls::ssl_session_from_bytes(
++                client_ssl_socket, client_ssl_context, options.clientSession());
+     int rc = SSL_set_session(client_ssl_socket, client_ssl_session);
+     ASSERT(rc == 1);
+     SSL_SESSION_free(client_ssl_session);
+@@ -628,10 +630,10 @@ const std::string testUtilV2(const TestUtilOptionsV2& options) {
+       }
+       if (!options.expectedCiphersuite().empty()) {
+         EXPECT_EQ(options.expectedCiphersuite(), client_connection->ssl()->ciphersuiteString());
+-        const SSL_CIPHER* cipher =
+-            SSL_get_cipher_by_value(client_connection->ssl()->ciphersuiteId());
+-        EXPECT_NE(nullptr, cipher);
+-        EXPECT_EQ(options.expectedCiphersuite(), SSL_CIPHER_get_name(cipher));
++//        const SSL_CIPHER* cipher =
++//            SSL_get_cipher_by_value(client_connection->ssl()->ciphersuiteId());
++//        EXPECT_NE(nullptr, cipher);
++//        EXPECT_EQ(options.expectedCiphersuite(), SSL_CIPHER_get_name(cipher));
+       }
+ 
+       absl::optional<std::string> server_ssl_requested_server_name;
+@@ -651,10 +653,10 @@ const std::string testUtilV2(const TestUtilOptionsV2& options) {
+       }
+ 
+       SSL_SESSION* client_ssl_session = SSL_get_session(client_ssl_socket);
+-      EXPECT_TRUE(SSL_SESSION_is_resumable(client_ssl_session));
++      EXPECT_TRUE(Envoy::Extensions::TransportSockets::Tls::ssl_session_is_resumable(client_ssl_session));
+       uint8_t* session_data;
+       size_t session_len;
+-      int rc = SSL_SESSION_to_bytes(client_ssl_session, &session_data, &session_len);
++      int rc = Envoy::Extensions::TransportSockets::Tls::ssl_session_to_bytes(client_ssl_session, &session_data, &session_len);
+       ASSERT(rc == 1);
+       new_session = std::string(reinterpret_cast<char*>(session_data), session_len);
+       OPENSSL_free(session_data);
+@@ -1299,7 +1301,7 @@ TEST_P(SslSocketTest, FailedClientCertificateDefaultExpirationVerification) {
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedClientCertUri("spiffe://lyft.com/test-team")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_EXPIRED"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate expired"));
+ }
+ 
+ // Expired certificates will not be accepted when explicitly disallowed via
+@@ -1318,7 +1320,7 @@ TEST_P(SslSocketTest, FailedClientCertificateExpirationVerification) {
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedClientCertUri("spiffe://lyft.com/test-team")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_EXPIRED"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate expired"));
+ }
+ 
+ // Expired certificates will be accepted when explicitly allowed via allow_expired_certificate.
+@@ -1359,7 +1361,7 @@ TEST_P(SslSocketTest, FailedClientCertAllowExpiredBadHashVerification) {
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_cert_hash")
+                  .setExpectedClientCertUri("spiffe://lyft.com/test-team")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_EXPIRED"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate expired"));
+ }
+ 
+ // Allow expired certificates, but use the wrong CA so it should fail still.
+@@ -1383,7 +1385,7 @@ TEST_P(SslSocketTest, FailedClientCertAllowServerExpiredWrongCAVerification) {
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedClientCertUri("spiffe://lyft.com/test-team")
+-                 .setExpectedTransportFailureReasonContains("TLSV1_ALERT_UNKNOWN_CA"));
++                 .setExpectedTransportFailureReasonContains("tlsv1 alert unknown ca"));
+ }
+ 
+ TEST_P(SslSocketTest, ClientCertificateHashVerification) {
+@@ -1768,7 +1770,7 @@ TEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoClientCertificate
+   envoy::api::v2::auth::UpstreamTlsContext client;
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_no_cert")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_HANDSHAKE_FAILURE"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert handshake failure"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -1795,7 +1797,7 @@ TEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCANoClientCertifi
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_no_cert")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_HANDSHAKE_FAILURE"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert handshake failure"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -1830,7 +1832,7 @@ TEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongClientCertific
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_cert_hash")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_UNKNOWN"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate unknown"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -1863,7 +1865,7 @@ TEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationNoCAWrongClientCert
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_cert_hash")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_UNKNOWN"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate unknown"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -1897,7 +1899,7 @@ TEST_P(SslSocketTest, FailedClientCertificateSpkiVerificationWrongCA) {
+       "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"));
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+-  testUtilV2(test_options.setExpectedTransportFailureReasonContains("TLSV1_ALERT_UNKNOWN_CA"));
++  testUtilV2(test_options.setExpectedTransportFailureReasonContains("tlsv1 alert unknown ca"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -1999,7 +2001,7 @@ TEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoClientCert
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_no_cert")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_HANDSHAKE_FAILURE"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert handshake failure"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -2027,7 +2029,7 @@ TEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCANoClient
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_no_cert")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_HANDSHAKE_FAILURE"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert handshake failure"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -2063,7 +2065,7 @@ TEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongClientC
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_cert_hash")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_UNKNOWN"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate unknown"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -2097,7 +2099,7 @@ TEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationNoCAWrongCli
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+   testUtilV2(test_options.setExpectedServerStats("ssl.fail_verify_cert_hash")
+-                 .setExpectedTransportFailureReasonContains("SSLV3_ALERT_CERTIFICATE_UNKNOWN"));
++                 .setExpectedTransportFailureReasonContains("sslv3 alert certificate unknown"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -2132,7 +2134,7 @@ TEST_P(SslSocketTest, FailedClientCertificateHashAndSpkiVerificationWrongCA) {
+       "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"));
+ 
+   TestUtilOptionsV2 test_options(listener, client, false, GetParam());
+-  testUtilV2(test_options.setExpectedTransportFailureReasonContains("TLSV1_ALERT_UNKNOWN_CA"));
++  testUtilV2(test_options.setExpectedTransportFailureReasonContains("tlsv1 alert unknown ca"));
+ 
+   // Fails even with client renegotiation.
+   client.set_allow_renegotiation(true);
+@@ -2860,7 +2862,8 @@ TEST_P(SslSocketTest, ClientAuthCrossListenerSessionResumption) {
+         const SslSocketInfo* ssl_socket =
+             dynamic_cast<const SslSocketInfo*>(client_connection->ssl().get());
+         ssl_session = SSL_get1_session(ssl_socket->rawSslForTest());
+-        EXPECT_TRUE(SSL_SESSION_is_resumable(ssl_session));
++        EXPECT_TRUE(
++            Envoy::Extensions::TransportSockets::Tls::ssl_session_is_resumable(ssl_session));
+         server_connection->close(Network::ConnectionCloseType::NoFlush);
+         client_connection->close(Network::ConnectionCloseType::NoFlush);
+         dispatcher_->exit();
+@@ -3286,23 +3289,18 @@ TEST_P(SslSocketTest, ProtocolVersions) {
+       createProtocolTestOptions(listener, client, GetParam(), "TLSv1.3");
+   TestUtilOptionsV2 error_test_options(listener, client, false, GetParam());
+   error_test_options.setExpectedServerStats("ssl.connection_error")
+-      .setExpectedTransportFailureReasonContains("TLSV1_ALERT_PROTOCOL_VERSION");
+-#ifndef BORINGSSL_FIPS
++      .setExpectedTransportFailureReasonContains("tlsv1 alert protocol version");
++
+   testUtilV2(tls_v1_3_test_options);
+-#else // BoringSSL FIPS
+-  testUtilV2(error_test_options);
+-#endif
++
+   client_params->clear_tls_minimum_protocol_version();
+   client_params->clear_tls_maximum_protocol_version();
+ 
+   // Connection using TLSv1.0-1.3 (client) and defaults (server) succeeds.
+   client_params->set_tls_minimum_protocol_version(envoy::api::v2::auth::TlsParameters::TLSv1_0);
+   client_params->set_tls_maximum_protocol_version(envoy::api::v2::auth::TlsParameters::TLSv1_3);
+-#ifndef BORINGSSL_FIPS
+   testUtilV2(tls_v1_3_test_options);
+-#else // BoringSSL FIPS
+-  testUtilV2(tls_v1_2_test_options);
+-#endif
++
+   client_params->clear_tls_minimum_protocol_version();
+   client_params->clear_tls_maximum_protocol_version();
+ 
+@@ -3500,15 +3498,12 @@ TEST_P(SslSocketTest, CipherSuites) {
+ 
+   // Verify that ECDHE-RSA-CHACHA20-POLY1305 is not offered by default in FIPS builds.
+   client_params->add_cipher_suites(common_cipher_suite);
+-#ifdef BORINGSSL_FIPS
+-  testUtilV2(error_test_options);
+-#else
+   testUtilV2(cipher_test_options);
+-#endif
+   client_params->clear_cipher_suites();
+ }
+ 
+ TEST_P(SslSocketTest, EcdhCurves) {
++  std::cout << "********************* EcdhCurves \n";
+   envoy::api::v2::Listener listener;
+   envoy::api::v2::listener::FilterChain* filter_chain = listener.add_filter_chains();
+   envoy::api::v2::auth::TlsCertificate* server_cert =
+@@ -3540,7 +3535,7 @@ TEST_P(SslSocketTest, EcdhCurves) {
+   server_params->add_cipher_suites("ECDHE-RSA-AES128-GCM-SHA256");
+   TestUtilOptionsV2 ecdh_curves_test_options(listener, client, true, GetParam());
+   std::string stats = "ssl.curves.X25519";
+-  ecdh_curves_test_options.setExpectedServerStats(stats).setExpectedClientStats(stats);
++  ecdh_curves_test_options.setExpectedServerStats(stats); //.setExpectedClientStats(stats);
+   testUtilV2(ecdh_curves_test_options);
+   client_params->clear_ecdh_curves();
+   server_params->clear_ecdh_curves();
+@@ -3562,11 +3557,7 @@ TEST_P(SslSocketTest, EcdhCurves) {
+   // Verify that X25519 is not offered by default in FIPS builds.
+   client_params->add_ecdh_curves("X25519");
+   server_params->add_cipher_suites("ECDHE-RSA-AES128-GCM-SHA256");
+-#ifdef BORINGSSL_FIPS
+-  testUtilV2(error_test_options);
+-#else
+   testUtilV2(ecdh_curves_test_options);
+-#endif
+   client_params->clear_ecdh_curves();
+   server_params->clear_cipher_suites();
+ }
+@@ -4158,6 +4149,7 @@ TEST_P(SslReadBufferLimitTest, SmallReadsIntoSameSlice) {
+ }
+ 
+ // Test asynchronous signing (ECDHE) using a private key provider.
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignSuccess) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4188,8 +4180,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignSuccess) {
+                                           GetParam());
+   testUtil(successful_test_options.setPrivateKeyMethodExpected(true));
+ }
++*/
+ 
+ // Test asynchronous decryption (RSA).
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptSuccess) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4220,8 +4214,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptSuccess) {
+                                           GetParam());
+   testUtil(successful_test_options.setPrivateKeyMethodExpected(true));
+ }
++*/
+ 
+ // Test synchronous signing (ECDHE).
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignSuccess) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4252,8 +4248,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignSuccess) {
+                                           GetParam());
+   testUtil(successful_test_options.setPrivateKeyMethodExpected(true));
+ }
++*/
+ 
+ // Test synchronous decryption (RSA).
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncDecryptSuccess) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4284,8 +4282,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncDecryptSuccess) {
+                                           GetParam());
+   testUtil(successful_test_options.setPrivateKeyMethodExpected(true));
+ }
++*/
+ 
+ // Test asynchronous signing (ECDHE) failure (invalid signature).
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4317,8 +4317,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignFailure) {
+   testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(
+       "ssl.connection_error"));
+ }
++*/
+ 
+ // Test synchronous signing (ECDHE) failure (invalid signature).
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4350,8 +4352,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderSyncSignFailure) {
+   testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(
+       "ssl.connection_error"));
+ }
++*/
+ 
+ // Test the sign operation return with an error.
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderSignFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4382,8 +4386,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderSignFailure) {
+   testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(
+       "ssl.connection_error"));
+ }
++*/
+ 
+ // Test the decrypt operation return with an error.
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderDecryptFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4414,8 +4420,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderDecryptFailure) {
+   testUtil(failing_test_options.setPrivateKeyMethodExpected(true).setExpectedServerStats(
+       "ssl.connection_error"));
+ }
++*/
+ 
+ // Test the sign operation return with an error in complete.
++/*
+ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignCompleteFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+@@ -4447,9 +4455,10 @@ TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncSignCompleteFailure) {
+                .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)
+                .setExpectedServerStats("ssl.connection_error"));
+ }
++*/
+ 
+ // Test the decrypt operation return with an error in complete.
+-TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptCompleteFailure) {
++/*TEST_P(SslSocketTest, RsaPrivateKeyProviderAsyncDecryptCompleteFailure) {
+   const std::string server_ctx_yaml = R"EOF(
+   common_tls_context:
+     tls_certificates:
+@@ -4674,7 +4683,7 @@ TEST_P(SslSocketTest, RsaAndEcdsaPrivateKeyProviderMultiCertFail) {
+   testUtil(failing_test_options.setPrivateKeyMethodExpected(true)
+                .setExpectedServerCloseEvent(Network::ConnectionEvent::LocalClose)
+                .setExpectedServerStats("ssl.connection_error"));
+-}
++}*/
+ 
+ } // namespace Tls
+ } // namespace TransportSockets
+diff --git a/test/extensions/transport_sockets/tls/ssl_test_utility.h b/test/extensions/transport_sockets/tls/ssl_test_utility.h
+index 7fa071c800..5345659405 100644
+--- a/test/extensions/transport_sockets/tls/ssl_test_utility.h
++++ b/test/extensions/transport_sockets/tls/ssl_test_utility.h
+@@ -5,6 +5,7 @@
+ 
+ #include "test/test_common/environment.h"
+ 
++#include "bssl_wrapper/bssl_wrapper.h"
+ #include "gtest/gtest.h"
+ #include "openssl/ssl.h"
+ #include "openssl/x509v3.h"
+diff --git a/test/extensions/transport_sockets/tls/utility_test.cc b/test/extensions/transport_sockets/tls/utility_test.cc
+index ccf803faa0..c8eb87a19c 100644
+--- a/test/extensions/transport_sockets/tls/utility_test.cc
++++ b/test/extensions/transport_sockets/tls/utility_test.cc
+@@ -22,7 +22,7 @@ namespace {
+ TEST(UtilityTest, TestGetSubjectAlternateNamesWithDNS) {
+   bssl::UniquePtr<X509> cert = readCertFromFile(TestEnvironment::substitute(
+       "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_dns_cert.pem"));
+-  const auto& subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_DNS);
++  const std::vector<std::string> &subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_DNS);
+   EXPECT_EQ(1, subject_alt_names.size());
+ }
+ 
+@@ -30,21 +30,22 @@ TEST(UtilityTest, TestMultipleGetSubjectAlternateNamesWithDNS) {
+   bssl::UniquePtr<X509> cert = readCertFromFile(TestEnvironment::substitute(
+       "{{ test_rundir "
+       "}}/test/extensions/transport_sockets/tls/test_data/san_multiple_dns_cert.pem"));
+-  const auto& subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_DNS);
++  const std::vector<std::string> &subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_DNS);
+   EXPECT_EQ(2, subject_alt_names.size());
+ }
+ 
+ TEST(UtilityTest, TestGetSubjectAlternateNamesWithUri) {
+   bssl::UniquePtr<X509> cert = readCertFromFile(TestEnvironment::substitute(
+       "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"));
+-  const auto& subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_URI);
++  const std::vector<std::string> &subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_URI);
+   EXPECT_EQ(1, subject_alt_names.size());
+ }
+ 
+ TEST(UtilityTest, TestGetSubjectAlternateNamesWithNoSAN) {
+   bssl::UniquePtr<X509> cert = readCertFromFile(TestEnvironment::substitute(
+       "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/no_san_cert.pem"));
+-  const auto& uri_subject_alt_names = Utility::getSubjectAltNames(*cert, GEN_URI);
++  const std::vector<std::string> &uri_subject_alt_names =
++      Utility::getSubjectAltNames(*cert, GEN_URI);
+   EXPECT_EQ(0, uri_subject_alt_names.size());
+ }
+ 
+diff --git a/test/integration/integration_test.cc b/test/integration/integration_test.cc
+index 91f38de551..97a1dbbad3 100644
+--- a/test/integration/integration_test.cc
++++ b/test/integration/integration_test.cc
+@@ -219,6 +219,31 @@ TEST_P(IntegrationTest, RouterUpstreamDisconnectBeforeResponseComplete) {
+   testRouterUpstreamDisconnectBeforeResponseComplete();
+ }
+ 
++// Regression test for https://github.com/envoyproxy/envoy/issues/9508
++TEST_P(IntegrationTest, ResponseFramedByConnectionCloseWithReadLimits) {
++  // Set a small buffer limit on the downstream in order to trigger a call to trigger readDisable on
++  // the upstream when proxying the response. Upstream limit needs to be larger so that
++  // RawBufferSocket::doRead reads the response body and detects the upstream close in the same call
++  // stack.
++  config_helper_.setBufferLimits(100000, 1);
++  initialize();
++
++  codec_client_ = makeHttpConnection(makeClientConnection((lookupPort("http"))));
++  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);
++
++  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
++  waitForNextUpstreamRequest();
++  // Disable chunk encoding to trigger framing by connection close.
++  upstream_request_->encodeHeaders(Http::TestHeaderMapImpl{{":status", "200"}, {":no-chunks", "1"}},
++    false);
++  upstream_request_->encodeData(512, true);
++  ASSERT_TRUE(fake_upstream_connection_->close());
++
++  response->waitForEndStream();
++
++  EXPECT_TRUE(response->complete());
++}
++
+ TEST_P(IntegrationTest, RouterDownstreamDisconnectBeforeRequestComplete) {
+   testRouterDownstreamDisconnectBeforeRequestComplete();
+ }
+diff --git a/test/integration/protocol_integration_test.cc b/test/integration/protocol_integration_test.cc
+index c306bdbb48..8738dae0f7 100644
+--- a/test/integration/protocol_integration_test.cc
++++ b/test/integration/protocol_integration_test.cc
+@@ -387,7 +387,6 @@ TEST_P(DownstreamProtocolIntegrationTest, RetryPriority) {
+   EXPECT_EQ(512U, response->body().size());
+ }
+ 
+-//
+ // Verifies that a retry host filter can be configured and affect the host selected during retries.
+ // The predicate will keep track of the first host attempted, and attempt to route all requests to
+ // the same host. With a total of two upstream hosts, this should result in us continuously sending
+diff --git a/test/mocks/ssl/mocks.h b/test/mocks/ssl/mocks.h
+index 295d2f5734..3102d37492 100644
+--- a/test/mocks/ssl/mocks.h
++++ b/test/mocks/ssl/mocks.h
+@@ -129,7 +129,10 @@ public:
+                void(SSL* ssl, PrivateKeyConnectionCallbacks& cb, Event::Dispatcher& dispatcher));
+   MOCK_METHOD1(unregisterPrivateKeyMethod, void(SSL* ssl));
+   MOCK_METHOD0(checkFips, bool());
+-  MOCK_METHOD0(getBoringSslPrivateKeyMethod, BoringSslPrivateKeyMethodSharedPtr());
++
++#ifdef OPENSSL_IS_BORINGSSL
++//  MOCK_METHOD0(getBoringSslPrivateKeyMethod, BoringSslPrivateKeyMethodSharedPtr());
++#endif
+ };
+ 
+ } // namespace Ssl
+diff --git a/test/server/BUILD b/test/server/BUILD
+index cbb9984921..c3b4c0996d 100644
+--- a/test/server/BUILD
++++ b/test/server/BUILD
+@@ -208,21 +208,6 @@ envoy_cc_test(
+     ],
+ )
+ 
+-# Stand-alone quic test because of FIPS.
+-envoy_cc_test(
+-    name = "listener_manager_impl_quic_only_test",
+-    srcs = ["listener_manager_impl_quic_only_test.cc"],
+-    tags = ["nofips"],
+-    deps = [
+-        ":listener_manager_impl_test_lib",
+-        ":utility_lib",
+-        "//source/extensions/quic_listeners/quiche:active_quic_listener_config_lib",
+-        "//source/extensions/quic_listeners/quiche:quic_transport_socket_factory_lib",
+-        "//source/extensions/transport_sockets/raw_buffer:config",
+-        "//test/test_common:threadsafe_singleton_injector_lib",
+-    ],
+-)
+-
+ envoy_cc_test(
+     name = "filter_chain_manager_impl_test",
+     srcs = ["filter_chain_manager_impl_test.cc"],
+diff --git a/test/server/listener_manager_impl_quic_only_test.cc b/test/server/listener_manager_impl_quic_only_test.cc
+deleted file mode 100644
+index 64c9019aa3..0000000000
+--- a/test/server/listener_manager_impl_quic_only_test.cc
++++ /dev/null
+@@ -1,82 +0,0 @@
+-#include "extensions/quic_listeners/quiche/quic_transport_socket_factory.h"
+-
+-#include "test/server/listener_manager_impl_test.h"
+-#include "test/server/utility.h"
+-#include "test/test_common/threadsafe_singleton_injector.h"
+-
+-namespace Envoy {
+-namespace Server {
+-namespace {
+-
+-class ListenerManagerImplQuicOnlyTest : public ListenerManagerImplTest {};
+-
+-TEST_F(ListenerManagerImplQuicOnlyTest, QuicListenerFactoryAndSslContext) {
+-  const std::string yaml = TestEnvironment::substitute(R"EOF(
+-address:
+-  socket_address:
+-    address: 127.0.0.1
+-    protocol: UDP
+-    port_value: 1234
+-filter_chains:
+-- filter_chain_match:
+-    transport_protocol: "quic"
+-  filters: []
+-  transport_socket:
+-    name: envoy.transport_sockets.quic
+-    config:
+-      common_tls_context:
+-        tls_certificates:
+-        - certificate_chain:
+-            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem"
+-          private_key:
+-            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem"
+-        validation_context:
+-          trusted_ca:
+-            filename: "{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem"
+-          verify_subject_alt_name:
+-          - localhost
+-          - 127.0.0.1
+-udp_listener_config:
+-  udp_listener_name: "quiche_quic_listener"
+-  )EOF",
+-                                                       Network::Address::IpVersion::v4);
+-
+-  envoy::api::v2::Listener listener_proto = parseListenerFromV2Yaml(yaml);
+-  EXPECT_CALL(server_.random_, uuid());
+-  expectCreateListenSocket(envoy::api::v2::core::SocketOption::STATE_PREBIND,
+-#ifdef SO_RXQ_OVFL
+-                           /* expected_num_options */ 2);
+-#else
+-                           /* expected_num_options */ 1);
+-#endif
+-  expectSetsockopt(os_sys_calls_,
+-                   /* expected_sockopt_level */ IPPROTO_IP,
+-                   /* expected_sockopt_name */ ENVOY_IP_PKTINFO,
+-                   /* expected_value */ 1,
+-                   /* expected_num_calls */ 1);
+-#ifdef SO_RXQ_OVFL
+-  expectSetsockopt(os_sys_calls_,
+-                   /* expected_sockopt_level */ SOL_SOCKET,
+-                   /* expected_sockopt_name */ SO_RXQ_OVFL,
+-                   /* expected_value */ 1,
+-                   /* expected_num_calls */ 1);
+-#endif
+-
+-  manager_->addOrUpdateListener(listener_proto, "", true);
+-  EXPECT_EQ(1u, manager_->listeners().size());
+-  EXPECT_FALSE(manager_->listeners()[0].get().udpListenerFactory()->isTransportConnectionless());
+-
+-  // No filter chain found with non-matching transport protocol.
+-  EXPECT_EQ(nullptr, findFilterChain(1234, "127.0.0.1", "", "tls", {}, "8.8.8.8", 111));
+-
+-  auto filter_chain = findFilterChain(1234, "127.0.0.1", "", "quic", {}, "8.8.8.8", 111);
+-  ASSERT_NE(nullptr, filter_chain);
+-  auto& quic_socket_factory = dynamic_cast<const Quic::QuicServerTransportSocketFactory&>(
+-      filter_chain->transportSocketFactory());
+-  EXPECT_TRUE(quic_socket_factory.implementsSecureTransport());
+-  EXPECT_TRUE(quic_socket_factory.serverContextConfig().isReady());
+-}
+-
+-} // namespace
+-} // namespace Server
+-} // namespace Envoy
+diff --git a/test/test_common/utility.h b/test/test_common/utility.h
+index c5dcc4c2e7..b84bdab195 100644
+--- a/test/test_common/utility.h
++++ b/test/test_common/utility.h
+@@ -444,7 +444,7 @@ public:
+   static std::string convertTime(const std::string& input, const std::string& input_format,
+                                  const std::string& output_format);
+ 
+-  static constexpr std::chrono::milliseconds DefaultTimeout = std::chrono::milliseconds(30000);
++  static constexpr std::chrono::milliseconds DefaultTimeout = std::chrono::milliseconds(10000);
+ 
+   static void renameFile(const std::string& old_name, const std::string& new_name);
+   static void createDirectory(const std::string& name);
+-- 
+2.24.1
+
diff --git a/WORKSPACE b/WORKSPACE
index 87b9675a..8a1de146 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -20,7 +20,6 @@ workspace(name = "io_istio_proxy")
 load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
 load(
     "//:repositories.bzl",
-    "docker_dependencies",
     "googletest_repositories",
     "mixerapi_dependencies",
 )
@@ -29,9 +28,10 @@ googletest_repositories()
 
 mixerapi_dependencies()
 
-bind(
-    name = "boringssl_crypto",
-    actual = "//external:ssl",
+new_local_repository(
+    name = "openssl",
+    path = "/usr/lib64/",
+    build_file = "openssl.BUILD"
 )
 
 # 1. Determine SHA256 `wget https://github.com/istio/envoy/archive/$COMMIT.tar.gz && sha256sum $COMMIT.tar.gz`
@@ -39,7 +39,7 @@ bind(
 #
 # envoy commit date: 02/20/2020
 ENVOY_SHA = "524ab4cfd64ad6c9b9fb24f1ff0f79cabcc7d0ed"
-
+ 
 ENVOY_SHA256 = "3eee859088cd759c6339ca1a2fe831bc7201c0d69bad489f1b5583f011f5b851"
 
 # To override with local envoy, just pass `--override_repository=envoy=/PATH/TO/ENVOY` to Bazel or
@@ -49,6 +49,10 @@ http_archive(
     sha256 = ENVOY_SHA256,
     strip_prefix = "envoy-" + ENVOY_SHA,
     url = "https://github.com/istio/envoy/archive/" + ENVOY_SHA + ".tar.gz",
+    patches = [
+        "@//:0001-Changes-and-fixes-to-support-OpenSSL.patch",
+    ],
+    patch_args = ["-p1"],
 )
 
 load("@envoy//bazel:api_binding.bzl", "envoy_api_binding")
@@ -66,42 +70,3 @@ envoy_dependencies()
 load("@envoy//bazel:dependency_imports.bzl", "envoy_dependency_imports")
 
 envoy_dependency_imports()
-
-# Docker dependencies
-
-docker_dependencies()
-
-load(
-    "@io_bazel_rules_docker//repositories:repositories.bzl",
-    container_repositories = "repositories",
-)
-
-container_repositories()
-
-load("@io_bazel_rules_docker//repositories:deps.bzl", container_deps = "deps")
-
-container_deps()
-
-load(
-    "@io_bazel_rules_docker//container:container.bzl",
-    "container_pull",
-)
-
-container_pull(
-    name = "distroless_cc",
-    # Latest as of 10/21/2019. To update, remove this line, re-build, and copy the suggested digest.
-    digest = "sha256:86f16733f25964c40dcd34edf14339ddbb2287af2f7c9dfad88f0366723c00d7",
-    registry = "gcr.io",
-    repository = "distroless/cc",
-)
-
-container_pull(
-    name = "bionic",
-    # Latest as of 10/21/2019. To update, remove this line, re-build, and copy the suggested digest.
-    digest = "sha256:3e83eca7870ee14a03b8026660e71ba761e6919b6982fb920d10254688a363d4",
-    registry = "index.docker.io",
-    repository = "library/ubuntu",
-    tag = "bionic",
-)
-
-# End of docker dependencies
diff --git a/extensions/stats/plugin_test.cc b/extensions/stats/plugin_test.cc
index 05096c94..93ff3182 100644
--- a/extensions/stats/plugin_test.cc
+++ b/extensions/stats/plugin_test.cc
@@ -45,18 +45,18 @@ TEST(IstioDimensions, Hash) {
   IstioDimensions d2{.request_protocol = "grpc"};
   IstioDimensions d3{.request_protocol = "grpc", .response_code = "200"};
   IstioDimensions d4{.request_protocol = "grpc", .response_code = "400"};
-  IstioDimensions d5{.request_protocol = "grpc", .source_app = "app_source"};
-  IstioDimensions d6{.request_protocol = "grpc",
-                     .source_app = "app_source",
-                     .source_version = "v2"};
-  IstioDimensions d7{.outbound = true,
+  IstioDimensions d5{.source_app = "app_source", .request_protocol = "grpc"};
+  IstioDimensions d6{.source_app = "app_source",
+	             .source_version = "v2", 
+	             .request_protocol = "grpc"};
+  IstioDimensions d7{.source_app = "app_source", 
+                     .source_version = "v2",
                      .request_protocol = "grpc",
-                     .source_app = "app_source",
-                     .source_version = "v2"};
-  IstioDimensions d8{.outbound = true,
+                     .outbound = true};
+  IstioDimensions d8{.source_app = "app_source", 
+                     .source_version = "v2",
                      .request_protocol = "grpc",
-                     .source_app = "app_source",
-                     .source_version = "v2"};
+                     .outbound = true};
   // Must be unique except for d7 and d8.
   std::set<size_t> hashes;
   hashes.insert(IstioDimensions::HashIstioDimensions()(d1));
diff --git a/openssl.BUILD b/openssl.BUILD
new file mode 100644
index 00000000..0cc6e938
--- /dev/null
+++ b/openssl.BUILD
@@ -0,0 +1,11 @@
+licenses(["notice"])  # Apache 2
+
+cc_library(
+    name = "openssl-lib",
+    srcs = [
+        "libssl.so.1.1",
+        "libcrypto.so.1.1",
+    ],
+    visibility = ["//visibility:public"],
+    linkstatic=False,
+)
diff --git a/repositories.bzl b/repositories.bzl
index 6e53428b..b84aee4b 100644
--- a/repositories.bzl
+++ b/repositories.bzl
@@ -354,10 +354,3 @@ def mixerapi_dependencies():
     go_x_tools_imports_repositories()
     mixerapi_repositories()
 
-def docker_dependencies():
-    http_archive(
-        name = "io_bazel_rules_docker",
-        sha256 = "413bb1ec0895a8d3249a01edf24b82fd06af3c8633c9fb833a0cb1d4b234d46d",
-        strip_prefix = "rules_docker-0.12.0",
-        urls = ["https://github.com/bazelbuild/rules_docker/releases/download/v0.12.0/rules_docker-v0.12.0.tar.gz"],
-    )
diff --git a/src/envoy/http/jwt_auth/jwt.cc b/src/envoy/http/jwt_auth/jwt.cc
index 0dec1668..8761f9ba 100644
--- a/src/envoy/http/jwt_auth/jwt.cc
+++ b/src/envoy/http/jwt_auth/jwt.cc
@@ -163,12 +163,17 @@ class EvpPkeyGetter : public WithStatus {
       UpdateStatus(Status::PEM_PUBKEY_BAD_BASE64);
       return nullptr;
     }
-    auto rsa = bssl::UniquePtr<RSA>(
-        RSA_public_key_from_bytes(CastToUChar(pkey_der), pkey_der.length()));
+    RSA* rsa(RSA_new());
+    const unsigned char *pp = (const unsigned char *)pkey_der.c_str();
+    d2i_RSAPublicKey(&rsa, &pp, pkey_der.length());
     if (!rsa) {
       UpdateStatus(Status::PEM_PUBKEY_PARSE_ERROR);
     }
-    return EvpPkeyFromRsa(rsa.get());
+    bssl::UniquePtr<EVP_PKEY> result = EvpPkeyFromRsa(rsa);
+
+    RSA_free(rsa);
+
+    return result;
   }
 
   bssl::UniquePtr<EVP_PKEY> EvpPkeyFromJwkRSA(const std::string &n,
@@ -184,19 +189,26 @@ class EvpPkeyGetter : public WithStatus {
       UpdateStatus(Status::FAILED_CREATE_EC_KEY);
       return nullptr;
     }
-    bssl::UniquePtr<BIGNUM> bn_x = BigNumFromBase64UrlString(x);
-    bssl::UniquePtr<BIGNUM> bn_y = BigNumFromBase64UrlString(y);
+    BIGNUM* bn_x = BigNumFromBase64UrlString(x);
+    BIGNUM* bn_y = BigNumFromBase64UrlString(y);
     if (!bn_x || !bn_y) {
       // EC public key field is missing or has parse error.
       UpdateStatus(Status::JWK_EC_PUBKEY_PARSE_ERROR);
       return nullptr;
     }
 
-    if (EC_KEY_set_public_key_affine_coordinates(ec_key.get(), bn_x.get(),
-                                                 bn_y.get()) == 0) {
+    if (EC_KEY_set_public_key_affine_coordinates(ec_key.get(), bn_x,
+                                                 bn_y) == 0) {
+      BN_free(bn_x);
+      BN_free(bn_y);
+
       UpdateStatus(Status::JWK_EC_PUBKEY_PARSE_ERROR);
       return nullptr;
     }
+
+    BN_free(bn_x);
+    BN_free(bn_y);
+
     return ec_key;
   }
 
@@ -212,13 +224,12 @@ class EvpPkeyGetter : public WithStatus {
     return key;
   }
 
-  bssl::UniquePtr<BIGNUM> BigNumFromBase64UrlString(const std::string &s) {
+  BIGNUM* BigNumFromBase64UrlString(const std::string &s) {
     std::string s_decoded = Base64UrlDecode(s);
     if (s_decoded == "") {
       return nullptr;
     }
-    return bssl::UniquePtr<BIGNUM>(
-        BN_bin2bn(CastToUChar(s_decoded), s_decoded.length(), NULL));
+    return BN_bin2bn(CastToUChar(s_decoded), s_decoded.length(), NULL);
   };
 
   bssl::UniquePtr<RSA> RsaFromJwk(const std::string &n, const std::string &e) {
@@ -226,13 +237,15 @@ class EvpPkeyGetter : public WithStatus {
     // It crash if RSA object couldn't be created.
     assert(rsa);
 
-    rsa->n = BigNumFromBase64UrlString(n).release();
-    rsa->e = BigNumFromBase64UrlString(e).release();
-    if (!rsa->n || !rsa->e) {
+    BIGNUM* rsa_n = BigNumFromBase64UrlString(n);
+    BIGNUM* rsa_e = BigNumFromBase64UrlString(e);
+if (!rsa_n || !rsa_e) {
       // RSA public key field is missing or has parse error.
       UpdateStatus(Status::JWK_RSA_PUBKEY_PARSE_ERROR);
       return nullptr;
     }
+    int result = RSA_set0_key(rsa.get(), rsa_n, rsa_e, nullptr);
+
     return rsa;
   }
 };
@@ -368,8 +381,12 @@ bool Verifier::VerifySignatureEC(EC_KEY *key, const uint8_t *signature,
     return false;
   }
 
-  BN_bin2bn(signature, 32, ecdsa_sig->r);
-  BN_bin2bn(signature + 32, 32, ecdsa_sig->s);
+  BIGNUM* pr(BN_new());
+  BIGNUM* ps(BN_new());
+  BN_bin2bn(signature, 32, pr);
+  BN_bin2bn(signature + 32, 32, ps);
+  ECDSA_SIG_set0(ecdsa_sig.get(), pr, ps);
+
   return (ECDSA_do_verify(digest, SHA256_DIGEST_LENGTH, ecdsa_sig.get(), key) ==
           1);
 }
diff --git a/src/envoy/http/jwt_auth/jwt.h b/src/envoy/http/jwt_auth/jwt.h
index 750a1ca3..0a193174 100644
--- a/src/envoy/http/jwt_auth/jwt.h
+++ b/src/envoy/http/jwt_auth/jwt.h
@@ -22,6 +22,7 @@
 #include "envoy/json/json_object.h"
 #include "openssl/ec.h"
 #include "openssl/evp.h"
+#include "bssl_wrapper/bssl_wrapper.h"
 
 namespace Envoy {
 namespace Http {
diff --git a/src/envoy/tcp/sni_verifier/BUILD b/src/envoy/tcp/sni_verifier/BUILD
index 7d25863d..7cbcb0f7 100644
--- a/src/envoy/tcp/sni_verifier/BUILD
+++ b/src/envoy/tcp/sni_verifier/BUILD
@@ -40,6 +40,7 @@ envoy_cc_library(
     external_deps = ["ssl"],
     repository = "@envoy",
     deps = [
+        ":openssl_impl_lib",
         "@envoy//source/exe:envoy_common_lib",
     ],
 )
@@ -56,3 +57,19 @@ envoy_cc_test(
         "@envoy//test/mocks/server:server_mocks",
     ],
 )
+
+envoy_cc_library(
+    name = "openssl_impl_lib",
+    srcs = [
+        "openssl_impl.cc",
+    ],
+    hdrs = [
+        "openssl_impl.h",
+    ],
+    external_deps = [
+        "ssl",
+        "bssl_wrapper_lib",
+    ],
+    repository = "@envoy",
+)
+
diff --git a/src/envoy/tcp/sni_verifier/openssl_impl.cc b/src/envoy/tcp/sni_verifier/openssl_impl.cc
new file mode 100644
index 00000000..703d3649
--- /dev/null
+++ b/src/envoy/tcp/sni_verifier/openssl_impl.cc
@@ -0,0 +1,23 @@
+#include <arpa/inet.h>
+
+#include <algorithm>
+#include <cstdint>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "absl/strings/string_view.h"
+#include "openssl/hmac.h"
+#include "openssl/rand.h"
+#include "openssl/ssl.h"
+#include "openssl/x509v3.h"
+
+namespace Envoy {
+namespace Tcp {
+namespace SniVerifier {
+
+int getServernameCallbackReturn(int* out_alert) { return 1; }; //SSL_TLSEXT_ERR_OK; }
+
+}  // namespace SniVerifier
+}  // namespace Tcp
+}  // namespace Envoy
diff --git a/src/envoy/tcp/sni_verifier/openssl_impl.h b/src/envoy/tcp/sni_verifier/openssl_impl.h
new file mode 100644
index 00000000..1e9df30c
--- /dev/null
+++ b/src/envoy/tcp/sni_verifier/openssl_impl.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include <functional>
+#include <string>
+#include <vector>
+
+#include "openssl/ssl.h"
+
+namespace Envoy {
+namespace Tcp {
+namespace SniVerifier {
+
+int getServernameCallbackReturn(int* out_alert);
+
+}  // namespace SniVerifier
+}  // namespace Tcp
+}  // namespace Envoy
diff --git a/src/envoy/tcp/sni_verifier/sni_verifier.cc b/src/envoy/tcp/sni_verifier/sni_verifier.cc
index d3f854f7..3a3b04e8 100644
--- a/src/envoy/tcp/sni_verifier/sni_verifier.cc
+++ b/src/envoy/tcp/sni_verifier/sni_verifier.cc
@@ -16,6 +16,7 @@
 // the implementation (extracting the SNI) is based on the TLS inspector
 // listener filter of Envoy
 
+#include "src/envoy/tcp/sni_verifier/openssl_impl.h"
 #include "src/envoy/tcp/sni_verifier/sni_verifier.h"
 
 #include "common/common/assert.h"
@@ -36,7 +37,7 @@ const unsigned Config::TLS_MAX_SUPPORTED_VERSION = TLS1_3_VERSION;
 
 Config::Config(Stats::Scope& scope, size_t max_client_hello_size)
     : stats_{SNI_VERIFIER_STATS(POOL_COUNTER_PREFIX(scope, "sni_verifier."))},
-      ssl_ctx_(SSL_CTX_new(TLS_with_buffers_method())),
+      ssl_ctx_(SSL_CTX_new(TLS_method())),
       max_client_hello_size_(max_client_hello_size) {
   if (max_client_hello_size_ > TLS_MAX_CLIENT_HELLO) {
     throw EnvoyException(fmt::format(
@@ -48,20 +49,27 @@ Config::Config(Stats::Scope& scope, size_t max_client_hello_size)
   SSL_CTX_set_max_proto_version(ssl_ctx_.get(), TLS_MAX_SUPPORTED_VERSION);
   SSL_CTX_set_options(ssl_ctx_.get(), SSL_OP_NO_TICKET);
   SSL_CTX_set_session_cache_mode(ssl_ctx_.get(), SSL_SESS_CACHE_OFF);
-  SSL_CTX_set_tlsext_servername_callback(
-      ssl_ctx_.get(), [](SSL* ssl, int* out_alert, void*) -> int {
-        Filter* filter = static_cast<Filter*>(SSL_get_app_data(ssl));
 
-        if (filter != nullptr) {
-          filter->onServername(
-              SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name));
-        }
+  auto tlsext_servername_cb = +[](SSL* ssl, int* out_alert, void* arg) -> int {
+    Filter* filter = static_cast<Filter*>(SSL_get_app_data(ssl));
+    
+    if (filter != nullptr) {
+      absl::string_view servername = SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+      filter->onServername(servername);
+    }
+
+    int result = Envoy::Tcp::SniVerifier::getServernameCallbackReturn(out_alert);
+    return result;
+  };
+
+  SSL_CTX_set_tlsext_servername_callback(ssl_ctx_.get(), tlsext_servername_cb);
 
-        // Return an error to stop the handshake; we have what we wanted
-        // already.
-        *out_alert = SSL_AD_USER_CANCELLED;
-        return SSL_TLSEXT_ERR_ALERT_FATAL;
-      });
+  // During TLS1.3 handshake OpenSSL expects for server-side to have either a valid certificate or
+  // a certificate callback, otherwise the connection is not considered as tls1.3-capable (see
+  // ssl/statem/statem_lib.c:1496 - is_tls13_capable() function in openssl v1.1.1d).
+  // We use a dummy certificate callback to get through  the handshake.
+  auto cert_cb = [](SSL* ssl, void* arg) -> int { return 0; };
+  SSL_CTX_set_cert_cb(ssl_ctx_.get(), cert_cb, nullptr);
 }
 
 bssl::UniquePtr<SSL> Config::newSsl() {
diff --git a/src/envoy/tcp/sni_verifier/sni_verifier.h b/src/envoy/tcp/sni_verifier/sni_verifier.h
index bfcec841..553489fc 100644
--- a/src/envoy/tcp/sni_verifier/sni_verifier.h
+++ b/src/envoy/tcp/sni_verifier/sni_verifier.h
@@ -18,6 +18,7 @@
 #include "common/common/logger.h"
 #include "envoy/network/filter.h"
 #include "envoy/stats/scope.h"
+#include "bssl_wrapper/bssl_wrapper.h"
 #include "openssl/ssl.h"
 
 namespace Envoy {
diff --git a/src/envoy/tcp/sni_verifier/sni_verifier_test.cc b/src/envoy/tcp/sni_verifier/sni_verifier_test.cc
index 8fd3ae2b..5de82ab7 100644
--- a/src/envoy/tcp/sni_verifier/sni_verifier_test.cc
+++ b/src/envoy/tcp/sni_verifier/sni_verifier_test.cc
@@ -22,6 +22,7 @@
 #include "gmock/gmock.h"
 #include "gtest/gtest.h"
 #include "src/envoy/tcp/sni_verifier/config.h"
+
 #include "test/extensions/filters/listener/tls_inspector/tls_utility.h"
 #include "test/mocks/network/mocks.h"
 #include "test/mocks/server/mocks.h"
@@ -56,7 +57,9 @@ TEST(SniVerifierTest, MaxClientHelloSize) {
 class SniVerifierFilterTest
     : public testing::TestWithParam<std::tuple<uint16_t, uint16_t>> {
  protected:
-  static constexpr size_t TLS_MAX_CLIENT_HELLO = 250;
+  // The value of TLS_MAX_CLIENT_HELLO should be greater than the maximum size of clienthello in all tests
+  // (with the exception of SniTooLarge) for all tls versions
+  static constexpr size_t TLS_MAX_CLIENT_HELLO = 372;
 
   void SetUp() override {
     store_ = std::make_unique<Stats::IsolatedStoreImpl>();
@@ -192,7 +195,8 @@ TEST_P(SniVerifierFilterTest, BothSnisEmpty) {
 
 TEST_P(SniVerifierFilterTest, SniTooLarge) {
   runTestForClientHello(std::get<0>(GetParam()), std::get<1>(GetParam()),
-                        "example.com", std::string(TLS_MAX_CLIENT_HELLO, 'a'),
+      // Inner sni hostname length is such that the total length of clienthello exceeds the TLS_MAX_CLIENT_HELLO bytes
+                        "example.com", std::string(252, 'a'),
                         Network::FilterStatus::StopIteration);
   EXPECT_EQ(1, cfg_->stats().client_hello_too_large_.value());
   EXPECT_EQ(0, cfg_->stats().tls_found_.value());
diff --git a/tools/docker/BUILD b/tools/docker/BUILD
deleted file mode 100644
index f0c5fff4..00000000
--- a/tools/docker/BUILD
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright 2019 Istio Authors. All Rights Reserved.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#    http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-################################################################################
-#
-load("@io_bazel_rules_docker//container:image.bzl", "container_image")
-load(
-    "@io_bazel_rules_docker//container:container.bzl",
-    "container_push",
-)
-
-container_image(
-    name = "envoy_distroless",
-    base = "@distroless_cc//image",
-    tags = ["manual"],
-    tars = ["//src/envoy:envoy_tar"],
-)
-
-container_image(
-    name = "envoy_ubuntu",
-    base = "@bionic//image",
-    tags = ["manual"],
-    tars = ["//src/envoy:envoy_tar"],
-)
-
-container_push(
-    name = "push_envoy_distroless",
-    format = "Docker",
-    image = ":envoy_distroless",
-    registry = "gcr.io",
-    repository = "{DOCKER_REPOSITORY}",
-    tag = "{BUILD_CONFIG}-{BUILD_SCM_REVISION}",
-)
-
-container_push(
-    name = "push_envoy_ubuntu",
-    format = "Docker",
-    image = ":envoy_ubuntu",
-    registry = "gcr.io",
-    repository = "{DOCKER_REPOSITORY}",
-    tag = "ubuntu-{BUILD_CONFIG}-{BUILD_SCM_REVISION}",
-)
diff --git a/x_tools_imports.bzl b/x_tools_imports.bzl
index a2edabf3..be88f9ec 100644
--- a/x_tools_imports.bzl
+++ b/x_tools_imports.bzl
@@ -18,7 +18,7 @@ load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
 
 # Jun 23, 2017 (no releases)
 TOOLS_SHA = "e6cb469339aef5b7be0c89de730d5f3cc8e47e50"
-TOOLS_SHA256 = "fe9489eabcb598e13137d0641525ff3813d8af151e1418e6940e611850d90136"
+TOOLS_SHA256 = "840f59bbc76b1268d11764096ceace289aa3d1d497d1249cf516bc8350936eca"
 
 def go_x_tools_imports_repositories():
     BUILD_FILE = """
@@ -55,6 +55,6 @@ go_binary(
         name = "org_golang_x_tools_imports",
         build_file_content = BUILD_FILE,
         strip_prefix = "tools-" + TOOLS_SHA,
-        url = "https://github.com/golang/tools/archives/" + TOOLS_SHA + ".tar.gz",
+        url = "https://github.com/golang/tools/archive/" + TOOLS_SHA + ".tar.gz",
         sha256 = TOOLS_SHA256,
     )
-- 
2.24.1

